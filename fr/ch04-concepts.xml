<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="chap:concepts">
  <?dbhtml filename="behind-the-scenes.html"?>
  <title>Derrière le décor</title>
  
  <para id="x_2e8">À la différence de beaucoup d'outils de gestion de versions,
    les concepts sur lesquels se base Mercurial sont assez simples pour
    qu'il soit facile de comprendre comment le logiciel fonctionne.
    Bien que leur connaissance ne soit pas nécéssaire, je trouve utile
    d'avoir un <quote>modèle mental</quote> de ce qui se passe.</para>

  <para id="x_2e9">En effet, cette compréhension m'apporte la confiance que
    Mercurial a été développé avec soin pour être à la fois
    <emphasis>sûr</emphasis> et <emphasis>efficace</emphasis>. De surcroît,
    si il m'est facile de garder en tête ce que le logiciel fait lorsque
    j'accompli des tâches de révision, j'aurai moins de risques d'être
    surpris par son comportement.</para>

  <para id="x_2ea">Dans ce chapitre, nous décrirons tout d'abord les concepts
    essentiels de l'architecture de Mercurial, pour ensuite discuter quelques
    uns des détails intéressants de son implémentation.</para>

  <sect1>
    <title>Conservation de l'historique sous Mercurial</title>
    <sect2>
      <title>Suivi de l'historique pour un seul fichier</title>
      
      <para id="x_2eb">Lorsque Mercurial effectue un suivi des modifications
        faites à un fichier, il conserve l'historique pour ce fichier dans un
        <emphasis>filelog</emphasis> sous forme de métadonnées. Chaque entrée
        dans le filelog contient assez d'informations pour reconstituer une
        révision du fichier correspondant. Les filelogs sont des fichiers
        stockés dans le répertoire  <filename role="special"
          class="directory">.hg/store/data</filename>. Un filelog contient
        des informations de deux types: les données de révision, et un index
        pour permettre à Mercurial une recherche efficace d'une révision
        donnée.</para>

      <para id="x_2ec">Lorsqu'un fichier devient trop gros ou a un long
        historique, son filelog se voit stocker dans un fichier de données
        (avec un suffixe <quote><literal>.d</literal></quote>) et un fichier
        index (avec un suffixe<quote><literal>.i</literal></quote>)
        distincts. La relation entre un fichier dans le répertoire de travail
        et le  filelog couvrant le suivi de son historique dans le dépôt est
        illustré à la figure <xref linkend="fig:concepts:filelog"/>.</para>

      <figure id="fig:concepts:filelog">
        <title>Relations entre les fichiers dans le répertoire de travail et
        leurs filelogs dans le dépôt</title> 
        <mediaobject> <imageobject><imagedata
              fileref="figs/filelog.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject> </figure>

    </sect2>
    <sect2>
      <title>Gestion des fichiers suivis</title>
      
      <para id="x_2ee">Mercurial a recours à une structure nommée
        <emphasis>manifest</emphasis> pour rassembler les informations sur
        les fichiers dont il gère le suivi. Chaque entrée dans ce manifest
        contient des informations sur les fichiers présents dans une révision
        donnée. Une entrée enregistre la liste des fichiers faisant partie de la
        révision, la version de chaque fichier, et quelques autres
        métadonnées sur ces fichiers.</para>

    </sect2>
    <sect2>
      <title>Enregistrer les informations des changeset</title>

      <para id="x_2ef">Le <emphasis>changelog</emphasis> contient les
        informations sur chaque changeset. Chaque révision enregistre qui a
        committé un changement, le commentaire du changeset, d'autres
        morceaux d'information relatives au changeset et la révision du
        manifest à utiliser.</para>

    </sect2>
    <sect2>
      <title>Relations entre les révisions</title>

      <para id="x_2f0">A l'intérieur d'un changelog, d'un manifest, ou d'un
        filelog, chaque révision enregistre un pointeur vers son parent
        immédiat (ou à ses deux parents s'il s'agit d'une révision
        correspondant à une fusion (merge)). Comme mentionné plus haut, il y
        a aussi des relations entre les révisions <emphasis>à
          travers</emphasis> ces structures, qui sont de nature
        hiérarchique.</para>

      <para id="x_2f1">Pour chaque changeset dans un dépôt, il y a exactement
        une révision stockée dans le changelog. Chaque révision du changelog
        contient un pointeur vers une unique révision du manifest. Une
        révision du manifeste garde un pointeur vers une unique révision pour
        chaque filelog suivi lorsque le changeset est créé. Ces relations
        sont illustrées dans <xref linkend="fig:concepts:metadata"/>.</para>

      <figure id="fig:concepts:metadata">
        <title>Metadata relationships</title>
        <mediaobject> <imageobject><imagedata
              fileref="figs/metadata.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject> 
        </mediaobject>
      </figure>

      <para id="x_2f3">Comme l'illustration le monde, il
        <emphasis>n'</emphasis>y a <emphasis>pas</emphasis> de relation
        <quote>un à un</quote> entre les révisions dans un changelog,
        manifest ou filelog. Si un fichier que Mercurial suit n'a pas changé
        entre deux changesets, l'entrée pour ce fichier dans les deux
        révisions du manifest pointera vers la même révision de son filelog
        <footnote> <para id="x_725">Il est possible (bien qu'inhabituel)
            qu'un manifest reste le même entre deux changesets, auquel cas
            l'entrée du changelog pour ces changesets pointera vers la même
            révision du manifest.</para>
        </footnote>.</para>

    </sect2>
  </sect1>
  <sect1>
    <title>Stockage sûr et efficace</title>

    <para id="x_2f4">Les fondements des changelogs, des manifests et des
      filelogs sont fournis par une unique structure appelée le
      <emphasis>revlog</emphasis>.</para>

    <sect2>
      <title>stockage efficace</title>

      <para id="x_2f5">Le revlog fournit un stockage efficace des révision en
        utilisant un mécanisme <emphasis>delta</emphasis>. A lieu de stocker
        une copie complète d'un fichier à chaque révision, il stocke les
        changements requis pour transformer une révision plus ancienne en la
        nouvelle révision. Pour plusieurs type de données, ces deltas sont
        typiquement une fraction de pourcentage de la taille de la copie
        complète d'un fichier.</para>

      <para id="x_2f6">Certains systèmes de gestion de révisions obselètes
        peuvent seulement travailler avec les deltas de fichiers texte. Il
        doivent d'ailleurs stocker les fichiers binaires comme des images
        complètes ou encodées avec une représentation texte, chacune de ces
        approches étant gaspilleuse. Mercurial peut traiter les deltas de
        fichiers avec du contenu binaire arbitraire ; il n'a pas besoin de
        traiter spécialement du texte.</para>

    </sect2>
    <sect2 id="sec:concepts:txn">
      <title>Opérations sûres</title>

      <para id="x_2f7">Mercurial <emphasis>empile</emphasis> toujours les
        données à la fin d'un fichier revlog. Il ne modifie jamais la section
        d'un fichier après qu'il l'ait écrite. C'est à la foit plus robuste
        et efficace que les schémas qui ont besoin de modifier ou réécrire
        les données.</para>

      <para id="x_2f8">De plus, Mercurial traite chaque écriture comme une
        partie d'une <emphasis>transaction</emphasis> qui peut comprendre
        plusieurs fichiers. Une transaction est <emphasis>atomique</emphasis>
        : spot la transaction entière réussit et ses effets sont tous
        visibles aux lecteurs en une étape, soit la totalité est annulée.
        Cette garantie de l'atomicité signifie que si vous exécutez deux
        copies de Mercurial, où une lit les données et l'autre les écrit, le
        lecteur ne verra jamais un résultat partiellement écrit qui pourrait
        le perturber.</para>

      <para id="x_2f9">Le fait que Mercurial ne fasse qu'ajouter aux fichiers
        fait qu'il est facile de fournir cette garantie de transaction. Plus
        les choses sont faites simplement comme ça, plus vous pouvez être
        rassurés qu'elles sont bien faites.</para>
    
    </sect2>
    <sect2>
      <title>Récupération rapide</title>

      <para id="x_2fa">Mercurial évite habillement un piège commun à tous les
        vieux systèmes de gestion de révisions : le problème de la
        <emphasis>récupération inefficace</emphasis> La plupart des systèmes
        de gestion de révisions stockent le contenu d'une révision comme une
        série incrémentale de modifications faites à un
        <quote>snapshot</quote>. (Certains basent le snapshot sur la plus
        vieille révision, d'autres sur la plus récente.) Pour reconstruire
        une révision spécifique, vous devez d'abord lire le snapshot, et
        ensuite toutes les révisions entre le snapshot et votre révision
        cible. Plus vous avez d'historique accumulé dans un fichier, plus de
        révisions vous avez à lire, d'où la longueur que cela prend à
        reconstruire une révision particulière.</para>

      <figure id="fig:concepts:snapshot">
        <title>Snapshot d'un revlog, avec des deltas incrémentaux</title>
        <mediaobject> <imageobject><imagedata
              fileref="figs/snapshot.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject>
      </figure>

      <para id="x_2fc">L'inovation que Mercurial apporte à ce problème est
        simple mais effective. Une fois que la quantité cumulée de deltas
        d'informations stockées depuis le dernier snapshot excède un seuil
        fixé, il stock un nouveau snapshot (compréssé biensûr), plutôt qu'un
        nouveau delta. Ceci rend possible la reconstruction de
        <emphasis>toute</emphasis> révision d'un fichier rapidement. Cette
        approche fonctionne si bien que depuis, elle a été copiée par
        plusieurs autres systèmes de gestion de révisions.</para>

      <para id="x_2fd"><xref linkend="fig:concepts:snapshot"/> illustre
        l'idée. Dans une entrée d'un fichier d'index de revlog, Mercurial
        stock l'intervale des entrées depuis le fichier de données qu'il doit
        lire pour reconstruire une révision particulière.</para>

      <sect3>
        <title>En amont : l'influence de la compression vidéo</title>
      
        <para id="x_2fe">Si vous êtes familiés de la compression vidéo ou
          avez déjà regardé un programme TV par cable ou par un service
          satellite, vous devez savoir que la plupart des schémas de
          compression vidéo stockent chaque frame de vidéo comme un delta vis
          à vis de la frame précédente.</para>
      
        <para id="x_2ff">Mercurial emprunte cette idée pour rendre possible
          la reconstruction d'une révision à partir d'un snapshot et d'un
          petit nombre de deltas.</para>

      </sect3>
    </sect2>
    <sect2>
      <title>Identification et intégrité forte</title>

      <para id="x_300">Avec les deltas ou l'information du snapshot, une
        entrée d'un revlog contient un hash cryptographique des données qu'il
        représente. Ceci fait qu'il est difficile de construire les données
        d'une révision, mais facile de détecter une corruption
        accidentelle.</para>

      <para id="x_301">Les hash fournissent plus qu'un bon moyen de
        vérification contre la corruption ; il sont aussi utilisés comme
        identifiants pour les révisions. Le hash d'identification d'un
        changeset que vous voyez comme utilisateur final proviennent des
        révisions du changelog. Bien que les filelogs et le manifest
        utilisent aussi des hash, Mercurial ne les utilise qu'en arrière
        plan.</para>

      <para id="x_302">Mercurial vérifie que les hash sont corrects lorsqu'il
        récupère les révisions de fichiers et lorsqu'il récupère (pull) les
        changements d'un autre dépôt. S'il rencontre un problème d'intégrité,
        il se pleindra et arrêtera tout ce qu'il est en train de faire.</para>

      <para id="x_303">En plus de l'effet qu'il a sur l'efficacité des
        récupérations, l'utilisation de Mercurial de snapshots périodiques
        fait qu'il est plus robuste contre la corruption partielle de
        données. Si un revlog devient partiellement corrompu à cause d'une
        erreur matérielle ou d'un bug système, il est souvent possible de
        reconstruire certaines ou la plupart des révisions à partir des
        sections non corrompues du revlog, avant et après la section
        corrompue. Ceci ne serait pas possible à partir d'un modèle de
        stockage delta seul.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Historique des révisions, branches et fusions (merge)</title>

    <para id="x_304">Chaque entrée dans un revlog Mercurial connaît
      l'identité de l'ancètre immédiat de la révision, habituellement référé
      comme son <emphasis>parent</emphasis>. En fait, une révision contient
      de la place pour non pas un parent, mais deux. Mercurial utilise un
      hash spécial, appelé le <quote>null ID</quote> pour représenter l'idée
      qu'<quote>il n'y a pas de parent ici</quote>. Ce hash est simplement
      une chaîne de zéros.</para>

    <para id="x_305">Dans <xref linkend="fig:concepts:revlog"/>, vous pouvez
      voir un exemple de la structure conceptuelle d'un revlog. Les filelogs,
      manifests et changelogs ont tous cette même structure ; ils difèrent
      simplement dans le type de donnée stockée dans chaque delta ou
      snapshot.</para>

    <para id="x_306">La première révision d'un revlog (au bas de l'image) a
      le null ID dans chacune de ses cases parent. Pour une révision
      <quote>normale</quote>, sa première case parent contient l'ID de sa
      révision parent et la seconde contient le null ID, indiquant que cette
      révision n'a qu'un seul vrai parent. Si deux révisions ont le même
      parent, il s'agit de branches. Une révision qui représente une fusion
      (merge) entre deux branches a deux identifiants de révision normaux
      dans ses cases parents.</para>

    <figure id="fig:concepts:revlog">
      <title>The conceptual structure of a revlog</title>
      <mediaobject> <imageobject><imagedata
            fileref="figs/revlog.png"/></imageobject> <textobject><phrase>XXX
            add text</phrase></textobject>
      </mediaobject>
    </figure>

  </sect1>
  <sect1>
    <title>Le répertoire de travail</title>

    <para id="x_307">Dans un répertoire de travail, Mercurial stock une image
      des fichiers du dépôt à un changeset particulier.</para>

    <para id="x_308">Le répertoire de travail <quote>sait</quote> quel
      changeset il contient. Lorsque vous mettez à jour (update) le
      répertoire de travail à un certain changeset, Mercurial regarde la
      révision appropriée du manifest pour trouver quels fichier il suivait
      au moment où le changeset a été committé, et quelle révision de chaque
      fichier était alors courante. Il recrée ensuite une copie de chacun de
      ces fichiers, avec le même contenu qu'ils avaient lorsque le changeset
      a été committé.</para>

    <para id="x_309">La structure spéciale <emphasis>dirstate</emphasis>
      contient la connaissance de Mercurial sur le répertoire de travail.
      Elle est maintenue par un fichier appelé
      <filename>.hg/dirstate</filename> dans un dépôt. Les détails du
      dirstate sont le changeset vers lequel le répertoire de travail se met
      à jour (update), et tous les fichiers que Mercurial suit dans le
      répertoire de travail. Il permet aussi à Mercurial se connaître
      rapidement les fichiers modifiés, en enregistrant leurs heures de
      dernière modification et leur taille.</para>

    <para id="x_30a">Puisqu'une révision de revlog a des emplacements pour
      deux parents et peut représenter aussi bien une révision normale (avec
      un parent) ou une fusion de deux révisions anciennes, le dirstate a des
      emplacements pour deux parents. Lorsque vous utilisez la commande
      <command role="hg-cmd">hg update</command>, le changeset que vous
      mettez à jour est stocké dans l'emplacement du <quote>premier
        parent</quote>, et le null ID l'est dans le second. Lorsque vous
      utilisez la commande <command role="hg-cmd">hg merge</command> avec un
      autre changeset, le premier parent reste inchangé, et le second est
      rempli avec le changeset à partir duquel vous êtes en train de
      fusionner. La commande <command role="hg-cmd">hg parents</command> vous
      donne les parents du dirstate.</para>

    <sect2>
      <title>Que se passe-t-il lorsque vous committez</title>

      <para id="x_30b">Le dirstate stock les informations sur les parents
        pour plusqu'un simple livre de stockage. Mercurial utilise les
        parents du distate comme <emphasis>les parents d'un nouveau
          changeset</emphasis> lorsque vous committez.</para>

      <figure id="fig:concepts:wdir"> 
        <title>Le répertoire de travail peut avoir deux parents</title>
        <mediaobject>
          <imageobject><imagedata fileref="figs/wdir.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject></mediaobject>
      </figure>

      <para id="x_30d"><xref linkend="fig:concepts:wdir"/> montre l'état
        normal d'un répertoire de travail, où il n'y a qu'un seul changeset
        comme parent. Ce changeset est le <emphasis>tip</emphasis>, le
        changeset le plus récent dans le dépôt n'a pas d'enfant.</para>

      <figure id="fig:concepts:wdir-after-commit">
        <title>Le répertoire de travail gagne de nouveaux parents après un
        commit</title>
        <mediaobject>
          <imageobject><imagedata
              fileref="figs/wdir-after-commit.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject>
      </figure>

      <para id="x_30f">Il est utile de penser du répertoire de travail qu'il
        est <quote>le changeset que je vais committer</quote>. Chaque fichier
        que vous dites à mercurial d'ajouter, de supprimer, de renommer ou de
        copier va être reflété dasn ce changeset, tout comme les
        modifications de n'importe quel fichier que Mercurial est déjà en
        train de suite ; le nouveau changeset aura les mêmes parents que le
        répertoire de travail.</para>

      <para id="x_310">Après un commit, Mercurial va mettre à jour les
        parents du répertoire de travail, ainsi, le premier parents est l'ID
        du nouveau changeset, et le second, le nullID. Ceci est illustré dans
        <xref linkend="fig:concepts:wdir-after-commit"/>. Mercurial ne touche
        à aucun des fichiers du répertoire de travail lorsque vous committez
        ; il modifie simplement le dirstate pour noter ses nouveaux
        parents.</para>

    </sect2>
    <sect2>
      <title>Création d'une nouvelle <quote>head</quote></title>

      <para id="x_311">Il est parfaitement normal de faire un update du
        répertoire de travail à un changeset autre que le tip courant. Par
        exemple, vous pourriez vouloir savoir ce à quoi votre projet
        ressemblait le dernier Mardi, ou regarder le changeset qui a
        introduit un bug. Dans des cas comme ça, la chose naturelle à faire
        est de faire un update du répertoire de travail au changeset qui vous
        intéresse, et ensuite d'en examiner les fichiers pour regarder leurs
        contenus comme ils l'étaient lorsque vous avez commité ce changeset.
        L'effet de ceci est montré dans <xref
          linkend="fig:concepts:wdir-pre-branch"/>.</para>

      <figure id="fig:concepts:wdir-pre-branch">
        <title>Le répertoire de travail, "updaté" pour un changeset plus
        ancien</title>
        <mediaobject> <imageobject><imagedata
              fileref="figs/wdir-pre-branch.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject>
      </figure>

      <para id="x_313">En ayant fait un update du répertoire de travail vers
        un changeset plus ancien, qu'est-ce qu'il se passe si vous faites des
        changements et ensuite committez ? Mercurial se comporte comme je
        l'ai fait remarqué plus haut. Les parents du répertoire de travail
        deviennent les parents du nouveau changeset. Ce nouveau changeset n'a
        pas d'enfant, donc il devient le nouveau tip. Le dépôt contient
        maintenant deux changesets qui n'ont pas d'enfant ; on appelle ceci
        des <emphasis>heads</emphasis>. Vous pouvez voir la structire que
        cela crée dans <xref linkend="fig:concepts:wdir-branch"/>.</para>

      <figure id="fig:concepts:wdir-branch">
        <title>Après un commit fait pendant la synchronisation avec un ancien
        changeset</title>
        <mediaobject> <imageobject><imagedata
              fileref="figs/wdir-branch.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject>
      </figure>

      <note>
        <para id="x_315">Si vous êtes nouveau à Mercurial, vous devez garder
          à l'esprit une <quote>erreur</quote> commune, qui est d'utiliser la
          commande <command role="hg-cmd">hg pull</command> sans aucune
          option. Par défaut, la commande <command role="hg-cmd">hg
            pull</command> <emphasis>ne fait pas</emphasis> d'update sur le
          répertoire de travail, ainsi, vous allez récupérer les nouveaux
          changesets dans votre dépôt, mais le répertoire de travail va
          rester synchroniser au même changeset qu'il l'était avant le pull.
          Si vous faites des changements et committez ensuite, vous allez
          créer une nouvelle head puisque votre répertoire de travail n'est
          pas synchronisé à ce que le tip actuel est. Pour combiner les
          opérations d'un pull suivi d'un update, exécutez run <command>hg
            pull -u</command>.</para>
      
        <para id="x_316">Je place le mot <quote>erreur</quote> entre
          guillemets parce que tous ce dont vous avez besoin de faire pour
          rectifier la situation où vous avez créé une nouvelle head par
          accident est un <command role="hg-cmd">hg merge</command> suivi
          d'un <command role="hg-cmd">hg commit</command>.  En d'autres mots,
          ceci n'a presque jamais de conséquences négatives ; il s'agit juste
          d'une surprise pour les nouveaux arrivants. Je discuterai d'autres
          moyens d'éviter ce comportement, et pourquoi Mercurial agit de
          cette façon surprenante plus tard.</para>
      </note>

    </sect2>
    <sect2>
      <title>Fusionner (merge) les changements</title>

      <para id="x_317">Lorsque vous exécutez la commande <command
          role="hg-cmd">hg merge</command>, Mercurial laisse le premier
        parent du répertoire de travail inchangé et fixe le second au
        changeset avec lequel vous fusionnez (merge), comme montré dans <xref
          linkend="fig:concepts:wdir-merge"/>.</para>

      <figure id="fig:concepts:wdir-merge">
        <title>Fusionner (merge) deux heads</title>
        <mediaobject>
          <imageobject> <imagedata fileref="figs/wdir-merge.png"/>
        </imageobject> <textobject><phrase>XXX add text</phrase></textobject>
      </mediaobject>
      </figure>

      <para id="x_319">Mercurial doit aussi modifier le répertoire de
        travail pour fusionner les fichiers gérés dans les deux changesets.
        Un peu simplifié, le processus de fusion fonctionne comme ça : pour
        chaque fichier dans le manifest de chaque changeset.</para>

      <itemizedlist>
        <listitem><para id="x_31a">Si aucun changeset n'a modifié un fichier,
            ne rien faire avec ce fichier.</para> </listitem>
        <listitem><para id="x_31b">Si un changeset a modifié un fichier et
            que l'autre ne l'a pas fait, créer une copie modifiée du fichier
            dans le répertoire de travail.</para> </listitem>
        <listitem><para id="x_31c">Si un changeset a modifié un fichier, et
            que l'autre ne l'a pas fait (ou l'a supprimé), supprimer le
            fichier du répertoire de travail.</para> </listitem>
        <listitem><para id="x_31d">Si un changeset a supprimé un fichier,
            mais que l'autre a modifié le fichier, demander à l'utilisateur
            quoi faire : garder le fichier modifié ou le supprimer ?</para>
        </listitem>
        <listitem><para id="x_31e">Si chacun des chengeset a modifié un
            fichier, invoquer le programme externe de fusion pour choisir les
            nouveaux contenus pour le fichier fusionné. Ceci peut demander
            des entrées de l'utilisateur.</para></listitem>
        <listitem><para id="x_31f">Si un changeset a modifié un fichier, et
            que l'autre a renommé ou copié le fichier, être sûr que les
            changements suivent le nouveau nom du fichier.</para></listitem>
      </itemizedlist>
      
      <para id="x_320">Il y a plus de détails&emdash;fusionner a beaucoup de
        cas anguleux&emdash;mais ceux-ci sont des chois plus communs qui sont
        invoqués pendant une fusion (merge). Comme vous pouvez le voir, la
        plupart des cas sont entièrement automatiques, et effectivement, la
        plupart des fusions (merge) se terminent automatiquement, sans avoir
        besoin d'entrées pour résoudre un conflit.</para>

      <para id="x_321">Lorsque vous pensez à ce qu'il se passe lorsque vous
        committez après un merge, une fois encore, le répertoire de travail
        est <quote>le changeset que je suis sur le point de
          committer</quote>. Après que la commande <command role="hg-cmd">hg
          merge</command> ait terminé, le répertoire de travail a deux
        parents ; ceux ci vont devenir les parents du nouveau
        changeset.</para>

      <para id="x_322">Mercurial vous permet d'exécuter de multiples fusions,
        mais vous devez committer le résultat de chaque fusion individuelle
        comme vous avancez. Ceci est nécessaire puisque Mercurial ne stock
        que deux parents pour chaque révision et le répertoire de travail.
        Alors qu'il serait techniquement faisble de fusionner de multiples
        changesets en même temps, Mercurial interdit cette simplicité. Avec
        des fusions multplus, les risques de confision utilisateur, de
        conflits néfastes de résolutions, et faire une pagaille d'une fusion
        grossiraient intollérablement.</para>

    </sect2>

    <sect2>
      <title>Fusions et renommages</title>

      <para id="x_69a">Un nombre surprenant de systèmes de gestion de
        révision fait peu ou pas attention à un <emphasis>nom</emphasis> au
        cours du temps. Par exemple, il était habituel que si un fichier
        était renommé d'un coté de la fusion, les changements à partir de
        l'autre coté étaient supprimés silencieusement.</para>

      <para id="x_69b">Mercurial enregistre les metadata lorsque vous lui
        dite d'exécuter un renommage ou une copie. Il utilise ces metadata
        durant une fusion pour faire les bonnes choses dans le cas d'un
        merge. Par exemple, si je renomme un fichier et que vous l'éditez
        sans le renommer, lorsque l'on fusionne, le fichier sera renommé et
        aura les éditions appliquées.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>D'autres fonctionnalités intéressantes</title>

    <para id="x_323">Dans les sections au dessus, j'ai tenté de mettre
      l'accent sur certains aspects importants du design de Mercurial pour
      illustrer l'attention particulière qui a été portée à la fiabilité et à
      la performance.Cependant, l'attention aux détails ne s'arrête pas ici.
      Il y a de nombreux aspects sur la construction de Mercurial que je
      trouve personnellement intéressante. Je détaillerai quelques un d'eux
      ici, séparément des éléments du <quote>big ticket</quote> ci dessus,
      ainsi, si vous êtes intéressés, vous pourrez avoir une meilleure idée
      de la quantité de pensées qu'il y a derrière un système bien
      défini.</para>

    <sect2>
      <title>Compression élégante</title>

      <para id="x_324">Lorsque cela est approprié, Mercurial stocke les
        snapshots et deltas sous une forme compressée. Il le fait en
        <emphasis>essayant</emphasis> toujours de compression un snapshot ou
        un delta, mais en ne stockant la version compression que si celle ci
        est plus petite que la version non compressée.</para>

      <para id="x_325">Ceci signifie que Mercurial fait <quote>la bonne
          chose</quote> lorsqu'il stocke un fichier dont la forme native est
        compressée, comme une archive <literal>zip</literal> ou une image
        JPEG. Lorsque ces types de fichiers sont compressés une seconde fois,
        le fichier obtenu est habituellement plus gros que la forme
        compressée une seule fois et Mercurial stockera alors le
        <literal>zip</literal> ou JPEG.</para>

      <para id="x_326">Les Deltas entre les révisions d'un fichier compressé
        sont habituellement plus gros que les snapshots du fichier, et
        Mercurial fait à nouveau <quote>la bonne chose</quote> dans ces cas.
        Il trouve qu'un delta dépasse le seuil auquel il devrait stocker un
        snapshot complet du ficheir, alors il stocke le snapshot, en gagnant
        encore de la place en comparaison à une approche naïve delta
        seulement.</quote>

      <sect3>
        <title>Recompression réseau</title>
      
        <para id="x_327">Lors du stockage des révisions sur le disque,
          Mercurial utilise l'algorithme de compression
          <quote>deflate</quote> (le même que celui utilisé pour le format
          d'archive populaire <literal>zip</literal>), qui est un bon
          comprimis entre la vitesse et le taux de compression. Cependant,
          lors de la transmission d'une révision de données par une connexion
          réseau, Mercurial décompresse les données de révision
          compressées.</para>
      
        <para id="x_328">Si la connexion est au dessus de HTTP, mercurial
          recompresse le flux entier de données en utilisant un algorithme de
          compression qui donne un meilleur taux de compression (l'algorithme
          Burrows-Wheeler utilisé principalement par le package de
          compression <literal>bzip2</literal>). Cette combinaison de
          l'algorithme et de compression du flux entier (plutôt que pour une
          révision à la fois) réduit substanciellement le nombre de bits qui
          sont transférés, résultant dans une performance réseau accrue sur
          la plupart des supports.</para>
      
        <para id="x_329">Si la connexion est au dessus de
          <command>ssh</command>, Mercurial <emphasis>ne</emphasis>
          recompresse <emphasis>pas</emphasis> le flux puisque
          <command>ssh</command> peut déjà le faire par lui même. Vous pouvez
          demander à Mercurial de toujours utiliser la compression
          <command>ssh</command> en éditant le fichier
          <filename>.hgrc</filename> de votre répertoire personnale comme ci
          dessous.</para>
      
        <programlisting>[ui]
ssh = ssh -C</programlisting>

      </sect3>
    </sect2>
    <sect2>
      <title>Ordres de Lecture/Écriture et atomicité</title>

      <para id="x_32a">Ajouter à la fin des fichiers n'est pas toute
        l'histoire lorsque l'on cherche à garantir que le lecteur ne verra
        pas qu'une écriture partielle. Si vous relisez <xref
          linkend="fig:concepts:metadata"/>, les révisions dans le changelog
        pointent vers les révisions dans le manifest, et les révisions du
        manifest pointent vers les révisions du filelog. Cette hiérarchie est
        délibérée.</para>

      <para id="x_32b">L'écriture commence une transaction en écrivant dans
        le filelog et dans les données du manifest, et n'écrit aucune donnée
        changelog tant que ce n'est pas terminé. La lecture commence en
        lisant les données du changelog, puis les données du manifest, et
        enfin les données du filelog.</para>

      <para id="x_32c">Puisque que l'écriture ne finit pas d'écrire les
        données du filelog et du manifest avant d'écrire dans le changelog,
        la lecture ne verra jamais un pointeur vers une révision du manifest
        partiellement écrite à partir du changelog, et ne lira jamais un
        pointeur vers une révision du filelog partiellement écrite dans le
        manifest.</para>

    </sect2>
    <sect2>
      <title>Accès concurrent</title>

      <para id="x_32d">La garantie de l'ordre de lecture/écriture et
        de l'atomicite signifie que Mercurial n'a jamais besoin de poser de
        <emphasis>lock</emphasis> sur un dépôt lorsqu'il lit des données,
        même si le dépôt est en train d'être écrit au même moment que la
        lecture a lieue. Ceci a un grand impact sur la fiabilité ; vous
        pouvez avoir un nombre arbitraire de processus Mercurial qui lisent
        dans risque en même temps les données d'un dépôt, peu importe s'il
        est en train d'être lu ou non.</para>

      <para id="x_32e">La nature sans <quote>lock</quote> de la lecture
        signifie que si vous partagez un dépôt sur un système
        multi-utilisateurs, vous n'avez pas besoin de donner aux autres
        utilisateurs locaux la permission d'<emphasis>écrire</emphasis> sur
        votre dépôt pour qu'ils soient capable de faire un clone ou un pull
        des changements à partir de celui ci ; ils ont seulement besoin de la
        permission en <emphasis>lecture</emphasis>. (Il
        <emphasis>ne</emphasis> s'agit <emphasis>pas</emphasis> d'une
        fonctionnalité commune à travers les systèmes de gestion de révision,
        donc ne prenez pas ça pour garanti ! La plupart ont besoin que les
        lecteurs soient capables de mettre un lock sur le dépôt pour y
        accéder en toute sécurité, et ceci demande des permissions en
        écriture, sur au moins un dépertoire, ce qui provoque biensûr toutes
        sortes de problèmes néfastes et ennuyants relatifs à la sécurité et à
        l'administration.)</para>

      <para id="x_32f">Mercurial utilise des locs pour assurer qu'un seul
        processus peut écrire dans le dépôt à un moment donné (le mécanisme
        de lock est sûr, même sur des systèmes de fichiers qui sont connus
        pour être hostiles aux locks, comme NFS). Si un dépôt dispose d'un
        lock, un processus qui cherche à écrire va attendre un peu avant de
        retenter pour voir si le dépôt perd son lock, mais le dépôt garde
        trop longtemps son lock, le processus qui tente d'écrire va expirer
        (time out) après un moment. Celà veut dire par exemple que vous
        scripts lancés quotidiennement n'attendront pas toujours et boucler
        si un système crashait sans avertissement, par exemple. (Oui, le
        timeout est configurable, de zéro à l'infini.)</para>

      <sect3>
	<title>Accès dirstate sûr</title>

	<para id="x_330">Comme avec les données de révision, Mercurial ne prend pas
    de lock pour lire le fichier dirstate ; il n'acquier pas un lock pour
    y écrire. Pour empécher la possibilité de lire une copie partiellement
    écrite du fichier dirstate, Mercurial écrit à un fichier avec un nom
    unique dans le même répertoire que le fichier dirstate, ensuite renomme
    le fichier temporaire automatiquement en <filename>dirstate</filename>.
    Le fichier nommé <filename>dirstate</filename> est ainsi garanti d'être
    écrit totalement, et non partiellement.</para>

      </sect3>
    </sect2>
    <sect2>
      <title>Empécher les recherches</title>

      <para id="x_331">L'absence de recherche sur les têtes de disques est
        critique pour la performance de Mercurial, puisque toute recherche
        est beaucoup plus coûteuse comparativement à une grosse opération de
        lecture.</para>

      <para id="x_332">C'est pour ça, par exemple, que le dirstate est stocké
        dans un unique fichier. S'il y avait eu un dirstate par répertoire
        que Mercurial suivait, le disque aurait recherché une fois par
        répertoire. Au lieu de ça, Mercurial lit entièrement un unique
        fichier, en une étape.</para>

      <para id="x_333">Mercurial utilise aussi un schéma <quote>copie à
          l'écriture</quote> lorsqu'il clone un dépôt sur un stockage local.
        Au lieu de copier chaque fichier revlog depuis l'ancien dépôt vers le
        nouveau dépôt, il crée un <quote>lien physique</quote>, qui est le
        plus court chemin pour dire <quote>Ces deux noms pointent vers le
          même fichier</quote>. Lorsque Mercurial est sur le point d'écrire
        sur l'un des revlogs de ces fichiers, il vérifie si le nombre de noms
        pointant sur ce fichier est plus grand que un. Si c'est le cas, plus
        d'un dépôt utilise le fichier, donc Mercurial crée une nouvelle copie
        du fichier qui est privée à ce dépôt.</para>

      <para id="x_334">Quelques développeurs de systèmes de gestion de
        révision ont montré que cette idée de faire une copie privée complète
        d'un fichier n'est pas vraiment efficace dans son utilisation du
        stockage. Bien que ce soit vrai, le stockage est peu onéreux, et
        cette méthode donne la plus grande performance lorsque l'on reporte
        la plupart des journalisations au système d'exploitation. Un schéma
        alternatif réduirait certainement la performance tout en augmentant
        la complexité du logiciel, mais la vitesse et la simplicité sont els
        clefs du <quote>sentiment</quote> de l'utilisation
        quotidienne.</para>

    </sect2>
    <sect2>
      <title>Autres contenus du dirstate</title>

      <para id="x_335">Puisque Mercurial ne vous force pas à dire lorsque
        vous modifiez un fichier, il utilise le dirstate pour stocker
        certaines informations supplémentaires pour déterminer efficacement
        si vous avez ou non modifié un fichier. Pour chaque fichier du
        répertoire de travail, il stocke l'heure à laquelle il a été modifié,
        ainsi que la taille du fichier à cette heure.</para>

      <para id="x_336">Lorsque vous faites explicitement un <command
          role="hg-cmd">hg add</command>, <command role="hg-cmd">hg
          remove</command>, <command role="hg-cmd">hg rename</command> ou
        <command role="hg-cmd">hg copy</command> sur des fichiers, Mercurial
        met à jour le dirstate afin de savoir quoi faire lorsque vous
        effectuez un commit.</para>

      <para id="x_337">Le dirstate aide Mercurial à vérifier efficacement le
        status des fichiers dans un dépôt.</para>

      <itemizedlist>
        <listitem> <para id="x_726"> Lorsque Mercurial vérifie l'état d'un
            fichier du répertoire de travail, il compare d'abord la date de
            dernière modification du fichier avec celle enregistrée dans le
            dirstate qui correspond à Mercurial a écrit en dernier sur ce
            fichier. Si le temps de dernière modification correspond au temps
            où Mercurial a écrit le fichier, celui ci n'a pas été modifié,
            donc mercurial n'a pas besoin de revérifier.</para> </listitem>
        <listitem> <para id="x_727"> Si la taille du fichier a changé, celui
            ci a été modifié. Si la date de modification a changé mais que la
            taille est restée inchangée, seulement à ce moment là Mercurial
            doit vérifier le contenu du fichier pour savoir s'il a été
            modifié.</para> </listitem>
      </itemizedlist>

      <para id="x_728">Enregistrer la date de modification et la taille
        réduit grandement le nombre d'opérations de lecture que Mercurial
        doit effectuer lorsque l'on utilise une commande comme <command>hg
          status</command>. Le résultat est un grand gain de
        performance.</para>
    </sect2>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
