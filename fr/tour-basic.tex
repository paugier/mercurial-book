\chapter{Un rapide tour de Mercurial}
\label{chap:tour-basic}

\section{Installer Mercurial sur votre système}
\label{sec:tour:install}

Des paquetages binaires de Mercurial sont disponibles pour la plupart
des systèmes d'exploitation, ce qui rend facile l'utilisation immédiate
de Mercurial sur votre ordinateur.

\subsection{Linux}

Parce que chaque distribution de Linux a ses propres outils de gestion
de paquets, politiques et rythmes de développements, il est difficile de
donner un ensemble d'instructions fixes pour installer les binaires de
Mercurial. La version de Mercurial avec laquelle vous vous retrouverez
dépendra grandement de l'activité de la personne en charge du paquetage
pour la distribution.

Pour rester simple, je me concentrerai sur l'installation de Mercurial
en ligne de commande, sous les plus courantes des distributions. La 
plupart des distributions fournissent des gestionnaires graphiques de
paquetage qui vous permettront d'installer Mercurial en quelques clicks.
Le paquetage devrait se nommer \textit{mercurial}.

\begin{itemize}
\item[Debian]
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}

\item[Fedora Core]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Gentoo]
  \begin{codesample4}
    emerge mercurial
  \end{codesample4}

\item[OpenSUSE]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Ubuntu] Le paquetage de Mercurial d'Ubuntu est construit sur celui de Debian. 
              Pour l'installer, exécute simplement les commandes suivantes:
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}
  Les paquetages Ubuntu pour Mercurial ont tendance à être un peu en retard
  par rapport au paquetage Debian (au moment de l'écriture de ce livre, il
  faut compter un peu près un retard de 7 mois), ce qui signifie que parfois 
  sur Ubuntu, vous risquez de rencontrer des problèmes qui ont été corrigés 
  depuis longtemps dans les paquetages Debian.
\end{itemize}

\subsection{Solaris}

SunFreeWare, à \url{http://www.saufreeware.com}, est une bonne source 
pour trouver un vaste nombre de paquets précompilés pour 32 ou 64 bits
Intel et les architecture Sparc, dont les versions courantes de Mercurial.

\subsection{Mac OS X}

Lee Cantey publie un installeur de Mercurial pour Mac OS~X sur le site 
\url{http://mercurial.berkwood.com}.  Ce paquetage fonctionne sur les 
architectures Intel-~et PowerPCC. Avant de vous en servir, vous devez
installer une version Universel MacPython~\cite{web:macpython}. C'est
assez facile à faire : suivez simplement les instructions sur le site
de Lee.

Il est aussi possible d'installer Mercurial en utilisant Fink ou MacPorts,
deux outils de gestion de paquetage libres pour Mac OS X. Si vous avez 
Fink, utiliser \command{sudo fink install mercurial-py25}. Si vous avez 
acPorts, \command{sudo port install mercurial}.

\subsection{Windows}

Lee Cantey publie aussi un installeur de Mercurial pour Windows sur le site
\url{http://mercurial.berkwood.com}. Ce paquetage n'a aucune dépendance 
externe, il fonctionne ``tout court''.

\begin{note}
  Le version de Windows de Mercurial ne convertie pas automatiquement
  les retour chariot Windows et Unix. Si vous désirez partager votre
  travail avec des utilisateurs Unix, vous devez faire un peu de configuration
  supllémentaire. XXX En dire plus.
\end{note}

\section{Commencer à utiliser Mercurial}

Pour commencer, nous utiliserons la commande \hgcmd{version} pour vérifier
si Mercurial est installé proprement. Les informations affichées sur la 
version ne sont pas réellement importante en soit, c'est surtout de savoir
si elles s'affichent qui nous intéresse.
\interaction{tour.version}

\subsection{L'aide intégrée}

Mercurial fournit un système d'aide intégré, ce qui est inestimable quand
vous vous retrouvez coincé à essayer de vous rappeler comment lancer telle
ou telle commande. 
Si c'est le cas, exécuter simplement \hgcmd{help}; il vous aidera à imprimer
une brève liste de commandes, avec une description de ce qu'elles font. Si vous
demandez de l'aide sur une commande spécifique (voir ci dessous), il affichera
des informations plus détaillées.
\interaction{tour.help}
Pour un niveau d'informations encore plus détaillées (ce dont vous aurez rarement
besoin), exécuter \hgcmdargs{help}{\hggopt{-v}}.  L'option \hggopt{-v} est 
l'abréviation de \hggopt{--verbose}, et indique à Mercurial d'afficher plus 
d'informations que d'habitude.

\section{Travailler avec un dépot}

Avec Mercurial, tout se déroule au sein du \emph{dépot}\footnote{NdT: Dépôt est
la traduction que j'ai retenue pour tout l'ouvrage du terme anglais \textit{repository}}.
Le dépôt d'un projet contient tous les fichiers qui ``appartiennent'' au projet.

Il n'y a rien de particulièrement magique au sujet de ce dépot, c'est
simplement une arboresence sur votre système de fichiers que Mercurial
traite de manière spéciale. Si vous pouvez renommer ou effacer ce répertoire
à n'importe quel moment, en utilisant la ligne de commande ou votre
explorateur de fichiers.

\subsection{Faire une copie locale de votre dépot}

\emph{Copier} un dépôt est just un peu spécial. Bien que vous 
puissiez utiliser une commande habituelle de copie pour copier
votre dépôt, il vaut mieux utiliser une commande fournie par
Mercurial. Cette commande est appelée \hgcmd{clone}, car elle
crée une copie identique d'un dépôt existant.
\interaction{tour.clone}
Si votre opération de clonage réussit, vous devriez maintenant
avoir un répertoire local appelé \dirname{hello}. Ce répertoire
contiendra quelques fichiers.
\interaction{tour.ls}
Ces fichiers ont le même contenu et historique dans votre dépôt
qu'ils ont dans le dépôt que vous avez cloné.

Chaque dépôt Mercurial est complet, autonome et indépendant. Il
contient sa propre copie privé des fichiers du projet et de leurs
historiques. Le clone d'un dépôt se souvient de la localisation du
dépôt à partir duquel il a été clôné, mais il ne communique pas avec
ce dernier, ou un autre, à moins que vous ne lui demandiez.

Ce que tout ceci signifie pour le moment est que nous sommes libre
d'expérimenter avec ce dépôt, confiant dans le fait qu'il s'agit d'un
``bac à sable'' qui n'affectera personne d'autres.

\subsection{Quel est le contenu d'un dépôt ?}

Prêtons plus attention un instant au contenu d'un dépôt. Nous voyons 
qu'il contient un répertoire nommée \dirname{.hg}. C'est ici que Mercurial
conserve toutes ses métadonnées.
\interaction{tour.ls-a}

Le contenu du répertoire \dirname{.hg} et ses sous répertoires sont les
seules propre à Mercurial. Tout les autres fichiers et répertoire dans 
le répertoire sont à vous, et vous pouvez faire ce que vous en voulez.

Pour introduire un peu de terminologie, le répertoire \dirname{.hg} est
un ``vrai'' dépôt, et tout les fichiers et les répertoires qui coexistent
avec lui, sont désigné sous le nom de \emph{espace de travail}\footnote{NdT: 
\textit{working directory}}. Une manière facile de se rappeler cette 
distinction est de retenir que le \emph{dépôt} contient l'\emph{historique}
de votre projet, alors que l'\emph{espace de travail} contient une \emph{copie
précise}\footnote{NdT: Ce terme est une traduction du terme anglais 
\textit{snapshot}. Il est traduit ici pour faciliter la lecture, mais ne sera
plus traduit par la suite.} de votre projet à un certain point de son
historique.

\section{Une ballade dans l'historique}

Une des premières choses que vous aurez envie de faire avec un nouveau
dépôt, sera de comprendre son historique. La commande \hgcmd{log} vous
donne une vue de l'historique.
\interaction{tour.log}
Par défaut, cette commande affiche à l'écran un bref paragraphe pour chaque
révision enregistrée pour ce projet. Dans la terminologie de Mercurial, nous
appelons chacun de ces évènements enregistrés un \emph{changeset}, parce 
qu'il contient un ensemble de mofications sur plusieurs fichiers.

La commande \hgcmd{log} affiche ainsi ces informations:
\begin{itemize}
\item[\texttt{changeset}] Ce champ contient un nombre, séparé par une 
  virgule, d'une chaine hexadécimal. Il s'agit en effet d'\emph{identifiants}
  pour un \textit{changeset}. Il y a deux identifiants car le numéro de
  la révision est plus court et plus à facile à saisir qu'une séquence
  hexadécimale.
\item[\texttt{utilisateur}] L'identité de la personne qui a crée ce 
  \textit{changeset}. C'est un champ libre de forme, mais la plupart du
  temps il contient le nom et l'email de la personne.
\item[\texttt{date}] La date et l'heure à laquelle le \textit{changeset}
  a été crée, ainsi que le \textit{timezone} dans laquelle il a été crée. %%%TODO: Translate 'timezone' properly
  (La date et l'heure sont locals à cette \textit{timezone}, ils indiquent
  donc quelle date et quelle il était pour la personne qui a crée ce 
  \textit{changeset}.)
\item[\texttt{résumé}] La première du message que le créateur a associée à
  son \textit{changeset} pour le décrire.
\end{itemize}

Par défaut, la commande \hgcmd{log} n'affiche qu'un résumé, il manque 
beaucoup de détails.


La figure~\ref{fig:tour-basic:history} fournit un représentation graphique
de l'historique du dépôt \dirname{hello}, pour rendre plus facile de voir
dans quelle direction l'historique se ``déroule''\footnote{NdT: \textit{flowing in}.}.
Nous reviendrons régulièrement à cette représentation dans ce chapitre et
ceux qui suivent.

\begin{figure}[ht]
  \centering
  \grafix{tour-history}
  \caption{Représentation graphique du dépôt \dirname{hello} }
  \label{fig:tour-basic:history}
\end{figure}

\subsection{Changesets, révisions, et discuter avec les autres}

Comme l'anglais est réputé pour un langage maladroit, et que l'informatique
est la source de bien des erreurs terminologique (pourquoi utiliser un
seul terme quand quatre feront l'affaire ?), la gestion de version a une
variété de mot et de phrases qui veulent dire la même chose. Si vous 
parlez à quelqu'un de l'historique de Mercurial à d'autres personnes, 
vous constaterez que souvent le mot ``\textit{changeset}'' est compressé 
en juste ``change'' ou (à l'écrit) ``cset'', et même parfois un 
\textit{changeset} simplement ``révision'', abrégé en ``rev''.

Bien que le \emph{mot} que vous utilisez pour désigner le concept de
\textit{changeset} importe peu, l'\emph{identifiant} que vous utilisez
pour désigner un \emph{spécifique} \textit{spécifique} a une grande
importance. Rappelez vous que le \textit{changeset} affiché par la 
commande \hgcmd{log} identifie un \textit{changeset} à la fois avec
un numéro de révision et une séquence hexadécimale.

\begin{itemize}
\item Le numéro de révision est \emph{seulement valable dans ce dépôt},
\item alors que la séquence hexadécimale est un \emph{identifiant 
	permanent, et immutable } qui pourra toujours être associé à %%%TODO: Immutable ? Is this french ?
	\textit{changeset} exacte de \emph{chaque} copie de votre dépôt.
\end{itemize}

La distinction est importante. Si vous envoyez un email à quelqu'un en
parlant de la ``révision 33'', il est très probable que sa révision~33
\emph{ne sera pas la même} que la votre. La raison de ceci est que le
numéro de révision dépend de l'ordre dans lequel les modifications sont
arrivés dans le dépôt, et il n'y a aucune garantie que les mêmes changements
soient arrivés dans le même ordre dans différents dépôts. Trois modifications
$a,b,c$ peuvent aisément apparaitre dans un dépôt comme $0,1,2$, et dans
un autre comme $1,0,2$.

Mercurial utilise les numéro de révision uniquement comme des raccourcis
pratique. Si vous devez disctuer d'un \textit{changeset} avec quelqu'un, 
our faire un enregistrement d'un \textit{changeset} pour une quelquonque
raison (par exemple, un rapport de \textit{bug}), utilisez la séquence
hexadécimale.

\subsection{Afficher une révision spécifique}

Pour réduire la sortie de \hgcmd{log} à une seule révision, utilisez
l'option \hgopt{log}{-r} (ou \hgopt{log}{--rev}). Vous pouvez utiser
le numéro de révision ou la séquence hexadécimal comme identifiant, et 
vous demandez autant de révisions que vous le souhaitez. 
\interaction{tour.log-r}

Si vous voulez voir l'historique de plusieurs révisions sans avoir à 
les énumérer, vous pouvez utiliser la \emph{\textit{range notation}}
\footnote{NdT: Il n'est pas aisé de traduire ce terme, donc je le 
laisse en anglais} qui vous permet d'exprimer l'idée ``je veux toutes
les révisions entre $a$ et $b$, inclus''.
\interaction{tour.log.range}
Mercurial respecte aussi l'ordre dans lequel vous spécifier les 
révisions, ainsi \hgcmdargs{log}{-r 2:4} affichera $2,3,4$ alors que 
\hgcmdargs{log}{-r 4:2} affichera $4,3,2$.

\subsection{Informations détaillées}

Si le résumé affiché par \hgcmd{log} est utile si vous savez déjà ce                                                                   
que vous cherchez. Vous aurez probablement besoin de voir un description                                                               
complète du changement, ou une liste des fichiers modifiés. Si vous                                                                    
cherchez à déterminer si ce \textit{changeset} est bien celui que vous                                                                 
recherchez. L'option \hgopt{-v} de la commande \hgcmd{log} (ou                                                                         
\hgopt{--verbose}) vous donne des informations supplémentaires.

Si vous voulez voir à la fois la description et le contenu d'une                                                                       
modification, ajouter l'option \hgopt{log}{-p} (ou \hgopt{log}{--patch}).                                                              
Ceci affiche le contenu d'une modification comme un \emph{diff unifié}                                                                 
\footnote{NdT: \textit{unified diff}} (si vous n'avez jamais vu de diff                                                                
unifié avant, consulter la section~\ref{sec:mq:patch} pour rapide                                                                      
survol).


\section{Tout sur les options de commandes}

Avant d'aller plus loin sur le fonctionnement des commandes de Mercurial,
étudions un moment comment elles fonctionnent de manière générale, vous
trouverez ça probablement utile pour la suite de notre parcours.

Mercurial a une manière approche directe et cohérente pour interpréter
les options que vous passez aux commandes. Il suit une convention commune
à la plupart des systèmes Unix et Linux modernes.

\begin{itemize}
\item Chaque option a un nom complet. Par exemple, comme nous l'avons déjà
      vu, la command e\hgcmd{log} accepte l'option \hgopt{log}{--rev}.
\item La plupart des options dispose de noms abrégés, aussi. Au lieu d'utiliser
  \hgopt{log}{--rev}, vous pouvez utiliser \hgopt{log}{-r}. (Les options qui
  n'ont pas de noms abrégés sont généralement rarement utilisés, c'est pour ça).
\item Les noms complets commence par deux tirets (i.e.~\hgopt{log}{--rev}),
  alors que les options courtes commencent avec un seul (i.e.~\hgopt{log}{-r}).
\item Les noms des options sont cohérent entre les commandes. Par exemple, 
  chaque commande qui accepte un \textit{changeset~ID} ou une numéro de révision
  accepte aussi \hgopt{log}{-r} et \hgopt{log}{--rev} comme arguments.
  %TODO: Small mistake here, shouldn't have log here... shouldn't it ?
\end{itemize}

Dans les exemples de ce libre, j'utilise les noms abrégés plutôt que les noms
complet. Ceci est une préférence personnelle, par une recommandation.

La plupart des commandes qui affiche une quelquonque sortie à l'écran,
afficheront plus avec l'option \hggopt{-v} (ou \hggopt{--verbose}), et
mois avec l'option \hggopt{-q} (ou \hggopt{--quiet}).

\section{Faire et vérifier des modifications}

Maintenant que nous avons une bonne idée de commande consulter l'historique
de Mercurial, regardons comment faire des modifications et les examiner.

La première chose que nous allons faire c'est isoler notre expérience dans
un dépôt à part. Nous allons utiliser la commande \hgcmd{clone}, mais nous
n'avons pas besoin de faire une copie de dépôt distant. Comme nous avons 
déjà une copie locale, nous pouvons juste faire un clone de celle ci à la 
place. C'est beaucoup plus rapide que de faire une copie à travers le 
réseau, et un dépôt cloné localement prend moins d'espace disques aussi.

\interaction{tour.reclone}

On notera au passage qu'il est souvent considéré comme une bonne pratique
de conserver une copie ``immaculée'' du dépôt distant, à partir de laquelle
vous pourrez faire des copies locales temporaires pour créer des ``bacs à 
sable'' pour chaque tâche sur laquelle vous souhaitez travailler. Ceci vous
permet de travailler sur plusieur choses en parallèle, chacune isolée les 
unes des autres en attendant que ces tâches soient fini et que vous soyez
prêt à les réintégrer. Parce que les copies locales sont peu coûteuse, il
est très rapide de créer ou détruire des dépôts dès que vous en avez besoin.

%% Note: la dernière phrase n'est pas une traduction littérale, mais je
%% pense qu'elle exprime plus clairement en français ce que veut dire son 
%% équivalent anglais.

Dans notre dépôt \dirname{my-hello}, nous avons un fichier \filename{hello.c}
qui contient le classique programme ``hello, world''. Nous allons utiliser 
l'ancienne et vénérable commande \command{sed} pour l'éditer pour qu'il 
affiche une seconde ligne à l'écran. (J'utilise \command{sed} seulement parce
qu'il est facile d'écrire des exemples sous formes de script ainsi. Comme 
vous n'avez pas ces contraintes, vous n'utiliserez probablement pas \command{sed}
mais plutôt votre éditeur de texte favori). 

\interaction{tour.sed}

La commande \hgcmd{status} de Mercurial nous dira de quels fichiers Mercurial
s'occupe au sein de ce dépôt.
\interaction{tour.status}
La commande \hgcmd{status} n'affiche rien sur la sortie pour quelques fichiers
mais une ligne commence par ``\texttt{M}'' for \filename{hello.c}. À moins que
vous ne lui indiquiez de le faire, \hgcmd{status} n'affichera aucune sortie 
pour les fichiers qui n'ont pas été modifiés.

Le caractère ``\texttt{M}'' indique que Mercurial a remarqué que nous avions
modifié le fichier \filename{hello.c}. Nous n'avons pas besoin d'\emph{informer}
Mercurial que nous allons modifier un fichier avant de le faire, ou que nous 
venons de le modifier, il est capable de s'en rendre compte tout seul.

C'est pratique de savoir que nous avons modifié \filename{hello.c}, mais il
serait encore plus pratique de savoir ce que nous avons modifié exactement. Pour
cela, nous avons la commande  \hgcmd{diff}.

\interaction{tour.diff}

\section{Enregister les modifications dans un nouveau \textit{changeset}}

Nous pouvons modifier des fichiers, compiler et tester nos modifications,
et utiliser les commandes \hgcmd{status} and \hgcmd{diff} pour voir les
modifications effectués, jusqu'au moment où nous serons assez satisfait
pour décider d'enregister notre travail dans un \textit{changeset}.

La commande \hgcmd{commit} vous laisse créer un nouveau \textit{changeset},
nous désignerons généralement cette opération par ``faire un commit'' ou
``commité''\footnote{NdT: De mon expérience, la plupart des francophones 
utilisent  régulièrement, à l'oral, cette expression, mais bien évidement
il ne s'agit pas d'un terme terminologiquement correct, ni même français.}

\subsection{Définir le nom d'utilisateur}

Quand vous exécuter la commande \hgcmd{commit} pour la première fois, elle
n'est pas garanti de réussir. Mercurial enregistre votre nom et votre 
adresse avec chaque modification que vous effectuez, de manière à ce que
vous soyez capable (ou d'autres le soient) de savoir qui a fait quelle
modification. Mercurial essaye automatiquement de découvrir un nom 
d'utilisateur qui est un minimum de sense pour effectuer l'opération
de \textit{commit} avec. Il va essayer chacune des méthodes suivantes,
dans l'ordre:
\begin{enumerate}
\item Si vous spécifiez l'option \hgopt{commit}{-u} avec la commande 
  \hgcmd{commit}, suivi d'un nom d'utilisateur, ceci aura toujours la 
  priorité sur les autres méthodes ci dessous.
\item Si vous avez défini une variable d'environement \envar{HGUSER}, 
  c'est cette valeur qui est alors utilisée.
\item Si vous créer un fichier nommé \sfilename{.hgrc} dans votre 
   répertoire \textit{home}, avec une entrée \rcitem{ui}{username}, 
   c'est la valeur associée qui sera utilisée. Pour voir à quoi 
   ressemble le contenu de ce fichier regardez la 
   section~\ref{sec:tour-basic:username} ci dessous.
\item Si vous avez défini une variable d'environement \envar{EMAIL}
  celle ci sera utilisée ensuite.
\item Enfin, Mercurial interrogera votre système pour trouver votre
  nom d'utilisateur local ainsi que le nom de la machine hôte, et il 
  un nom d'utilisateur à partir de ces composants. Comme il arrive
  souvent que ce genre de noms soit totalement inutile, il vous 
  préviendra en affichant un message d'avertissement.
\end{enumerate}

Si tous ces méchanismes échouent, Mercurial n'exécutera pas la commande,
affichant un message d'erreur. Dans ce cas, il ne vous laissera pas 
effectuer de \textit{commit} tant que vous n'aurez pas défini un nom
d'utilisateur.

Vous devriez penser à utiliser la variable d'environement \envar{HGUSER} 
et l'option \hgopt{commit}{-u} comme moyen pour \emph{changer le nom
d'utilisateur} par défaut. Pour une utilisation normale, le plus simple
et robuste manière d'opérer est de créer un fichier \sfilename{.hgrc},
voir ci dessous pour les détails à ce sujet.

\subsubsection{Creating a Mercurial configuration file}
\label{sec:tour-basic:username}

To set a user name, use your favourite editor to create a file called
\sfilename{.hgrc} in your home directory.  Mercurial will use this
file to look up your personalised configuration settings.  The initial
contents of your \sfilename{.hgrc} should look like this.
\begin{codesample2}
  # This is a Mercurial configuration file.
  [ui]
  username = Firstname Lastname <email.address@domain.net>
\end{codesample2}
The ``\texttt{[ui]}'' line begins a \emph{section} of the config file,
so you can read the ``\texttt{username = ...}'' line as meaning ``set
the value of the \texttt{username} item in the \texttt{ui} section''.
A section continues until a new section begins, or the end of the
file.  Mercurial ignores empty lines and treats any text from
``\texttt{\#}'' to the end of a line as a comment.

\subsubsection{Choosing a user name}

You can use any text you like as the value of the \texttt{username}
config item, since this information is for reading by other people,
but for interpreting by Mercurial.  The convention that most people
follow is to use their name and email address, as in the example
above.

\begin{note}
  Mercurial's built-in web server obfuscates email addresses, to make
  it more difficult for the email harvesting tools that spammers use.
  This reduces the likelihood that you'll start receiving more junk
  email if you publish a Mercurial repository on the web.
\end{note}

\subsection{Writing a commit message}

When we commit a change, Mercurial drops us into a text editor, to
enter a message that will describe the modifications we've made in
this changeset.  This is called the \emph{commit message}.  It will be
a record for readers of what we did and why, and it will be printed by
\hgcmd{log} after we've finished committing.
\interaction{tour.commit}

The editor that the \hgcmd{commit} command drops us into will contain
an empty line, followed by a number of lines starting with
``\texttt{HG:}''.
\begin{codesample2}
  \emph{empty line}
  HG: changed hello.c
\end{codesample2}
Mercurial ignores the lines that start with ``\texttt{HG:}''; it uses
them only to tell us which files it's recording changes to.  Modifying
or deleting these lines has no effect.

\subsection{Writing a good commit message}

Since \hgcmd{log} only prints the first line of a commit message by
default, it's best to write a commit message whose first line stands
alone.  Here's a real example of a commit message that \emph{doesn't}
follow this guideline, and hence has a summary that is not readable.
\begin{codesample2}
  changeset:   73:584af0e231be
  user:        Censored Person <censored.person@example.org>
  date:        Tue Sep 26 21:37:07 2006 -0700
  summary:     include buildmeister/commondefs.   Add an exports and install
\end{codesample2}

As far as the remainder of the contents of the commit message are
concerned, there are no hard-and-fast rules.  Mercurial itself doesn't
interpret or care about the contents of the commit message, though
your project may have policies that dictate a certain kind of
formatting.

My personal preference is for short, but informative, commit messages
that tell me something that I can't figure out with a quick glance at
the output of \hgcmdargs{log}{--patch}.

\subsection{Aborting a commit}

If you decide that you don't want to commit while in the middle of
editing a commit message, simply exit from your editor without saving
the file that it's editing.  This will cause nothing to happen to
either the repository or the working directory.

If we run the \hgcmd{commit} command without any arguments, it records
all of the changes we've made, as reported by \hgcmd{status} and
\hgcmd{diff}.

\subsection{Admiring our new handiwork}

Once we've finished the commit, we can use the \hgcmd{tip} command to
display the changeset we just created.  This command produces output
that is identical to \hgcmd{log}, but it only displays the newest
revision in the repository.
\interaction{tour.tip}
We refer to the newest revision in the repository as the tip revision,
or simply the tip.

\section{Sharing changes}

We mentioned earlier that repositories in Mercurial are
self-contained.  This means that the changeset we just created exists
only in our \dirname{my-hello} repository.  Let's look at a few ways
that we can propagate this change into other repositories.

\subsection{Pulling changes from another repository}
\label{sec:tour:pull}

To get started, let's clone our original \dirname{hello} repository,
which does not contain the change we just committed.  We'll call our
temporary repository \dirname{hello-pull}.
\interaction{tour.clone-pull}

We'll use the \hgcmd{pull} command to bring changes from
\dirname{my-hello} into \dirname{hello-pull}.  However, blindly
pulling unknown changes into a repository is a somewhat scary
prospect.  Mercurial provides the \hgcmd{incoming} command to tell us
what changes the \hgcmd{pull} command \emph{would} pull into the
repository, without actually pulling the changes in.
\interaction{tour.incoming}
(Of course, someone could cause more changesets to appear in the
repository that we ran \hgcmd{incoming} in, before we get a chance to
\hgcmd{pull} the changes, so that we could end up pulling changes that we
didn't expect.)

Bringing changes into a repository is a simple matter of running the
\hgcmd{pull} command, and telling it which repository to pull from.
\interaction{tour.pull}
As you can see from the before-and-after output of \hgcmd{tip}, we
have successfully pulled changes into our repository.  There remains
one step before we can see these changes in the working directory.

\subsection{Updating the working directory}

We have so far glossed over the relationship between a repository and
its working directory.  The \hgcmd{pull} command that we ran in
section~\ref{sec:tour:pull} brought changes into the repository, but
if we check, there's no sign of those changes in the working
directory.  This is because \hgcmd{pull} does not (by default) touch
the working directory.  Instead, we use the \hgcmd{update} command to
do this.
\interaction{tour.update}

It might seem a bit strange that \hgcmd{pull} doesn't update the
working directory automatically.  There's actually a good reason for
this: you can use \hgcmd{update} to update the working directory to
the state it was in at \emph{any revision} in the history of the
repository.  If you had the working directory updated to an old
revision---to hunt down the origin of a bug, say---and ran a
\hgcmd{pull} which automatically updated the working directory to a
new revision, you might not be terribly happy.

However, since pull-then-update is such a common thing to do,
Mercurial lets you combine the two by passing the \hgopt{pull}{-u}
option to \hgcmd{pull}.
\begin{codesample2}
  hg pull -u
\end{codesample2}
If you look back at the output of \hgcmd{pull} in
section~\ref{sec:tour:pull} when we ran it without \hgopt{pull}{-u},
you can see that it printed a helpful reminder that we'd have to take
an explicit step to update the working directory:
\begin{codesample2}
  (run 'hg update' to get a working copy)
\end{codesample2}

To find out what revision the working directory is at, use the
\hgcmd{parents} command.
\interaction{tour.parents}
If you look back at figure~\ref{fig:tour-basic:history}, you'll see
arrows connecting each changeset.  The node that the arrow leads
\emph{from} in each case is a parent, and the node that the arrow
leads \emph{to} is its child.  The working directory has a parent in
just the same way; this is the changeset that the working directory
currently contains.

To update the working directory to a particular revision, give a
revision number or changeset~ID to the \hgcmd{update} command.
\interaction{tour.older}
If you omit an explicit revision, \hgcmd{update} will update to the
tip revision, as shown by the second call to \hgcmd{update} in the
example above.

\subsection{Pushing changes to another repository}

Mercurial lets us push changes to another repository, from the
repository we're currently visiting.  As with the example of
\hgcmd{pull} above, we'll create a temporary repository to push our
changes into.
\interaction{tour.clone-push}
The \hgcmd{outgoing} command tells us what changes would be pushed
into another repository.
\interaction{tour.outgoing}
And the \hgcmd{push} command does the actual push.
\interaction{tour.push}
As with \hgcmd{pull}, the \hgcmd{push} command does not update the
working directory in the repository that it's pushing changes into.
(Unlike \hgcmd{pull}, \hgcmd{push} does not provide a \texttt{-u}
option that updates the other repository's working directory.)

What happens if we try to pull or push changes and the receiving
repository already has those changes?  Nothing too exciting.
\interaction{tour.push.nothing}

\subsection{Sharing changes over a network}

The commands we have covered in the previous few sections are not
limited to working with local repositories.  Each works in exactly the
same fashion over a network connection; simply pass in a URL instead
of a local path.
\interaction{tour.outgoing.net}
In this example, we can see what changes we could push to the remote
repository, but the repository is understandably not set up to let
anonymous users push to it.
\interaction{tour.push.net}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
