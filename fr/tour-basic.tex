\chapter{Un rapide tour de Mercurial}
\label{chap:tour-basic}

\section{Installer Mercurial sur votre système}
\label{sec:tour:install}

Des paquetages binaires de Mercurial sont disponibles pour la plupart
des systèmes d'exploitation, ce qui rend facile l'utilisation immédiate
de Mercurial sur votre ordinateur.

\subsection{Linux}

Parce que chaque distribution de Linux a ses propres outils de gestion
de paquets, politiques et rythmes de développements, il est difficile de
donner un ensemble d'instructions uniques pour installer les binaires de
Mercurial. La version de Mercurial avec laquelle vous vous retrouverez
dépendra grandement de l'activité de la personne en charge du paquetage
pour la distribution.

Pour rester simple, je me concentrerai sur l'installation de Mercurial
en ligne de commande, sous les distributions les plus courantes. La 
plupart des distributions fournissent des gestionnaires graphiques de
paquetage qui vous permettront d'installer Mercurial en quelques clicks.
Le paquetage devrait se nommer \textit{mercurial}.

\begin{itemize}
\item[Debian]
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}

\item[Fedora Core]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Gentoo]
  \begin{codesample4}
    emerge mercurial
  \end{codesample4}

\item[OpenSUSE]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Ubuntu] Le paquetage de Mercurial d'Ubuntu est construit sur celui de Debian. 
              Pour l'installer, exécutez simplement les commandes suivantes:
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}
  Les paquetages Ubuntu pour Mercurial ont tendance à être un peu en retard
  par rapport au paquetage Debian (au moment de l'écriture de ce livre, il
  faut compter à peu près un retard de 7 mois), ce qui signifie que parfois 
  sur Ubuntu, vous risquez de rencontrer des problèmes qui ont été corrigés 
  depuis longtemps dans les paquetages Debian.
\end{itemize}

\subsection{Solaris}

SunFreeWare, à \url{http://www.saufreeware.com}, est une bonne source 
pour trouver un vaste nombre de paquets précompilés pour 32 ou 64 bits
Intel et les architecture Sparc, dont les versions courantes de Mercurial.

\subsection{Mac OS X}

Lee Cantey publie un installateur de Mercurial pour Mac OS~X sur le site 
\url{http://mercurial.berkwood.com}.  Ce paquetage fonctionne sur les 
architectures Intel-~et PowerPC. Avant de vous en servir, vous devez
installer une version Universelle MacPython~\cite{web:macpython}. C'est
assez facile à faire : suivez simplement les instructions sur le site
de Lee.

Il est aussi possible d'installer Mercurial en utilisant Fink ou MacPorts,
deux outils de gestion de paquetage libres pour Mac OS X. Si vous avez 
Fink, utilisez \command{sudo fink install mercurial-py25}. Si vous avez 
MacPorts, \command{sudo port install mercurial}.

\subsection{Windows}

Lee Cantey publie aussi un installateur de Mercurial pour Windows sur le site
\url{http://mercurial.berkwood.com}. Ce paquetage n'a aucune dépendance 
externe, il fonctionne ``tout court''.

\begin{note}
  La version de Windows de Mercurial ne convertie pas automatiquement
  les retours chariot Windows et Unix. Si vous désirez partager votre
  travail avec des utilisateurs Unix, vous devez faire un peu de configuration
  supplémentaire. XXX En dire plus.
\end{note}

\section{Commencer à utiliser Mercurial}

Pour commencer, nous utiliserons la commande \hgcmd{version} pour vérifier
si Mercurial est installé proprement. Les informations affichées sur la 
version ne sont pas réellement importantes en soit, c'est surtout de savoir
si elles s'affichent qui nous intéresse.
\interaction{tour.version}

\subsection{L'aide intégrée}

Mercurial fournit un système d'aide intégré, ce qui est inestimable quand
vous vous retrouvez coincé à essayer de vous rappeler comment lancer telle
ou telle commande. 
Si c'est le cas, exécutez simplement \hgcmd{help}; il vous aidera à imprimer
une brève liste de commandes, avec une description de ce qu'elles font. Si vous
demandez de l'aide sur une commande spécifique (voir ci-dessous), il affichera
des informations plus détaillées.
\interaction{tour.help}
Pour un niveau d'informations encore plus détaillées (ce dont vous aurez rarement
besoin), exécuter \hgcmdargs{help}{\hggopt{-v}}.  L'option \hggopt{-v} est 
l'abréviation de \hggopt{--verbose}, et indique à Mercurial d'afficher plus 
d'informations que d'habitude.

\section{Travailler avec un dépôt}

Avec Mercurial, tout se déroule au sein du \emph{dépôt}\footnote{NdT: Dépôt est
la traduction que j'ai retenue pour tout l'ouvrage du terme anglais \textit{repository}}.
Le dépôt d'un projet contient tous les fichiers qui ``appartiennent'' au projet.

Il n'y a rien de particulièrement magique au sujet de ce dépôt, c'est
simplement une arborescence sur votre système de fichiers que Mercurial
traite de manière spéciale. Vous pouvez renommer ou effacer ce répertoire
à n'importe quel moment, en utilisant la ligne de commande ou votre
explorateur de fichiers.

\subsection{Faire une copie locale de votre dépôt}

\emph{Copier} un dépôt est juste un peu spécial. Bien que vous 
puissiez utiliser une commande habituelle de copie pour copier
votre dépôt, il vaut mieux utiliser une commande fournie par
Mercurial. Cette commande est appelée \hgcmd{clone}, car elle
crée une copie identique à un dépôt existant.
\interaction{tour.clone}
Si votre opération de clonage réussit, vous devriez maintenant
avoir un répertoire local appelé \dirname{hello}. Ce répertoire
contiendra quelques fichiers.
\interaction{tour.ls}
Ces fichiers ont le même contenu et historique dans votre dépôt
qu'ils ont dans le dépôt que vous avez cloné.

Chaque dépôt Mercurial est complet, autonome et indépendant. Il
contient sa propre copie privée des fichiers du projet et de leur
historique. Le clone d'un dépôt se souvient de la localisation du
dépôt à partir duquel il a été clôné, mais il ne communique pas avec
ce dernier, ou un autre, à moins que vous ne lui demandiez.

Ce que tout ceci signifie pour le moment est que nous sommes libres
d'expérimenter avec ce dépôt, confiants dans le fait qu'il s'agit d'un
``bac à sable'' qui n'affectera personne d'autre.

\subsection{Quel est le contenu d'un dépôt ?}

Prêtons plus attention un instant au contenu d'un dépôt. Nous voyons 
qu'il contient un répertoire nommé \dirname{.hg}. C'est ici que Mercurial
conserve toutes ses métadonnées.
\interaction{tour.ls-a}

Le contenu du répertoire \dirname{.hg} et ses sous répertoires sont les
seuls propres à Mercurial. Tous les autres fichiers et répertoires dans 
le dépôt sont à vous, et vous pouvez en faire ce que vous voulez.

Pour introduire un peu de terminologie, le répertoire \dirname{.hg} est
un ``vrai'' dépôt, et tous les fichiers et les répertoires qui coexistent
avec lui, sont désignés sous le nom \emph{espace de travail}\footnote{NdT: 
\textit{working directory}}. Une manière facile de se rappeler cette 
distinction est de retenir que le \emph{dépôt} contient l'\emph{historique}
de votre projet, alors que l'\emph{espace de travail} contient une \emph{copie
ponctuelle}\footnote{NdT: Ce terme est une traduction du terme anglais 
\textit{snapshot}. Il est traduit ici pour faciliter la lecture, mais ne sera
plus traduit par la suite.} de votre projet à un certain point de son
historique.

\section{Une ballade dans l'historique}

Une des premières choses que vous aurez envie de faire avec un nouveau
dépôt, sera de comprendre son historique. La commande \hgcmd{log} vous
donne une vue de l'historique.
\interaction{tour.log}
Par défaut, cette commande affiche à l'écran un bref paragraphe pour chaque
révision enregistrée pour ce projet. Dans la terminologie de Mercurial, nous
appelons chacun de ces évènements enregistrés un \emph{changeset}, parce 
qu'il contient un ensemble de modifications sur plusieurs fichiers.

La commande \hgcmd{log} affiche ainsi ces informations:
\begin{itemize}
\item[\texttt{changeset}] Ce champ contient un nombre, séparé par deux points
  (:), d'une chaine hexadécimale. Il s'agit en fait d'\emph{identifiants}
  d'un \textit{changeset}. Il y a deux identifiants car le numéro de
  la révision est plus court et plus à facile à saisir qu'une séquence
  hexadécimale.
\item[\texttt{user}] L'identité de la personne qui a créée ce  %%% laisser le terme anglais car il sera affiché
  \textit{changeset}. C'est un champ libre de forme, mais la plupart du
  temps il contient le nom et l'email de la personne.
\item[\texttt{date}] La date et l'heure à laquelle le \textit{changeset}
  a été créé, ainsi que le \textit{fuseau horaire} dans laquelle il a été créé. %%%TODO: Translate 'timezone' properly : FUSEAU
  (La date et l'heure sont locales à ce \textit{fuseau}, elles indiquent
  donc quelle date et heure il était pour la personne qui a créé ce %%%TODO: je suppose (quelle "heure")  OUI
  \textit{changeset}.)
\item[\texttt{résumé}] La première du message que le créateur a associé à
  son \textit{changeset} pour le décrire.
\end{itemize}

Par défaut, la commande \hgcmd{log} n'affiche qu'un résumé, il manque 
beaucoup de détails.

La figure~\ref{fig:tour-basic:history} fournit une représentation graphique
de l'historique du dépôt \dirname{hello}, pour rendre plus facile de voir
dans quelle direction l'historique se ``déroule''\footnote{NdT: \textit{flowing in}.}.
Nous reviendrons régulièrement sur cette représentation dans ce chapitre et
ceux qui suivent.

\begin{figure}[ht]
  \centering
  \grafix{tour-history}
  \caption{Représentation graphique du dépôt \dirname{hello} }
  \label{fig:tour-basic:history}
\end{figure}

\subsection{Changesets, révisions, et discuter avec les autres}%%%TODO: je propose : "discussion" (3 noms communs)
%%% je propose "colaboration"

Comme l'anglais est réputé pour être un langage maladroit, et que l'informatique
est la source de bien des erreurs de terminologies (pourquoi utiliser un
seul terme quand quatre feront l'affaire ?), la gestion de version a une
variété de mots et de phrases qui veulent dire la même chose. Si vous 
discutez d'historique de Mercurial avec d'autres personnes, 
%%%TODO: ça ne veut rien dire: il faut supprimer une des personnes : soit "quelqu'un", 
% soit "à d'autres personnes"
vous constaterez que souvent le mot ``\textit{changeset}'' est contracté simplement
en ``change'' ou (à l'écrit) ``cset'', et même parfois un 
\textit{changeset} simplement ``révision'', abrégé en ``rev''.

Bien que le \emph{mot} que vous utilisez pour désigner le concept de
\textit{changeset} importe peu, l'\emph{identifiant} que vous utilisez
pour désigner un \emph{changeset} \textit{spécifique} a une grande
importance. Rappelez vous que le champ \textit{changeset} affiché par la 
commande \hgcmd{log} identifie un \textit{changeset} à la fois avec
un numéro de révision et une séquence hexadécimale.

\begin{itemize}
\item Le numéro de révision est \emph{seulement valable dans ce dépôt},
\item alors que la séquence hexadécimale est un \emph{identifiant 
	permanent, et invariant } qui pourra toujours être associé au 
	\textit{changeset} exact de \emph{chaque} copie de votre dépôt.
\end{itemize}

La distinction est importante. Si vous envoyez un email à quelqu'un en
parlant de la ``révision 33'', il est très probable que sa révision~33
\emph{ne sera pas la même} que la votre. La raison de ceci est que le
numéro de révision dépend de l'ordre dans lequel les modifications sont
arrivées dans le dépôt, et il n'y a aucune garantie que les mêmes changements
soient arrivés dans le même ordre dans différents dépôts. Trois modifications
$a,b,c$ peuvent aisément apparaitre dans un dépôt comme $0,1,2$, et dans
un autre comme $1,0,2$.

Mercurial utilise les numéros de révision uniquement comme des raccourcis
pratiques. Si vous devez discuter d'un \textit{changeset} avec quelqu'un, 
ou identifer un \textit{changeset} pour une quelquonque %%%TODO: our : "pour" ou "ou"
raison (par exemple, un rapport de \textit{bug}), utilisez la séquence
hexadécimale.

\subsection{Afficher une révision spécifique}

Pour réduire la sortie de \hgcmd{log} à une seule révision, utilisez
l'option \hgopt{log}{-r} (ou \hgopt{log}{--rev}). Vous pouvez utiliser
le numéro de révision ou la séquence hexadécimale comme identifiant, et 
demander autant de révisions que vous le souhaitez. 
\interaction{tour.log-r}

Si vous voulez voir l'historique de plusieurs révisions sans avoir à 
les énumérer, vous pouvez utiliser la \emph{\textit{range notation}}
\footnote{NdT: Il n'est pas aisé de traduire ce terme, donc je le  %%%TODO : intervalle de numérotation ?
laisse en anglais} qui vous permet d'exprimer l'idée ``je veux toutes
les révisions entre $a$ et $b$, inclus''.
\interaction{tour.log.range}
Mercurial respecte aussi l'ordre dans lequel vous spécifiez les 
révisions, ainsi \hgcmdargs{log}{-r 2:4} affichera $2,3,4$ alors que 
\hgcmdargs{log}{-r 4:2} affichera $4,3,2$.

\subsection{Informations détaillées}


Le résumé affiché par \hgcmd{log} est suffisant si vous savez déjà ce %%%TODO: je pense que le premier "si" est de trop : exact
que vous cherchez. En revanche, vous aurez probablement besoin de voir une description
complète du changement, ou une liste des fichiers modifiés si vous 
cherchez à déterminer qu'un \textit{changeset} est bien celui que vous%%%TODO: les propositions sont mal construites : après un "si...." il faut une proposition sans "si... donc ici : "si ... recherchez", ben quoi ?
recherchez. L'option \hgopt{-v} de la commande \hgcmd{log} (ou 
\hgopt{--verbose}) vous donne ces informations supplémentaires.
\interaction{tour.log-v}

Si vous voulez voir à la fois la description et le contenu d'une 
modification, ajouter l'option \hgopt{log}{-p} (ou \hgopt{log}{--patch}).
Ceci affiche le contenu d'une modification comme un \emph{diff unifié}
\footnote{NdT: \textit{unified diff}} (si vous n'avez jamais vu de diff 
unifié avant, consultez la section~\ref{sec:mq:patch} pour un rapide 
survol).

\interaction{tour.log-vp}

\section{Tout sur les options de commandes}


Avant d'aller plus loin sur le fonctionnement des commandes de Mercurial,
étudions un moment comment elles fonctionnent de manière générale. Vous
trouverez ça probablement utile pour la suite de notre parcours.

Mercurial utilise une approche directe et cohérente pour interpréter %%%TODO: une manière d'approche ?
les options que vous passez aux commandes. Il suit une convention commune
à la plupart des systèmes Unix et Linux modernes.

\begin{itemize}
\item Chaque option a un nom complet. Par exemple, comme nous l'avons déjà
      vu, la commande \hgcmd{log} accepte l'option \hgopt{log}{--rev}.%%%TODO: commande ou command e\hgcmd...?
\item La plupart des options disposent de noms abrégés. Aussi, au lieu d'utiliser
  \hgopt{log}{--rev}, vous pouvez utiliser \hgopt{log}{-r}. (Les options qui
  n'ont pas de noms abrégés sont généralement rarement utilisées, pour cette raison).
\item Les noms complets commencent par deux tirets (i.e.~\hgopt{log}{--rev}),
  alors que les options courtes commencent avec un seul (i.e.~\hgopt{log}{-r}).
\item Les noms des options sont cohérents entre les commandes. Par exemple, 
  chaque commande qui accepte un \textit{changeset~ID} ou un numéro de révision
  accepte aussi \hgopt{log}{-r} et \hgopt{log}{--rev} comme arguments.
  %TODO: Small mistake here, shouldn't have log here... shouldn't it ?
\end{itemize}

Dans les exemples de ce livre, j'utilise les noms abrégés plutôt que les noms
complets. Ceci est une préférence personnelle, pas une recommandation.

La plupart des commandes qui affichent une quelconque sortie à l'écran,
afficheront davantage avec l'option \hggopt{-v} (ou \hggopt{--verbose}), et
moins avec l'option \hggopt{-q} (ou \hggopt{--quiet}).

\section{Faire et vérifier des modifications}

Maintenant que nous avons une bonne idée des commandes pour consulter 
l'historique de Mercurial, regardons comment faire des modifications et 
les examiner.


La première chose que nous allons faire c'est isoler notre expérience dans
un dépôt à part. Nous allons utiliser la commande \hgcmd{clone}, mais nous
n'avons pas besoin de faire une copie de dépôt distant. Comme nous avons 
déjà une copie locale, nous pouvons juste faire un clone de celle-ci à la 
place. C'est beaucoup plus rapide que de faire une copie à travers le 
réseau, et un dépôt cloné localement prend également moins d'espace disque.

\interaction{tour.reclone}

On notera au passage qu'il est souvent considéré comme une bonne pratique
de conserver une copie ``immaculée'' du dépôt distant, à partir de laquelle
vous pourrez faire des copies locales temporaires pour créer des ``bacs à 
sable'' pour chaque tâche sur laquelle vous souhaitez travailler. Ceci vous
permet de travailler sur plusieurs choses en parallèle, chacune isolée les 
unes des autres en attendant que ces tâches soient finies et que vous soyez
prêt à les réintégrer. Parce que les copies locales sont peu coûteuses, il
est très rapide de créer ou détruire des dépôts dès que vous en avez besoin.

%% Note: la dernière phrase n'est pas une traduction littérale, mais je
%% pense qu'elle exprime plus clairement en français ce que veut dire son 
%% équivalent anglais. : OUI

Dans notre dépôt \dirname{my-hello}, nous avons un fichier \filename{hello.c}
qui contient le classique programme ``hello, world''. Nous allons utiliser 
l'ancienne et vénérable commande \command{sed} pour l'éditer afin qu'il 
affiche une seconde ligne à l'écran. (J'utilise \command{sed} seulement parce
qu'il est ainsi facile d'écrire des exemples sous forme de script. Comme 
vous n'avez pas ces contraintes, vous n'utiliserez probablement pas \command{sed}
mais plutôt votre éditeur de texte favori). 

\interaction{tour.sed}

La commande \hgcmd{status} de Mercurial nous dira de quels fichiers Mercurial
s'occupe au sein de ce dépôt.
\interaction{tour.status}
La commande \hgcmd{status} n'affiche rien sur la sortie pour quelques fichiers
mais une ligne commence par ``\texttt{M}'' for \filename{hello.c}. À moins que
vous ne lui indiquiez de le faire, \hgcmd{status} n'affichera aucune sortie 
pour les fichiers qui n'ont pas été modifiés.

Le caractère ``\texttt{M}'' indique que Mercurial a remarqué que nous avions
modifié le fichier \filename{hello.c}. Nous n'avons pas besoin d'\emph{informer}
Mercurial que nous allons modifier un fichier avant de le faire, ou que nous 
venons de le modifier, il est capable de s'en rendre compte tout seul.

C'est pratique de savoir que nous avons modifié \filename{hello.c}, mais il
serait encore plus pratique de savoir ce que nous avons modifié exactement. Pour
cela, nous avons la commande  \hgcmd{diff}.

\interaction{tour.diff}

\section{Enregister les modifications dans un nouveau \textit{changeset}}

Nous pouvons modifier des fichiers, compiler et tester nos modifications,
et utiliser les commandes \hgcmd{status} et \hgcmd{diff} pour voir les
modifications effectuées, jusqu'au moment où nous serons assez satisfaits
pour décider d'enregistrer notre travail dans un \textit{changeset}.

La commande \hgcmd{commit} vous laisse créer un nouveau \textit{changeset},
nous désignerons généralement cette opération par ``faire un commit'' ou
``commiter''\footnote{NdT: De mon expérience, la plupart des francophones 
utilisent  régulièrement, à l'oral, cette expression, mais bien évidement
il ne s'agit pas d'un terme de terminologie correcte, ni même français.}

\subsection{Définir le nom d'utilisateur}

Quand vous exécutez la commande \hgcmd{commit} pour la première fois, elle
n'est pas garantie de réussir. Mercurial enregistre votre nom et votre 
adresse avec chaque modification que vous effectuez, de manière à ce que
vous soyez capable (ou d'autres le soient) de savoir qui a fait quelle
modification. Mercurial essaye automatiquement de découvrir un nom 
d'utilisateur qui ait un minimum de sens pour effectuer l'opération
de \textit{commit} avec. Il va essayer chacune des méthodes suivantes,
dans l'ordre:
\begin{enumerate}
\item Si vous spécifiez l'option \hgopt{commit}{-u} avec la commande 
  \hgcmd{commit}, suivi d'un nom d'utilisateur, ceci aura toujours la 
  priorité sur les autres méthodes ci dessous.
\item Si vous avez défini une variable d'environnement \envar{HGUSER}, 
  c'est cette valeur qui est alors utilisée.
\item Si vous créez un fichier nommé \sfilename{.hgrc} dans votre 
   répertoire \textit{home}, avec une entrée \rcitem{ui}{username}, 
   c'est la valeur associée qui sera utilisée. Pour voir à quoi 
   ressemble le contenu de ce fichier regardez la 
   section~\ref{sec:tour-basic:username} ci-dessous.
\item Si vous avez défini une variable d'environnement \envar{EMAIL}
  celle ci sera utilisée ensuite.
\item Enfin, Mercurial interrogera votre système pour trouver votre
  nom d'utilisateur local ainsi que le nom de la machine hôte, et il 
  fabriquera un nom d'utilisateur à partir de ces données. Comme il arrive
  souvent que ce genre de noms soit totalement inutile, il vous 
  préviendra en affichant un message d'avertissement.
\end{enumerate}

Si tous ces mécanismes échouent, Mercurial n'exécutera pas la commande,
affichant un message d'erreur. Dans ce cas, il ne vous laissera pas 
effectuer de \textit{commit} tant que vous n'aurez pas défini un nom
d'utilisateur.

Vous devriez penser à utiliser la variable d'environement \envar{HGUSER} 
et l'option \hgopt{commit}{-u} comme moyen pour \emph{changer le nom
d'utilisateur} par défaut. Pour une utilisation normale, la manière la plus
simple et robuste d'opérer est de créer un fichier \sfilename{.hgrc},
voir ci-dessous pour les détails à ce sujet.

\subsubsection{Créer un fichier de configuration pour Mercurial}
\label{sec:tour-basic:username}

Pour définir un nom d'utilisateur, utilisez votre éditeur de texte favori
pour créer un fichier \sfilename{.hgrc} dans votre répertoire \textit{home}.
Mercurial va utiliser ce fichier pour retrouver votre configuration personnelle.
Le contenu initial devrait ressembler à ceci:
\begin{codesample2}
  # This is a Mercurial configuration file.
  [ui]
  username = Firstname Lastname <email.address@domain.net>
\end{codesample2}
La ligne avec \texttt{[ui]} commence une \emph{section} du fichier de
configuration, ainsi la ligne ``\texttt{username = ...}'' signifie ``
définir la valeur de l'élément \texttt{username} dans la section 
\texttt{ui}''. Une section continue jusqu'à ce qu'une nouvelle 
commence, ou que la fin du fichier soit atteinte. Mercurial ignore
les lignes vides et traite tout texte situé à la suite d'un  
``\texttt{\#}'' jusqu'à la fin de la ligne comme un commentaire.

\subsubsection{Choisir un nom d'utilisateur}

Vous pouvez utiliser n'importe quelle valeur pour votre \texttt{username},
car cette information est destinée à d'autres personnes et non à être
interprétée par Mercurial. La convention que la plupart des personnes
<<<<<<< local
suivent est d'utiliser leurs noms suivies de leurs adresses emails,
comme montrée ci-dessus:
=======
suivent est d'utiliser leur nom suivi de leur adresse email,
comme montrée ci dessus:
>>>>>>> other

\begin{note}
  Le mécanisme interne du serveur \textit{web} intégré à Mercurial,
  masque les adresses emails, pour rendre plus difficile leurs
  récupérations par les outils utilisés par les \textit{spammmers}.
  Ceci réduit la probabilité que de recevoir encore plus de 
  \textit{spam} si vous vous publiez un dépôt sur internet.
\end{note}

\subsection{Rédiger un message de \textit{commit}}

Lorsqu'on effectue une opération de \textit{commit}, Mercurial 
lance automatiquement un éditeur de texte pour permettre de saisir
un message qui décrira les modifications effectuées dans ce 
\textit{changeset}. Ce message est nommé le \emph{message de 
\textit{commit}}. Ce sera un enregistrement pour tout lecteur 
expliquant le pourquoi et le comment de vos modifications, et il sera
affiché par la commande \hgcmd{log}.
\interaction{tour.commit}

L'éditeur que la commande \hgcmd{commit} déclenche ne contiendra
qu'une ligne vide suivi d'un certain nombre de lignes commençant
par ``\texttt{HG:}''.
\begin{codesample2}
  \emph{empty line}
  HG: changed hello.c
\end{codesample2}
Mercurial ignore les lignes qui commencent avec ``\texttt{HG:}'', il 
ne les utilise que pour nous indiquer quels fichiers modifiés il se 
prépare à \textit{commiter}. Modifier ou effacer ces lignes n'a 
aucune conséquence sur l'opération de \textit{commit}.

\subsection{Rédiger un message \textit{approprié}}

Comme \hgcmd{log} n'affiche que la première ligne du message de
\textit{commit} par défaut, il est souvent considéré comme une bonne
<<<<<<< local
pratique de rédiger des messages de \textit{commit} qui tiennent
=======
pratique de rédiger des messages de \textit{commit} qui n'entrent que 
>>>>>>> other
sur une seule ligne. Voilà un exemple concret de message de 
\textit{commit} qui \emph{ne suit pas} cette directive, et qui a donc
un résumé peu lisible.
\begin{codesample2}
  changeset:   73:584af0e231be
  user:        Censored Person <censored.person@example.org>
  date:        Tue Sep 26 21:37:07 2006 -0700
  summary:     include buildmeister/commondefs.   Add an exports and install
\end{codesample2}

A ce sujet, il faut noter qu'il n'existe pas de règle absolue dans ce 
domaine. Mercurial lui-même n'interprète pas les contenus des messages
de \textit{commit}, ainsi votre projet est libre de concevoir différentes
<<<<<<< local
politiques de mise en page des messages.
=======
politiques de formatage des messages.
>>>>>>> other

Ma préférence personnelle va au message court, mais informatif, qui offre
des précisions supplémentaires par rapport à ce que pourrait m'apprendre une commande
\hgcmdargs{log}{--patch}.

\subsection{Annuler un \textit{commit}}

Si, en rédigeant le message, vous décidez que finalement vous ne 
<<<<<<< local
voulez pas effectuer ce \textit{commit}, il suffit de simplement quitter
l'éditeur sans sauvegarder. Ceci n'aura aucune conséquence sur le dépôt ou
=======
voulez pas effectuer ce \textit{commit}, il suffit de quitter simplement
l'éditeur sans sauver. Ceci n'aura aucune conséquence sur le dépôt ou
>>>>>>> other
les fichiers de l'espace de travail.

<<<<<<< local
Si vous exécuter la commande \hgcmd{commit} sans aucun argument, elle
=======
Si vous exécutez la commande \hgcmd{commit} sans aucun argument, elle
>>>>>>> other
enregistre toutes les modifications que vous avez faites, comme le montre
les commandes \hgcmd{status} et \hgcmd{diff}.

\subsection{Admirer votre travail}

Une fois que votre \textit{commit} est terminé, vous pouvez utiliser
la commande \hgcmd{tip} pour afficher le \textit{changeset} que nous
venons de créer. Cette commande produit une sortie à l'écran qui est
identique à celle du \hgcmd{log}, mais qui n'affiche que la dernière
révision du dépôt.
\interaction{tour.tip}
<<<<<<< local
On fait couramment référence à la dernière révision du dépôt comme
=======
On fait couramment référénce à la dernière révision du dépôt comme
>>>>>>> other
étant la révision \textit{tip}, ou plus simplement le \textit{tip}.

\section{Partager ses modifications}

Nous avons mentionné plus haut que les dépôts de Mercurial 
sont autosuffisants. Ce qui signifie que le \textit{changeset} 
que vous venez de créer existe seulement dans votre répertoire 
\dirname{my-hello}. Étudions comment propager cette modification
dans d'autres dépôts.

\subsection{Récupérer les modifications d'autres dépôts}
\label{sec:tour:pull}

Pour commencer, construisons un clone de notre dépôt \dirname{hello} 
qui ne contiendra pas le changement que nous venons d'effectuer. Nous
<<<<<<< local
l'appellerons notre dépôt temporaire \dirname{hello-pull}.
=======
appelerons notre dépôt temporaire \dirname{hello-pull}.
>>>>>>> other
\interaction{tour.clone-pull}

Nous allons utiliser la commande \hgcmd{pull} pour apporter les 
modifications depuis \dirname{my-hello} dans \dirname{hello-pull}.
Néanmoins, récupérer aveuglement des modifications depuis un dépôt
a quelque chose d'un peu effrayant. Mercurial propose donc une 
commande \hgcmd{incoming} qui permet de savoir quelles modifications
la commande \hgcmd{pull} \emph{pourrait} entraîner dans notre dépôt,
et ceci sans effectuer réellement de modification dessus.
\interaction{tour.incoming}
(Bien évidement, quelqu'un pourrait ajouter des modifications
supplémentaires sur le dépôt que nous étudions avec \hgcmd{incoming},
avant que nous ayons effectué notre \hgcmd{pull}, avec comme 
triste conséquence que nous aurons récupéré des modifications que 
nous n'attendions pas.)

Apporter les modifications rapatriées dans un dépôt se résume donc
à exécuter la commande \hgcmd{pull}, et préciser depuis quel dépôt 
effectuer le \hgcmd{pull}.
\interaction{tour.pull}

Comme vous le voyez avec une sortie avant et après de la commande
\hgcmd{tip}, nous avons réussi à récupérer aisément les modifications
dans notre dépôt. Il reste néanmoins quelque chose à faire avant de
placer ces modifications dans l'espace de travail.

\subsection{Mise à jour de l'espace de travail}

Nous avons jusqu'à maintenant grossièrement définie la relation 
entre un dépôt et un espace de travail. La commande \hgcmd{pull} que
nous avons exécutée dans la section~\ref{sec:tour:pull} a apporté
des modifications, que nous avons vérifiées, dans notre dépôt, mais
il n'y a aucune trace de ces modifications dans notre espace de travail.
En effet, \hgcmd{pull} ne touche pas (par défaut) à l'espace de 
travail. C'est la commande \hgcmd{update} qui s'en charge.
\interaction{tour.update}

Il peut sembler un peu étrange que la commande \hgcmd{pull} ne mette
pas à jour l'espace de travail automatiquement. Il y a en fait une
<<<<<<< local
très bonne raison à cela : vous pouvez utilisez la commande 
=======
très bonne raison à cela: vous pouvez utiliser la commmande 
>>>>>>> other
\hgcmd{update} pour mettre à jour votre espace de travail à l'état
dans lequel il était à \emph{n'importe quelle révision} de l'historique
du dépôt. Si vous aviez un espace de travail contenant une ancienne
révision---pour chercher l'origine d'un \textit{bug}, par exemple---et
que vous effectuiez un \hgcmd{pull} qui mettrait à jour automatiquement
votre espace de travail, vous ne seriez probablement pas très satisfait.

Néanmoins, comme les opérations de \textit{pull} sont très souvent
suivies d'un \textit{update}, Mercurial vous permet de combiner les
deux aisément en passant l'option \hgopt{pull}{-u} à la commande
\hgcmd{pull}
\begin{codesample2}
  hg pull -u
\end{codesample2}

Si vous étudiez de nouveau la sortie de la commande \hgcmd{pull} dans
<<<<<<< local
la section~\ref{sec:tour:pull} quand nous l'avons exécuté sans l'option
\hgopt{pull}{-u}, vous pouvez constater qu'elle a affiché le rappel assez
utile comme quoi vous devez encore effectuer une opération pour mettre à jour
=======
la section~\ref{sec:tour:pull} quand nous l'avons exécutée sans l'option
\hgopt{pull}{-u}, vous pouvez constater qu'elle a affiché un rappel assez
utile : vous devez encore effectuer une opération pour mettre à jour
>>>>>>> other
votre espace de travail:
\begin{codesample2}
  (run 'hg update' to get a working copy)
\end{codesample2}

<<<<<<< local
Pour découvrir sur quelle révision de l'espace de travail on est, utilisez
=======
Pour découvrir quelle révision de l'espace de travail en est où, utiliser
>>>>>>> other
la commande \hgcmd{parents}. 
\interaction{tour.parents}
Si vous regardez de nouveau le dessin~\ref{fig:tour-basic:history}, vous
<<<<<<< local
verrez les flèches reliant entre eux les \textit{changeset}. Le nœud 
d'où la flèche \emph{part} est dans chaque cas un parent, 
et le nœud où la flèche \emph{arrive} est un enfant. 
=======
verrez que les flèches reliant les \textit{changeset} entre eux. Le noeud 
dont la flèche mène \emph{de quelquepart} est dans chaque cas un parent, 
et le node dont la flèche mène \emph{vers quelquepart} est un enfant. %%%TODO: vers quelque part ?
>>>>>>> other
L'espace de travail a un parent de la même manière, c'est ce \textit{changeset} 
que l'espace de travail contient à ce moment.
%%%TODO : difficile à comprendre : l'espace de travail a un parent, de la même manière, c'est ce changeset que l'espace...

Pour mettre à jour l'espace de travail d'une révision particulière, 
indiquez un numéro de révision ou un \textit{changeset~ID} à la commande 
\hgcmd{update}.
\interaction{tour.older}
Si vous ne précisez pas de manière explicite de numéro de révision
la commande \hgcmd{update} mettra à jour votre espace de travail avec
<<<<<<< local
le contenu de la révision \textit{tip}, comme montré dans l'exemple 
ci-dessus lors du second appel à \hgcmd{update}.
=======
le contenu de la révsion \textit{tip}, comme montrée dans l'exemple 
ci dessus lors du second appel à \hgcmd{update}.
>>>>>>> other

\subsection{Transférer les modifications à un autre dépôt}

Mercurial vous laisse transférer les modifications à un autre
dépôt, depuis votre dépôt actuel. Comme dans l'exemple du 
\hgcmd{pull} ci-dessus, nous allons créer un dépôt temporaire
vers lequel transférer\footnote{NdT: Les francophones disent souvent 
``pousser'' tout simplement} nos modifications.
\interaction{tour.clone-push}
La commande \hgcmd{outgoing} nous indique quels changements nous
allons transférer vers l'autre serveur ?
\interaction{tour.outgoing}
Et la commande \hgcmd{push} effectue réellement le transfert.
\interaction{tour.push}
Comme avec \hgcmd{pull}, la commande \hgcmd{push} ne met pas à jour
le répertoire de travail du dépôt dans lequel il transfère les 
modifications. (À l'inverse de \hgcmd{pull}, \hgcmd{push} ne fournit
pas d'option \texttt{-u} pour forcer la mise à jour de l'espace
de travail cible).

Qu'est ce qui se passe lorsque vous essayez de récupérer ou de transférer
vos modifications et que le dépôt cible a déjà reçu ces modifications ? 
Rien de bien excitant.
\interaction{tour.push.nothing}

\subsection{Partager ses modifications à travers le réseau}

<<<<<<< local
Les commandes que nous avons étudiés dans les sections précédentes
ne se limitent pas aux dépôt locaux. Chacune commande fonctionne de la même
=======
Les commandes que nous avons étudiées dans les sections précédentes
ne sont pas limitées aux dépôt locaux. Chacune fonctionne de la même
>>>>>>> other
manière à travers une connexion réseau, il suffit de lui passer une 
URL à la place d'un chemin de fichier local.

\interaction{tour.outgoing.net}
Dans cet exemple, nous allons voir quels changements nous pourrions
transférer vers le dépôt distant, mais le dépôt est, de manière tout
à fait compréhensible, pas configuré pour accepter des modifications
d'utilisateurs anonymes.
\interaction{tour.push.net}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
