\chapter{Un rapide tour de Mercurial}
\label{chap:tour-basic}

\section{Installer Mercurial sur votre système}
\label{sec:tour:install}

Des paquetages binaires de Mercurial sont disponible pour tous les plupart
des systèmes d'exploitation, ce qui rend facile de commencer de suite
à utiliser Mercurial sur votre ordinateur.

\subsection{Linux}

Parce que chaque distribution de Linux a ses propres outils de gestion
de paquets, politique et rythme de développements, il est difficile de
donner un ensemble instructions fixes pour installer les binaires de
Mercurial. La version de Mercurial avec laquelle vous vous retrouverez
dépendera grandement selon l'activité de la personne en charge du paquetage
pour la distribution.

Pour rester simple, je me concentrerais sur l'installation de Mercurial
en ligne de commande, sous les plus courantes des distributions. La 
plupart des distributions fournissent des gestionnaires graphiques de
paquetage qui vous permettront d'installer Mercurial en quelques clicks.
Le paquetage devrait se nommer \textit{mercurial}.

\begin{itemize}
\item[Debian]
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}

\item[Fedora Core]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Gentoo]
  \begin{codesample4}
    emerge mercurial
  \end{codesample4}

\item[OpenSUSE]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Ubuntu] Le paquetage de Mercurial d'Ubuntu est construit sur celui de Debian. Pour
  l'installer, exécute simplement les commandes suivantes:
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}
  Les paquetages Ubuntu pour Mercurial ont tendance à être un peu en retard
  par rapport au paquetage Debian (au moment de l'écriture de ce livre, un 
  peu près 7 mois), ce qui signifie que parfois sur Ubuntu, vous risquez
  de rencontrer des problèmes qui ont été corrigés depuis longtemps dans
  les paquetages Debian.
\end{itemize}

\subsection{Solaris}

SunFreeWare, à \url{http://www.saufreeware.com}, est une bonne source 
pour trouver un vaste nombre de paquet précompiler pour 32 ou 64 bits
Intel et les architecture Sparc, dont les versions courantes de Mercurial.

\subsection{Mac OS X}

Lee Cantey publie un installeur de Mercurial pour Mac OS~X sur le site 
\url{http://mercurial.berkwood.com}.  Ce paquetage fonctionne sur les 
architecture Intel-~et PowerPCC. Avant de vous en servir, vous devez
installer une version Universel MacPython~\cite{web:macpython}. C'est
assez facile à faire : suivez simplement les instructions sur le site
de Lee.

Il est aussi possible d'installer Mercurial en utilisant Fink ou MacPorts,
deux outils de gestion de paquetage libre pour Mac OS X. Si vous avez 
Fink, utiliser \command{sudo fink install mercurial-py25}. Si vous avez 
acPorts, \command{sudo port install mercurial}.

\subsection{Windows}

Lee Cantey publie aussi un installeur de Mercurial pour Windows sur le site
\url{http://mercurial.berkwood.com}. Ce paquetage n'a aucune dépendance 
externe, il fonctionne ``tout court''.

\begin{note}
  Le version de Windows de Mercurial ne convertie pas automatiquement
  les retour chariot Windows et Unix. Si vous désirez partager votre
  travail avec des utilisateurs Unix, vous devez faire un peu de configuration
  supllémentaire. XXX En dire plus.
\end{note}

\section{Commencer à utiliser Mercurial}

Pour commencer, nous utiliserons la commande \hgcmd{version} pour vérifier
si Mercurial est installé proprement. Les informations affichées sur la 
version ne sont pas réellement importante en soit, c'est surtout de savoir
si elles s'affichent qui nous intéresse.
\interaction{tour.version}

\subsection{L'aide intégrée}

Mercurial fournit un système d'aide intégré, ce qui est inestimable quand
vous vous retrouvez coincé à essayer de vous rappeler comment lancer telle
ou telle commande. 
Si c'est le cas, exécuter simplement \hgcmd{help}; il vous aidera à imprimer
une brève liste de commandes, avec une description de ce qu'elle fait. Si vous
demandez de l'aide sur une commande spécifique (voir ci dessous), il affichera
des informations plus détaillés.
\interaction{tour.help}
Pour un niveau d'informations encore plus détaillé (ce dont vous aurez rarement
besoins), exécuter \hgcmdargs{help}{\hggopt{-v}}.  L'option \hggopt{-v} est 
l'abréviation de \hggopt{--verbose}, et indique à Mercurial d'afficher plus 
d'information que d'habitude.

\section{Travailler avec un dépot}

Avec Mercurial, tout se déroule au sein du \emph{dépot}\footnote{NdT: Dépôt est
la traduction que j'ai retenu pour tout l'ouvrage du terme anglais \textit{repository}}.
Le dépôt d'une projet contient tout les fichiers qui ``appartiennent'' 
au projet, avec l'historique des fichiers du projet.

Il n'y a rien de particulièrement magique au sujet de ce dépot, c'est
simplement une arboresence sur votre système de fichiers que Mercurial
traite de manière spéciale. Si vous pouvez renommer ou effacer ce répertoire
à n'importe quel moment, en utilisant la ligne de commande ou votre
explorateur de fichiers.

\subsection{Faire une copie locale de votre dépot}

\emph{Copier} un dépôt est just un peu spécial. Bien que vous 
puissiez utiliser une commande habituelle de copie pour copier
votre dépôt, il vaut mieux utiliser une commande fournie par
Mercurial. Cette commande est appelée \hgcmd{clone}, car elle
crée une copie identique d'un dépôt existant.
\interaction{tour.clone}
Si votre opération de clonage réussit, vous devriez maintenant
avoir un répertoire local appelé \dirname{hello}. Ce répertoire
contiendra quelques fichiers.
\interaction{tour.ls}
Ces fichiers ont le même contenu et historique dans votre dépôt
qu'ils ont dans le dépôt que vous avez cloné.

Chaque dépôt Mercurial est complet, autonome et indépendant. Il
contient sa propre copie privé des fichiers du projet et de leurs
historiques. Le clone d'un dépôt se souvient de la localisation du
dépôt à partir duquel il a été clôné, mais il ne communique pas avec
ce dernier, ou un autre, à moins que vous ne lui demandiez.

Ce que tout ceci signifie pour le moment est que nous sommes libre
d'expérimenter avec ce dépôt, confiant dans le fait qu'il s'agit d'un
``bac à sable'' qui n'affectera personne d'autres.

\subsection{Quel est le contenu d'un dépôt ?}

Prêtons plus attention un instant au contenu d'un dépôt. Nous voyons 
qu'il contient un répertoire nommée \dirname{.hg}. C'est ici que Mercurial
conserve toutes ses métadonnées.
\interaction{tour.ls-a}

Le contenu du répertoire \dirname{.hg} et ses sous répertoires sont les
seules propre à Mercurial. Tout les autres fichiers et répertoire dans 
le répertoire sont à vous, et vous pouvez faire ce que vous en voulez.

Pour introduire un peu de terminologie, le répertoire \dirname{.hg} est
un ``vrai'' dépôt, et tout les fichiers et les répertoires qui coexistent
avec lui, sont désigné sous le nom de \emph{espace de travail}\footnote{NdT: 
\textit{working directory}}. Une manière facile de se rappeler cette 
distinction est de retenir que le \emph{dépôt} contient l'\emph{historique}
de votre projet, alors que l'\emph{espace de travail} contient une \emph{copie
précise}\footnote{NdT: Ce terme est une traduction du terme anglais 
\textit{snapshot}. Il est traduit ici pour faciliter la lecture, mais ne sera
plus traduit par la suite.} de votre projet à un certain point de son
historique.

\section{Une ballade dans l'historique}

Une des premières choses que vous aurez envie de faire avec un nouveau
dépôt, sera de comprendre son historique. La commande \hgcmd{log} vous
donne une vue de l'historique.
\interaction{tour.log}
Par défaut, cette commande affiche à l'écran un bref paragraphe pour chaque
révision enregistrée pour ce projet. Dans la terminologie de Mercurial, nous
appelons chacun de ces évènements enregistrés un \emph{changeset}, parce 
qu'il contient un ensemble de mofications sur plusieurs fichiers.

La commande \hgcmd{log} affiche ainsi ces informations:
\begin{itemize}
\item[\texttt{changeset}] Ce champ contient un nombre, séparé par une 
  virgule, d'une chaine hexadécimal. Il s'agit en effet d'\emph{identifiants}
  pour un \textit{changeset}. Il y a deux identifiants car le numéro de
  la révision est plus court et plus à facile à saisir qu'une séquence
  hexadécimale.
\item[\texttt{utilisateur}] L'identité de la personne qui a crée ce 
  \textit{changeset}. C'est un champ libre de forme, mais la plupart du
  temps il contient le nom et l'email de la personne.
\item[\texttt{date}] La date et l'heure à laquelle le \textit{changeset}
  a été crée, ainsi que le \textit{timezone} dans laquelle il a été crée. %%%TODO: Translate 'timezone' properly
  (La date et l'heure sont locals à cette \textit{timezone}, ils indiquent
  donc quelle date et quelle il était pour la personne qui a crée ce 
  \textit{changeset}.)
\item[\texttt{résumé}] La première du message que le créateur a associée à
  son \textit{changeset} pour le décrire.
\end{itemize}

Par défaut, la commande \hgcmd{log} n'affiche qu'un résumé, il manque 
beaucoup de détails.


La figure~\ref{fig:tour-basic:history} fournit un représentation graphique
de l'historique du dépôt \dirname{hello}, pour rendre plus facile de voir
dans quelle direction l'historique se ``déroule''\footnote{NdT: \textit{flowing in}.}.
Nous reviendrons régulièrement à cette représentation dans ce chapitre et
ceux qui suivent.

\begin{figure}[ht]
  \centering
  \grafix{tour-history}
  \caption{Représentation graphique du dépôt \dirname{hello} }
  \label{fig:tour-basic:history}
\end{figure}

\subsection{Changesets, révisions, et discuter avec les autres}

Comme l'anglais est réputé pour un langage maladroit, et que l'informatique
est la source de bien des erreurs terminologique (pourquoi utiliser un
seul terme quand quatre feront l'affaire ?), la gestion de version a une
variété de mot et de phrases qui veulent dire la même chose. Si vous 
parlez à quelqu'un de l'historique de Mercurial à d'autres personnes, 
vous constaterez que souvent le mot ``\textit{changeset}'' est compressé 
en juste ``change'' ou (à l'écrit) ``cset'', et même parfois un 
\textit{changeset} simplement ``révision'', abrégé en ``rev''.

Bien que le \emph{mot} que vous utilisez pour désigner le concept de
\textit{changeset} importe peu, l'\emph{identifiant} que vous utilisez
pour désigner un \emph{spécifique} \textit{spécifique} a une grande
importance. Rappelez vous que le \textit{changeset} affiché par la 
commande \hgcmd{log} identifie un \textit{changeset} à la fois avec
un numéro de révision et une séquence hexadécimale.

\begin{itemize}
\item Le numéro de révision est \emph{seulement valable dans ce dépôt},
\item alors que la séquence hexadécimale est un \emph{identifiant 
	permanent, et immutable } qui pourra toujours être associé à %%%TODO: Immutable ? Is this french ?
	\textit{changeset} exacte de \emph{chaque} copie de votre dépôt.
\end{itemize}

La distinction est importante. Si vous envoyez un email à quelqu'un en
parlant de la ``révision 33'', il est très probable que sa révision~33
\emph{ne sera pas la même} que la votre. La raison de ceci est que le
numéro de révision dépend de l'ordre dans lequel les modifications sont
arrivés dans le dépôt, et il n'y a aucune garantie que les mêmes changements
soient arrivés dans le même ordre dans différents dépôts. Trois modifications
$a,b,c$ peuvent aisément apparaitre dans un dépôt comme $0,1,2$, et dans
un autre comme $1,0,2$.

Mercurial utilise les numéro de révision uniquement comme des raccourcis
pratique. Si vous devez disctuer d'un \textit{changeset} avec quelqu'un, 
our faire un enregistrement d'un \textit{changeset} pour une quelquonque
raison (par exemple, un rapport de \textit{bug}), utilisez la séquence
hexadécimale.

\subsection{Afficher une révision spécifique}

Pour réduire la sortie de \hgcmd{log} à une seule révision, utilisez
l'option \hgopt{log}{-r} (ou \hgopt{log}{--rev}). Vous pouvez utiser
le numéro de révision ou la séquence hexadécimal comme identifiant, et 
vous demandez autant de révisions que vous le souhaitez. 
\interaction{tour.log-r}

Si vous voulez voir l'historique de plusieurs révisions sans avoir à 
les énumérer, vous pouvez utiliser la \emph{\textit{range notation}}
\footnote{NdT: Il n'est pas aisé de traduire ce terme, donc je le 
laisse en anglais} qui vous permet d'exprimer l'idée ``je veux toutes
les révisions entre $a$ et $b$, inclus''.
\interaction{tour.log.range}
Mercurial respecte aussi l'ordre dans lequel vous spécifier les 
révisions, ainsi \hgcmdargs{log}{-r 2:4} affichera $2,3,4$ alors que 
\hgcmdargs{log}{-r 4:2} affichera $4,3,2$.

\subsection{Informations détaillées}

Si le résumé affiché par \hgcmd{log} est utile si vous savez déjà ce 
que vous cherchez. Vous aurez probablement besoin de voir un description
complète du changement, ou une liste des fichiers modifiés. Si vous 
cherchez à déterminer si ce \textit{changeset} est bien celui que vous
recherchez. L'option \hgopt{-v} de la commande \hgcmd{log} (ou 
\hgopt{--verbose}) vous donne des informations supplémentaires.
\interaction{tour.log-v}

Si vous voulez voir à la fois la description et le contenu d'une 
modification, ajouter l'option \hgopt{log}{-p} (ou \hgopt{log}{--patch}). 
Ceci affiche le contenu d'une modification comme un \emph{diff unifié}
\footnote{NdT: \textit{unified diff}} (si vous n'avez jamais vu de diff 
unifié avant, consulter la section~\ref{sec:mq:patch} pour rapide
survol).
\interaction{tour.log-vp}

\section{Tout sur les options de commandes}

Avant d'aller plus loin sur le fonctionnement des commandes de Mercurial,
étudions un moment comment elles fonctionnent de manière générale, vous
trouverez ça probablement utile pour la suite de notre parcours.

Mercurial a une manière approche directe et cohérente pour interpréter
les options que vous passez aux commandes. Il suit une convention commune
à la plupart des systèmes Unix et Linux modernes.

\begin{itemize}
\item Every option has a long name.  For example, as we've already
  seen, the \hgcmd{log} command accepts a \hgopt{log}{--rev} option.
\item Most options have short names, too.  Instead of
  \hgopt{log}{--rev}, we can use \hgopt{log}{-r}.  (The reason that
  some options don't have short names is that the options in question
  are rarely used.)
\item Long options start with two dashes (e.g.~\hgopt{log}{--rev}),
  while short options start with one (e.g.~\hgopt{log}{-r}).
\item Option naming and usage is consistent across commands.  For
  example, every command that lets you specify a changeset~ID or
  revision number accepts both \hgopt{log}{-r} and \hgopt{log}{--rev}
  arguments.
\end{itemize}
In the examples throughout this book, I use short options instead of
long.  This just reflects my own preference, so don't read anything
significant into it.

Most commands that print output of some kind will print more output
when passed a \hggopt{-v} (or \hggopt{--verbose}) option, and less
when passed \hggopt{-q} (or \hggopt{--quiet}).

\section{Making and reviewing changes}

Now that we have a grasp of viewing history in Mercurial, let's take a
look at making some changes and examining them.

The first thing we'll do is isolate our experiment in a repository of
its own.  We use the \hgcmd{clone} command, but we don't need to
clone a copy of the remote repository.  Since we already have a copy
of it locally, we can just clone that instead.  This is much faster
than cloning over the network, and cloning a local repository uses
less disk space in most cases, too.
\interaction{tour.reclone}
As an aside, it's often good practice to keep a ``pristine'' copy of a
remote repository around, which you can then make temporary clones of
to create sandboxes for each task you want to work on.  This lets you
work on multiple tasks in parallel, each isolated from the others
until it's complete and you're ready to integrate it back.  Because
local clones are so cheap, there's almost no overhead to cloning and
destroying repositories whenever you want.

In our \dirname{my-hello} repository, we have a file
\filename{hello.c} that contains the classic ``hello, world'' program.
Let's use the ancient and venerable \command{sed} command to edit this
file so that it prints a second line of output.  (I'm only using
\command{sed} to do this because it's easy to write a scripted example
this way.  Since you're not under the same constraint, you probably
won't want to use \command{sed}; simply use your preferred text editor to
do the same thing.)
\interaction{tour.sed}

Mercurial's \hgcmd{status} command will tell us what Mercurial knows
about the files in the repository.
\interaction{tour.status}
The \hgcmd{status} command prints no output for some files, but a line
starting with ``\texttt{M}'' for \filename{hello.c}.  Unless you tell
it to, \hgcmd{status} will not print any output for files that have
not been modified.  

The ``\texttt{M}'' indicates that Mercurial has noticed that we
modified \filename{hello.c}.  We didn't need to \emph{inform}
Mercurial that we were going to modify the file before we started, or
that we had modified the file after we were done; it was able to
figure this out itself.

It's a little bit helpful to know that we've modified
\filename{hello.c}, but we might prefer to know exactly \emph{what}
changes we've made to it.  To do this, we use the \hgcmd{diff}
command.
\interaction{tour.diff}

\section{Recording changes in a new changeset}

We can modify files, build and test our changes, and use
\hgcmd{status} and \hgcmd{diff} to review our changes, until we're
satisfied with what we've done and arrive at a natural stopping point
where we want to record our work in a new changeset.

The \hgcmd{commit} command lets us create a new changeset; we'll
usually refer to this as ``making a commit'' or ``committing''.  

\subsection{Setting up a username}

When you try to run \hgcmd{commit} for the first time, it is not
guaranteed to succeed.  Mercurial records your name and address with
each change that you commit, so that you and others will later be able
to tell who made each change.  Mercurial tries to automatically figure
out a sensible username to commit the change with.  It will attempt
each of the following methods, in order:
\begin{enumerate}
\item If you specify a \hgopt{commit}{-u} option to the \hgcmd{commit}
  command on the command line, followed by a username, this is always
  given the highest precedence.
\item If you have set the \envar{HGUSER} environment variable, this is
  checked next.
\item If you create a file in your home directory called
  \sfilename{.hgrc}, with a \rcitem{ui}{username} entry, that will be
  used next.  To see what the contents of this file should look like,
  refer to section~\ref{sec:tour-basic:username} below.
\item If you have set the \envar{EMAIL} environment variable, this
  will be used next.
\item Mercurial will query your system to find out your local user
  name and host name, and construct a username from these components.
  Since this often results in a username that is not very useful, it
  will print a warning if it has to do this.
\end{enumerate}
If all of these mechanisms fail, Mercurial will fail, printing an
error message.  In this case, it will not let you commit until you set
up a username.

You should think of the \envar{HGUSER} environment variable and the
\hgopt{commit}{-u} option to the \hgcmd{commit} command as ways to
\emph{override} Mercurial's default selection of username.  For normal
use, the simplest and most robust way to set a username for yourself
is by creating a \sfilename{.hgrc} file; see below for details.

\subsubsection{Creating a Mercurial configuration file}
\label{sec:tour-basic:username}

To set a user name, use your favourite editor to create a file called
\sfilename{.hgrc} in your home directory.  Mercurial will use this
file to look up your personalised configuration settings.  The initial
contents of your \sfilename{.hgrc} should look like this.
\begin{codesample2}
  # This is a Mercurial configuration file.
  [ui]
  username = Firstname Lastname <email.address@domain.net>
\end{codesample2}
The ``\texttt{[ui]}'' line begins a \emph{section} of the config file,
so you can read the ``\texttt{username = ...}'' line as meaning ``set
the value of the \texttt{username} item in the \texttt{ui} section''.
A section continues until a new section begins, or the end of the
file.  Mercurial ignores empty lines and treats any text from
``\texttt{\#}'' to the end of a line as a comment.

\subsubsection{Choosing a user name}

You can use any text you like as the value of the \texttt{username}
config item, since this information is for reading by other people,
but for interpreting by Mercurial.  The convention that most people
follow is to use their name and email address, as in the example
above.

\begin{note}
  Mercurial's built-in web server obfuscates email addresses, to make
  it more difficult for the email harvesting tools that spammers use.
  This reduces the likelihood that you'll start receiving more junk
  email if you publish a Mercurial repository on the web.
\end{note}

\subsection{Writing a commit message}

When we commit a change, Mercurial drops us into a text editor, to
enter a message that will describe the modifications we've made in
this changeset.  This is called the \emph{commit message}.  It will be
a record for readers of what we did and why, and it will be printed by
\hgcmd{log} after we've finished committing.
\interaction{tour.commit}

The editor that the \hgcmd{commit} command drops us into will contain
an empty line, followed by a number of lines starting with
``\texttt{HG:}''.
\begin{codesample2}
  \emph{empty line}
  HG: changed hello.c
\end{codesample2}
Mercurial ignores the lines that start with ``\texttt{HG:}''; it uses
them only to tell us which files it's recording changes to.  Modifying
or deleting these lines has no effect.

\subsection{Writing a good commit message}

Since \hgcmd{log} only prints the first line of a commit message by
default, it's best to write a commit message whose first line stands
alone.  Here's a real example of a commit message that \emph{doesn't}
follow this guideline, and hence has a summary that is not readable.
\begin{codesample2}
  changeset:   73:584af0e231be
  user:        Censored Person <censored.person@example.org>
  date:        Tue Sep 26 21:37:07 2006 -0700
  summary:     include buildmeister/commondefs.   Add an exports and install
\end{codesample2}

As far as the remainder of the contents of the commit message are
concerned, there are no hard-and-fast rules.  Mercurial itself doesn't
interpret or care about the contents of the commit message, though
your project may have policies that dictate a certain kind of
formatting.

My personal preference is for short, but informative, commit messages
that tell me something that I can't figure out with a quick glance at
the output of \hgcmdargs{log}{--patch}.

\subsection{Aborting a commit}

If you decide that you don't want to commit while in the middle of
editing a commit message, simply exit from your editor without saving
the file that it's editing.  This will cause nothing to happen to
either the repository or the working directory.

If we run the \hgcmd{commit} command without any arguments, it records
all of the changes we've made, as reported by \hgcmd{status} and
\hgcmd{diff}.

\subsection{Admiring our new handiwork}

Once we've finished the commit, we can use the \hgcmd{tip} command to
display the changeset we just created.  This command produces output
that is identical to \hgcmd{log}, but it only displays the newest
revision in the repository.
\interaction{tour.tip}
We refer to the newest revision in the repository as the tip revision,
or simply the tip.

\section{Sharing changes}

We mentioned earlier that repositories in Mercurial are
self-contained.  This means that the changeset we just created exists
only in our \dirname{my-hello} repository.  Let's look at a few ways
that we can propagate this change into other repositories.

\subsection{Pulling changes from another repository}
\label{sec:tour:pull}

To get started, let's clone our original \dirname{hello} repository,
which does not contain the change we just committed.  We'll call our
temporary repository \dirname{hello-pull}.
\interaction{tour.clone-pull}

We'll use the \hgcmd{pull} command to bring changes from
\dirname{my-hello} into \dirname{hello-pull}.  However, blindly
pulling unknown changes into a repository is a somewhat scary
prospect.  Mercurial provides the \hgcmd{incoming} command to tell us
what changes the \hgcmd{pull} command \emph{would} pull into the
repository, without actually pulling the changes in.
\interaction{tour.incoming}
(Of course, someone could cause more changesets to appear in the
repository that we ran \hgcmd{incoming} in, before we get a chance to
\hgcmd{pull} the changes, so that we could end up pulling changes that we
didn't expect.)

Bringing changes into a repository is a simple matter of running the
\hgcmd{pull} command, and telling it which repository to pull from.
\interaction{tour.pull}
As you can see from the before-and-after output of \hgcmd{tip}, we
have successfully pulled changes into our repository.  There remains
one step before we can see these changes in the working directory.

\subsection{Updating the working directory}

We have so far glossed over the relationship between a repository and
its working directory.  The \hgcmd{pull} command that we ran in
section~\ref{sec:tour:pull} brought changes into the repository, but
if we check, there's no sign of those changes in the working
directory.  This is because \hgcmd{pull} does not (by default) touch
the working directory.  Instead, we use the \hgcmd{update} command to
do this.
\interaction{tour.update}

It might seem a bit strange that \hgcmd{pull} doesn't update the
working directory automatically.  There's actually a good reason for
this: you can use \hgcmd{update} to update the working directory to
the state it was in at \emph{any revision} in the history of the
repository.  If you had the working directory updated to an old
revision---to hunt down the origin of a bug, say---and ran a
\hgcmd{pull} which automatically updated the working directory to a
new revision, you might not be terribly happy.

However, since pull-then-update is such a common thing to do,
Mercurial lets you combine the two by passing the \hgopt{pull}{-u}
option to \hgcmd{pull}.
\begin{codesample2}
  hg pull -u
\end{codesample2}
If you look back at the output of \hgcmd{pull} in
section~\ref{sec:tour:pull} when we ran it without \hgopt{pull}{-u},
you can see that it printed a helpful reminder that we'd have to take
an explicit step to update the working directory:
\begin{codesample2}
  (run 'hg update' to get a working copy)
\end{codesample2}

To find out what revision the working directory is at, use the
\hgcmd{parents} command.
\interaction{tour.parents}
If you look back at figure~\ref{fig:tour-basic:history}, you'll see
arrows connecting each changeset.  The node that the arrow leads
\emph{from} in each case is a parent, and the node that the arrow
leads \emph{to} is its child.  The working directory has a parent in
just the same way; this is the changeset that the working directory
currently contains.

To update the working directory to a particular revision, give a
revision number or changeset~ID to the \hgcmd{update} command.
\interaction{tour.older}
If you omit an explicit revision, \hgcmd{update} will update to the
tip revision, as shown by the second call to \hgcmd{update} in the
example above.

\subsection{Pushing changes to another repository}

Mercurial lets us push changes to another repository, from the
repository we're currently visiting.  As with the example of
\hgcmd{pull} above, we'll create a temporary repository to push our
changes into.
\interaction{tour.clone-push}
The \hgcmd{outgoing} command tells us what changes would be pushed
into another repository.
\interaction{tour.outgoing}
And the \hgcmd{push} command does the actual push.
\interaction{tour.push}
As with \hgcmd{pull}, the \hgcmd{push} command does not update the
working directory in the repository that it's pushing changes into.
(Unlike \hgcmd{pull}, \hgcmd{push} does not provide a \texttt{-u}
option that updates the other repository's working directory.)

What happens if we try to pull or push changes and the receiving
repository already has those changes?  Nothing too exciting.
\interaction{tour.push.nothing}

\subsection{Sharing changes over a network}

The commands we have covered in the previous few sections are not
limited to working with local repositories.  Each works in exactly the
same fashion over a network connection; simply pass in a URL instead
of a local path.
\interaction{tour.outgoing.net}
In this example, we can see what changes we could push to the remote
repository, but the repository is understandably not set up to let
anonymous users push to it.
\interaction{tour.push.net}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
