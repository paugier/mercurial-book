\chapter{Un rapide tour de Mercurial: fusionner les travaux}
\label{chap:tour-merge}

Nous avons maintenons étudié comment cloner un dépôt, effectuer
des changements dedans, et récupérer ou transférer depuis un 
autre dépôt. La prochaine étape est donc de \emph{fusionner} les
modifications de différents dépôts.

\section{Fusionner différents travaux} %%%TODO: better translation
				       %%% for 'Merging streams of work' ?
La fusion\footnote{NdT: Je garde fusion mais le jargon professionnel 
emploiera généralement le terme \textit{merge}.} est un aspect 
fondamental lorsqu'on travail avec un gestionnaire de source 
distribué.
\begin{itemize}
\item Alice et Bob ont chacun une copie personnelle du dépôt d'un
  projet sur lequel ils collaborent. Alice corrige un \textit{bug} 
  dans son dépôt, et Bob ajoute une nouvelle fonctionnalité dans le
  sien. Ils veulent un dépôt partagé avec à la fois le correctif du
  \textit{bug} et la nouvelle fonctionnalité.
\item Je travaille régulièrement sur plusieurs tâches différentes sur
  un seul projet en même temps, chacun isolée dans son propre dépôt.
  Travailler ainsi signifie que je dois régulièrement fusionner une 
  partie de mon code avec celui des autres.
\end{itemize}

Parce que la fusion est une opération si commune que je dois réaliser,
Mercurial la rend facile. Étudions ensemble le déroulement des opérations.
Nous commencerons par faire un clone de encore un autre dépôt (vous voyez
comment on fait ça tout le temps ?) puis nous ferons quelques modifications
dessus.
\interaction{tour.merge.clone}
Nous devrions avoir maintenant deux copies de \filename{hello.c} avec 
des contenus différents. Les historiques de ces deux dépôts ont aussi 
divergés, comme illustré dans la figure~\ref{fig:tour-merge:sep-repos}.

\interaction{tour.merge.cat}

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-sep-repos}
  \caption{Historiques récent divergents des dépôts \dirname{my-hello} 
  et \dirname{my-new-hello}}
  \label{fig:tour-merge:sep-repos}
\end{figure}

Nous savons déjà que récupérer les modifications depuis notre dépôt 
\dirname{my-hello} n'aura aucun effet sur l'espace de travail.

\interaction{tour.merge.pull}

Néanmoins, la commande \hgcmd{pull} nous indique quelque chose au 
sujet des ``heads''.

\subsection{\textit{Head changesets}} %%%TODO: Hard (too?) to translate

Une \textit{head}\footnote{NdT: Je garde \textit{head} que j'accorde 
au féminin comme la coutume oral l'a imposée.} est un \textit{changeset} 
sans descendants, ou enfants, comme on les désigne parfois. La révision 
\textit{tip} est une \textit{head}, car la dernière révision dans un dépôt 
n'a aucun enfant, mais il est important de noter qu'un dépôt peut contenir 
plus d'une \textit{head}.

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-pull}
  \caption{Contenu d'un dépôt après avoir transférer le contenu du dépôt 
    \dirname{my-hello} dans le dépôt \dirname{my-new-hello}}
  \label{fig:tour-merge:pull}
\end{figure}

Dans la figure~\ref{fig:tour-merge:pull}, vous pouvez constater l'effet
d'un \textit{pull} depuis le dépôt \dirname{my-hello} dans le dépôt 
\dirname{my-new-hello}. L'historique qui était déjà présent dans le dépôt
\dirname{my-new-hello} reste intact, mais une nouvelle révision a été 
ajoutée. En vous reportant à la figure~\ref{fig:tour-merge:sep-repos},
vous pouvez voir que le \textit{\emph{changeset ID}} reste le même dans
le nouveau dépôt, mais que le \emph{numéro de révision} reste le même.
(Ceci est un parfait exemple de pourquoi il n'est fiable d'utiliser les
numéro de révision lorsque l'on discute d'un \textit{changeset}.) Vous
pouvez voir les \texit{heads} présente dans le dépôt en utilisant la 
commande \hgcmd{heads}.
\interaction{tour.merge.heads}

\subsection{Effectuer la fusion}

Que se passe-t-il quand vous essayez d'utiliser la commande \hgcmd{update} 
pour mettre à jour votre espace de travail au nouveau \textit{tip}.
\interaction{tour.merge.update}
Mercurial nous prévient que la commande \hgcmd{update} n'effectuera pas
la fusion, il ne veut pas mettre à jour l'espace de travail quand il 
estime que nous pourrions avoir besoin d'une fusion, à moins de lui
forcer la main. À la place, il faut utiliser la commande \hgcmd{merge}
pour fusionner les deux \textit{heads}.
\interaction{tour.merge.merge}

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-merge}
  \caption{Espace de travail et dépôt lors d'une fusion, et dans le
    \textit{commit} qui suit.}
  \label{fig:tour-merge:merge}
\end{figure}

Ceci met à jour de l'espace de travail de manière à ce qu'il contienne
les modifications des \emph{deux} \textit{heads}, ce qui apparaît dans
les sorties de la commande \hgcmd{parents} et le contenu de 
\filename{hello.c}. 
\interaction{tour.merge.parents}

\subsection{Effectuer le \textit{commit} du résultat de la fusion}

Dès l'instant où vous avez effectuer une fusion, \hgcmd{parents} vous
affichera deux parents, avant que vous n'exécuter la commande 
\hgcmd{commit} sur le résultat de la fusion.
\interaction{tour.merge.commit}
Nous avons maintenant un nouveau \textit{tip}, remarquer qu'il contient
\emph{à la fois} nos anciennes \textit{heads} et leurs parents. Ce sont
les mêmes révisions que nous avions affichés avec la commande 
\hgcmd{parents}.

\interaction{tour.merge.tip}
Dans la figure~\ref{fig:tour-merge:merge}, vous pouvez voir une représentation
de ce qui se passe dans l'espace de travail pendant la fusion, et comment ceci
affecte le dépôt lors du \textit{commit}. Pendant la fusion, l'espace de travail,
qui a deux \texit{changesets} comme parents, voit ces derniers devenir le parent
d'un nouveau \textit{changeset}.

\section{Fusionner les modifications en conflit}

La plupart des fusions sont assez simple à réaliser, mais parfois 
vous vous trouverez à fusionner des fichiers où la modification touche
la même portion de code, au sein d'un même fichier. À moins que ces
modification ne soient identiques, ceci aboutira à un \emph{conflit},
et vous devrez décider comment réconcilier les différentes modifications
dans un tout cohérent. 

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-conflict}
  \caption{Modifications conflictuelles dans un document}
  \label{fig:tour-merge:conflict}
\end{figure}

La figure~\ref{fig:tour-merge:conflict} illustre un cas de modifications
conflictuelles dans un document. Nous avons commencé avec une version simple
de ce fichier, puis nous avons ajoutés des modifications, pendant que 
quelqu'un d'autre modifie le même texte. Notre tâche dans la résolution
du conflit est de décider à quoi le fichier devrait ressembler.

Mercurial n'a pas de mécanisme interne pour gérer les conflits. 
À la place, il exécute un programme externe appelé \command{hgmerge}.
Il s'agit d'un script shell qui est embarqué par Mercurial, vous
pouvez le modifier si vous le voulez. Ce qu'il fait par défaut est
d'essayer de trouver un des différents outils de fusion qui seront
probablement installé sur le système. Il commence par les outils
totalement automatique, et si ils échouent (parce que la résolution
du conflit nécessite une intervention humaine) ou si ils sont absents,
le script tente d'exécuter certains outils graphiques de fusion.

Il est aussi possible de demander à Mercurial d'exécuter un autre
programme ou un autre script au lieu de la commande \command{hgmerge},
en définissant la variable d'environnement \envar{HGMERGE} avec le nom
du programme de votre choix.

\subsection{Utiliser un outil graphique de fusion}

Mon outil de fusion préféré est \command{kdiff3}, que j'utilise ici
pour illustré les fonctionnalités classiques des outils graphiques 
de fusion. Vous pouvez voir une capture d'écran de l'utilisation de 
\command{kdiff3} dans la figure~\ref{fig:tour-merge:kdiff3}. Cet outil
effectue une \emph{fusion \textit{three-way}}, car il y a trois différentes
versions du fichier qui nous intéresse. Le fichier découpe la partie
supérieure de la fenêtre en trois panneaux:

\begin{itemize}
\item A gauche on la version de \emph{base} du fichier, soit ~la plus 
  récente version des deux versions qu'on souhaite fusionner.
\item Au centre, il y a ``notre'' version du fichier, avec le contenu 
  que nous avons modifié.
\item Sur la droite, on trouve ``leur'' version du fichier, celui qui qui
  contient le \textit{changeset} que nous souhaitons intégré. 
\end{itemize}

Dans le panneau en dessous, on trouve le \emph{résultat} actuel de notre
fusion. Notre tâche consiste donc à remplacement tout les textes en rouges,
qui indiquent des conflits non résolus, avec un fusion manuel et pertinente
de ``notre'' version et de la ``leur''. 

Tout les quatre panneaux sont \emph{accrochés ensemble}, si nous déroulons
les ascenseurs verticalement ou horizontalement dans chacun d'entre eux, les
autres sont mise à jours avec la section correspondantes dans leurs fichiers.

\begin{figure}[ht]
  \centering
  \grafix{kdiff3}
  \caption{Utilisation de  \command{kdiff3} pour fusionner différents versions
  d'un fichier.}
  \label{fig:tour-merge:kdiff3}
\end{figure}

Pour chaque portion de fichier posant problème, nous pouvons choisir 
de résoudre le le conflit en utilisant en utilisant une combinaison 
de texte depuis la version de base, la notre, ou la leur. Nous pouvons 
aussi éditer manuellement les fichiers à tous moments, si c'est
nécessaire.

Il y a \emph{beaucoup} d'outils de fusion disponibles, bien trop pour
en parler de tous ici. Leurs disponibilités varient selon les plate formes
ainsi que leurs avantages et inconvénients. La plupart sont optimisé pour
la fusion de fichier contenant un texte plat, certains sont spécialisé
dans un format de fichier précis (généralement XML).

\subsection{A worked example} %TODO: Find a translation for this !

Dans cet exemple, nous allons reproduire la modification de l'historique
du fichier de la figure~\ref{fig:tour-merge:conflict} ci dessus. Commençons
par créer un dépôt avec une version de base de notre document.

\interaction{tour-merge-conflict.wife}
Créons un clone de ce dépôt et faisons une modification dans le fichier.
\interaction{tour-merge-conflict.cousin}
Et un autre clone, pour simuler que quelqu'un d'autre effectuer une
modification sur le fichier. (Ceci pour suggérer qu'il n'est pas rare
de devoir effectuer des \textit{merge} avec vos propres travaux quand 
vous isoler les tâches dans des dépôts distincts. En effet, vous 
aurez alors à trouver et résoudre certains conflits).
\interaction{tour-merge-conflict.son}
Maintenant que ces deux versions différentes du même fichier sont 
créées, nous allons configurer l'environnement approprié pour exécuter 
notre \textit{merge}.
\interaction{tour-merge-conflict.pull}

Dans cette exemple, je n'utiliserais pas la commande Mercurial
habituelle \command{hgmerge} pour effectuer le \textit{merge},
car il me faudrait abandonner ce joli petit exemple automatisé
pour utiliser un outil graphique. À la place, je vais définir
la variable d'environnement \envar{HGMERGE} pour indiquer à 
Mercurial d'utiliser la commande non-interactive \command{merge}.
Cette dernière est embarqué par de nombreux systèmes ``à la Unix''.
Si vous exécuter cet exemple depuis votre ordinateur, ne vous
occupez pas de définir \envar{HGMERGE}.
\interaction{tour-merge-conflict.merge}
Parce que \command{merge} ne peut pas résoudre les modifications
conflictuelles, il laisse des \emph{marqueurs de différences}
\footnote{NdT: Oui, je traduis \textit{merge markers} par un sens
inverse en Français, mais je pense vraiment que c'est plus clair 
comme ça...} à l'intérieur du fichier qui a des conflits, indiquant
clairement quelles lignes sont en conflits, et si elles viennent de
notre fichier ou du fichier externe.

Mercurial peut distinguer, à la manière dont la commande \command{merge}
se termine, qu'elle n'a pas été capable d'effectuer le \textit{merge},
alors il nous indique qu'il faut devons effectuer de nouveau cette
opération. Ceci peut être très utile si, par exemple, nous exécutons un
outil graphique de fusion et que nous le quittons sans se rendre compte
qu'il reste des conflits ou simplement par erreur.

Si le \textit{merge} automatique ou manuel échoue, il n'y a rien pour
nous empêcher de ``corriger le tir'' en modifiant nous même les fichiers,
et enfin effectuer le \textit{commit} du fichier:
\interaction{tour-merge-conflict.commit}

\section{Simplifying the pull-merge-commit sequence}
\label{sec:tour-merge:fetch}

The process of merging changes as outlined above is straightforward,
but requires running three commands in sequence.
\begin{codesample2}
  hg pull
  hg merge
  hg commit -m 'Merged remote changes'
\end{codesample2}
In the case of the final commit, you also need to enter a commit
message, which is almost always going to be a piece of uninteresting
``boilerplate'' text.

It would be nice to reduce the number of steps needed, if this were
possible.  Indeed, Mercurial is distributed with an extension called
\hgext{fetch} that does just this.

Mercurial provides a flexible extension mechanism that lets people
extend its functionality, while keeping the core of Mercurial small
and easy to deal with.  Some extensions add new commands that you can
use from the command line, while others work ``behind the scenes,''
for example adding capabilities to the server.

The \hgext{fetch} extension adds a new command called, not
surprisingly, \hgcmd{fetch}.  This extension acts as a combination of
\hgcmd{pull}, \hgcmd{update} and \hgcmd{merge}.  It begins by pulling
changes from another repository into the current repository.  If it
finds that the changes added a new head to the repository, it begins a
merge, then commits the result of the merge with an
automatically-generated commit message.  If no new heads were added,
it updates the working directory to the new tip changeset.

Enabling the \hgext{fetch} extension is easy.  Edit your
\sfilename{.hgrc}, and either go to the \rcsection{extensions} section
or create an \rcsection{extensions} section.  Then add a line that
simply reads ``\Verb+fetch +''.
\begin{codesample2}
  [extensions]
  fetch =
\end{codesample2}
(Normally, on the right-hand side of the ``\texttt{=}'' would appear
the location of the extension, but since the \hgext{fetch} extension
is in the standard distribution, Mercurial knows where to search for
it.)

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
