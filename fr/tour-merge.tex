\chapter{Un rapide tour de Mercurial: fusionner les travaux}
\label{chap:tour-merge}

Nous avons maintenons étudié comment clôner un dépôt, effectuer
des changements dedans, et récupérer ou transférer depuis un 
autre dépôt. La prochaine étape est donc de \emph{fusionner} les
modifications de différents dépôts.

\section{Fusionner différents travaux} %%%TODO: better translation
				       %%% for 'Merging streams of work' ?
La fusion\footnote{NdT: Je garde fusion mais le jargon professionnel 
employera généralement le terme \textit{merge}.} est un aspect 
fondamental lorsqu'on travail avec un gestionnaire de source 
distribé.
\begin{itemize}
\item Alice et Bob ont chacun une copie personnelle du dépôt d'un
  projet sur lequel ils collaborent. Alice corrige un \textit{bug} 
  dans son dépôt, et Bob ajoute une nouvelle fonctionnalité dans le
  sien. Ils veulent un dépôt partagé avec à la fois le correctif du
  \textit{bug} et la nouvelle fonctionnalité.
\item Je travaille régulièrement sur plusieurs tâches différentes sur
  un seul projet en même temps, chacun isolée dans son propre dépôt.
  Travailler ainsi signifie que je dois régulièrement fusionner une 
  partie de mon code avec celui des autres.
\end{itemize}

Parce que la fusion est une opération si commune que je dois réaliser,
Mercurial la rend facile. Etudions ensemble le déroulement des opérations.
Nous commencerons par faire un clone d'encore un autre dépôt (vous voyez
comment on fait ça tout le temps ?) puis nous ferons quelques modifications
dessus.
\interaction{tour.merge.clone}
Nous devrions avoir maintenant deux copies de \filename{hello.c} avec 
des contenus différents. Les historiques de ces deux dépôts ont aussi 
divergés, comme illustré dans la figure~\ref{fig:tour-merge:sep-repos}.

\interaction{tour.merge.cat}

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-sep-repos}
  \caption{Historiques récent divergents des dépôts \dirname{my-hello} 
  et \dirname{my-new-hello}}
  \label{fig:tour-merge:sep-repos}
\end{figure}

Nous savons déjà que récupérer les modifications depuis notre dépôt 
\dirname{my-hello} n'aura aucun effet sur l'espace de travail.

\interaction{tour.merge.pull}

Néanmoins, la commande \hgcmd{pull} nous indique quelquechose au 
sujet des ``heads''.

\subsection{\textit{Head changesets}} %%%TODO: Hard (too?) to translate

Une \textit{head}\footnote{NdT: Je garde \textit{head} que j'accorde 
au féminin comme la coutume oral l'a imposée.} est un \textit{changeset} 
sans descendants, ou enfants, comme on les désigne parfois. La révision 
\textit{tip} est une \textit{head}, car la dernière révision dans un dépôt 
n'a aucun enfant, mais il est important de noter qu'un dépôt peut contenir 
plus d'une \textit{head}.

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-pull}
  \caption{Contenu d'un dépôt après avoir transférer le contenu du dépôt 
    \dirname{my-hello} dans le dépôt \dirname{my-new-hello}}
  \label{fig:tour-merge:pull}
\end{figure}

Dans la figure~\ref{fig:tour-merge:pull}, vous pouvez constater l'effet
d'un \textit{pull} depuis le dépôt \dirname{my-hello} dans le dépôt 
\dirname{my-new-hello}. L'historique qui était déjà présent dans le dépôt
\dirname{my-new-hello} reste intact, mais une nouvelle révision a été 
ajoutée. En vous reportant à la figure~\ref{fig:tour-merge:sep-repos},
vous pouvez voir que le \textit{\emph{changeset ID}} reste le même dans
le nouveau dépôt, mais que le \emph{numéro de révision} reste le même.
(Ceci est un parfait exemple de pourquoi il n'est fiable d'utiliser les
numéro de révision lorsque l'on discute d'un \textit{changeset}.) Vous
pouvez voir les \texit{heads} présente dans le dépôt en utilisant la 
commande \hgcmd{heads}.
\interaction{tour.merge.heads}

\subsection{Effectuer la fusion}

Que se passe-t-il quand vous essayez d'utiliser la commande \hgcmd{update} 
pour mettre à jour votre espace de travail au nouveau \textit{tip}.
\interaction{tour.merge.update}
Mercurial nous prévient que la commande \hgcmd{update} n'effectuera pas
la fusion, il ne veut pas mettre à jour l'espace de travail quand il 
estime que nous pourrions avoir besoin d'une fusion, à moins de lui
forcer la main. À la place, il faut utiliser la commande \hgcmd{merge}
pour fusionner les deux \textit{heads}.
\interaction{tour.merge.merge}

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-merge}
  \caption{Espace de travail et dépôt lors d'une fusion, et dans le
    \textit{commit} qui suit.}
  \label{fig:tour-merge:merge}
\end{figure}

Ceci met à jour de l'espace de travail de manière à ce qu'il contienne
les modifications des \emph{deux} \textit{heads}, ce qui apparait dans
les sorties de la commande \hgcmd{parents} et le contenu de 
\filename{hello.c}. 
\interaction{tour.merge.parents}

\subsection{Committing the results of the merge}

Whenever we've done a merge, \hgcmd{parents} will display two parents
until we \hgcmd{commit} the results of the merge.
\interaction{tour.merge.commit}
Nous avons maintenant un nouveau \textit{tip}, remarquer qu'il contient
\emph{à la fois} nos anciennes \textit{heads} et leurs parents. Ce sont
les mêmes révisions que nous avions affichés avec la commande 
\hgcmd{parents}.

\interaction{tour.merge.tip}
Dans la figure~\ref{fig:tour-merge:merge}, vous pouvez voir une représentation
de ce qui se passe dans l'espace de travail pendant la fusion, et comment ceci
affecte le dépôt lors du \textit{commit}. Pendant la fusion, l'espace de travail,
qui a deux \texit{changesets} comme parents, voit ces derniers devenir le parent
d'un nouveau \textit{changeset}.

\section{Fusionner les modifications en conflit}

La plupart des fusions sont assez simple à réaliser, mais parfois 
vous vous trouverez à fusioner des fichiers où la modification touche
la même portion de code, au sein d'un même fichier. À moins que ces
modification ne soient identiques, ceci aboutira à un \emph{conflit},
et vous devrez décider comment réconcillier les différentes modifications
dans un tout cohérent. 

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-conflict}
  \caption{Modifications conflictuelles dans un document}
  \label{fig:tour-merge:conflict}
\end{figure}

La figure~\ref{fig:tour-merge:conflict} illustre un cas de modifications
conflictuelles dans un document. Nous avons commencé avec une version simple
de ce fichier, puis nous avons ajoutés des modifications, pendant que 
quelqu'un d'autre modifie le même texte. Notre tâche dans la résolution
du conflit est de décider à quoi le fichier devrait ressembler.

Mercurial n'a pas de mécanisme interne pour gérer les conflits. 
À la place, il exéctue un programme externe appelé \command{hgmerge}.
Il s'agit d'un script shell qui est embarqué par Mercurial, vous
pouvez le modifier si vous le voulez. Ce qu'il fait par défaut est
d'essayer de trouver un des différents outils de fusion qui seront
probablement installé sur le système. Il commence par les outils
totalement automatique, et si ils échouent (parce que la résolution
du conflit nécessite une intervention humaine) ou si ils sont absents,
le script tente d'exécuter certains outils graphiques de fusion.

Il est aussi possible de demander à Mercurial d'exécuter un autre
programme ou un autre script au lieu de la commande \command{hgmerge},
en définissant la variable d'environement \envar{HGMERGE} avec le nom
du programme de votre choix.

\subsection{Utiliser un outil graphique de fusion}

Mon outil de fusion préféré est \command{kdiff3}, que j'utilise ici
pour illustré les fonctionnalités classiques des outils graphiques 
de fusion. Vous pouvez voir une capture d'écran de l'utilisation de 
\command{kdiff3} dans la figure~\ref{fig:tour-merge:kdiff3}. Cet outil
effectue une \emph{fusion \textit{three-way}}, car il y a trois différentes
versions du fichier qui nous intéresse. Le fichier découpe la partie
supérieure de la fenêtre en trois panneaux:

\begin{itemize}
\item A gauche on la version de \emph{base} du fichier, soit ~la plus 
  récente version des deux versions qu'on souhaite fusionner.
\item Au centre, il y a ``notre'' version du fichier, avec le contenu 
  que nous avons modifié.
\item Sur la droite, on trouve ``leur'' version du fichier, celui qui qui
  contient le \textit{changeset} que nous souhaitons intégré. 
\end{itemize}

Dans le panneau en dessous, on trouve le \emph{résultat} actuel de notre
fusion. Notre tâche consiste donc à remplacement tout les textes en rouges,
qui indiquent des conflits non résolus, avec un fusion manuel et pertinente
de ``notre'' version et de la ``leur''. 

Tout les quatres panneaux sont \emph{accrochés ensemble}, si nous déroulons
les ascenseurs verticalement ou horizontalement dans chacun d'entre eux, les
autres sont mise à jours avec la section correspondantes dans leurs fichiers.

\begin{figure}[ht]
  \centering
  \grafix{kdiff3}
  \caption{Utilisation de  \command{kdiff3} pour fusionner différents versions
  d'un fichier.}
  \label{fig:tour-merge:kdiff3}
\end{figure}

Pour chaque portion de fichier posant problème, nous pouvons choisir 
de résoudre le le conlfit en utilisant en utilisant une combinaison 
de texte depuis la version de base, la notre, ou la leur. Nous pouvons 
aussi éditer manuellement les fichiers à tous moments, si c'est
nécessaire.

Il y a \emph{beaucoup} d'outils de fusion disponibles, bien trop pour
en parler de tous ici. Leurs disponibilités varient selon les plateformes
ainsi que leurs avantages et incovénients. La plupart sont optimisé pour
la fusion de fichier contenant un texte plat, certains sont spécialisé
dans un format de fichier précis (générallement XML).

\subsection{A worked example}

In this example, we will reproduce the file modification history of
figure~\ref{fig:tour-merge:conflict} above.  Let's begin by creating a
repository with a base version of our document.
\interaction{tour-merge-conflict.wife}
We'll clone the repository and make a change to the file.
\interaction{tour-merge-conflict.cousin}
And another clone, to simulate someone else making a change to the
file.  (This hints at the idea that it's not all that unusual to merge
with yourself when you isolate tasks in separate repositories, and
indeed to find and resolve conflicts while doing so.)
\interaction{tour-merge-conflict.son}
Having created two different versions of the file, we'll set up an
environment suitable for running our merge.
\interaction{tour-merge-conflict.pull}

In this example, I won't use Mercurial's normal \command{hgmerge}
program to do the merge, because it would drop my nice automated
example-running tool into a graphical user interface.  Instead, I'll
set \envar{HGMERGE} to tell Mercurial to use the non-interactive
\command{merge} command.  This is bundled with many Unix-like systems.
If you're following this example on your computer, don't bother
setting \envar{HGMERGE}.
\interaction{tour-merge-conflict.merge}
Because \command{merge} can't resolve the conflicting changes, it
leaves \emph{merge markers} inside the file that has conflicts,
indicating which lines have conflicts, and whether they came from our
version of the file or theirs.

Mercurial can tell from the way \command{merge} exits that it wasn't
able to merge successfully, so it tells us what commands we'll need to
run if we want to redo the merging operation.  This could be useful
if, for example, we were running a graphical merge tool and quit
because we were confused or realised we had made a mistake.

If automatic or manual merges fail, there's nothing to prevent us from
``fixing up'' the affected files ourselves, and committing the results
of our merge:
\interaction{tour-merge-conflict.commit}

\section{Simplifying the pull-merge-commit sequence}
\label{sec:tour-merge:fetch}

The process of merging changes as outlined above is straightforward,
but requires running three commands in sequence.
\begin{codesample2}
  hg pull
  hg merge
  hg commit -m 'Merged remote changes'
\end{codesample2}
In the case of the final commit, you also need to enter a commit
message, which is almost always going to be a piece of uninteresting
``boilerplate'' text.

It would be nice to reduce the number of steps needed, if this were
possible.  Indeed, Mercurial is distributed with an extension called
\hgext{fetch} that does just this.

Mercurial provides a flexible extension mechanism that lets people
extend its functionality, while keeping the core of Mercurial small
and easy to deal with.  Some extensions add new commands that you can
use from the command line, while others work ``behind the scenes,''
for example adding capabilities to the server.

The \hgext{fetch} extension adds a new command called, not
surprisingly, \hgcmd{fetch}.  This extension acts as a combination of
\hgcmd{pull}, \hgcmd{update} and \hgcmd{merge}.  It begins by pulling
changes from another repository into the current repository.  If it
finds that the changes added a new head to the repository, it begins a
merge, then commits the result of the merge with an
automatically-generated commit message.  If no new heads were added,
it updates the working directory to the new tip changeset.

Enabling the \hgext{fetch} extension is easy.  Edit your
\sfilename{.hgrc}, and either go to the \rcsection{extensions} section
or create an \rcsection{extensions} section.  Then add a line that
simply reads ``\Verb+fetch +''.
\begin{codesample2}
  [extensions]
  fetch =
\end{codesample2}
(Normally, on the right-hand side of the ``\texttt{=}'' would appear
the location of the extension, but since the \hgext{fetch} extension
is in the standard distribution, Mercurial knows where to search for
it.)

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
