\chapter{Un rapide tour de Mercurial: fusionner les travaux}
\label{chap:tour-merge}

Nous avons maintenant étudié comment cloner un dépôt, effectuer
des changements dedans, et récupérer ou transférer depuis un 
autre dépôt. La prochaine étape est donc de \emph{fusionner} les
modifications de différents dépôts.

\section{Fusionner différents travaux} %%%TODO: better translation
				       %%% for 'Merging streams of work' ?
La fusion\footnote{NdT: Je garde fusion mais le jargon professionnel 
emploiera généralement le terme \textit{merge}.} est un aspect 
fondamental lorsqu'on travaille avec un gestionnaire de source 
distribué.
\begin{itemize}
\item Alice et Bob ont chacun une copie personnelle du dépôt d'un
  projet sur lequel ils collaborent. Alice corrige un \textit{bug} 
  dans son dépôt, et Bob ajoute une nouvelle fonctionnalité dans le
  sien. Ils veulent un dépôt partagé avec à la fois le correctif du
  \textit{bug} et la nouvelle fonctionnalité.
\item Je travaille régulièrement sur plusieurs tâches différentes sur
  un seul projet en même temps, chacun isolé dans son propre dépôt.
  Travailler ainsi signifie que je dois régulièrement fusionner une 
  partie de mon code avec celui des autres.
\end{itemize}

Parce que la fusion est une opération si commune à réaliser,
Mercurial la rend facile. Étudions ensemble le déroulement des opérations.
Nous commencerons encore par faire un clone d'un autre dépôt (vous voyez
que l'on fait ça tout le temps ?) puis nous ferons quelques modifications
dessus.
\interaction{tour.merge.clone}
Nous devrions avoir maintenant deux copies de \filename{hello.c} avec 
des contenus différents. Les historiques de ces deux dépôts ont aussi 
divergés, comme illustré dans la figure~\ref{fig:tour-merge:sep-repos}.

\interaction{tour.merge.cat}

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-sep-repos}
  \caption{Historiques récent divergents des dépôts \dirname{my-hello} 
  et \dirname{my-new-hello}}
  \label{fig:tour-merge:sep-repos}
\end{figure}

Nous savons déjà que récupérer les modifications depuis notre dépôt 
\dirname{my-hello} n'aura aucun effet sur l'espace de travail.

\interaction{tour.merge.pull}

Néanmoins, la commande \hgcmd{pull} nous indique quelque chose au 
sujet des ``heads''.

\subsection{\textit{Head changesets}} %%%TODO: Hard (too?) to translate

Une \textit{head}\footnote{NdT: Je garde \textit{head} que j'accorde 
au féminin comme la coutume orale l'a imposé.} est un \textit{changeset} 
sans descendants, ou enfants, comme on les désigne parfois. La révision 
\textit{tip} est une \textit{head}, car la dernière révision dans un dépôt 
n'a aucun enfant, mais il est important de noter qu'un dépôt peut contenir 
plus d'une \textit{head}.

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-pull}
  \caption{Contenu d'un dépôt après avoir transféré le contenu du dépôt 
    \dirname{my-hello} dans le dépôt \dirname{my-new-hello}}
  \label{fig:tour-merge:pull}
\end{figure}

Dans la figure~\ref{fig:tour-merge:pull}, vous pouvez constater l'effet
d'un \textit{pull} depuis le dépôt \dirname{my-hello} dans le dépôt 
\dirname{my-new-hello}. L'historique qui était déjà présent dans le dépôt
\dirname{my-new-hello} reste intact, mais une nouvelle révision a été 
ajoutée. En vous reportant à la figure~\ref{fig:tour-merge:sep-repos},
vous pouvez voir que le \textit{\emph{changeset ID}} reste le même dans
le nouveau dépôt, mais que le \emph{numéro de révision} reste le même.
(Ceci est un parfait exemple de pourquoi il n'est fiable d'utiliser les
numéros de révision lorsque l'on discute d'un \textit{changeset}.) Vous
pouvez voir les \texit{heads} présentes dans le dépôt en utilisant la 
commande \hgcmd{heads}.
\interaction{tour.merge.heads}

\subsection{Effectuer la fusion}

Que se passe-t-il quand vous essayez d'utiliser la commande \hgcmd{update} 
pour mettre à jour votre espace de travail au nouveau \textit{tip}.
\interaction{tour.merge.update}
Mercurial nous prévient que la commande \hgcmd{update} n'effectuera pas
la fusion, il ne veut pas mettre à jour l'espace de travail quand il 
estime que nous pourrions avoir besoin d'une fusion, à moins de lui
forcer la main. À la place, il faut utiliser la commande \hgcmd{merge}
pour fusionner les deux \textit{heads}.
\interaction{tour.merge.merge}

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-merge}
  \caption{Espace de travail et dépôt lors d'une fusion, et dans le
    \textit{commit} qui suit.}
  \label{fig:tour-merge:merge}
\end{figure}

Ceci met à jour l'espace de travail de manière à ce qu'il contienne
les modifications des \emph{deux} \textit{heads}, ce qui apparaît dans
les sorties de la commande \hgcmd{parents} et le contenu de 
\filename{hello.c}. 
\interaction{tour.merge.parents}

\subsection{Effectuer le \textit{commit} du résultat de la fusion}

Dès l'instant où vous avez effectué une fusion, \hgcmd{parents} vous
affichera deux parents, avant que vous n'exécutiez la commande 
\hgcmd{commit} sur le résultat de la fusion.
\interaction{tour.merge.commit}
Nous avons maintenant un nouveau \textit{tip}, remarquer qu'il contient
\emph{à la fois} nos anciennes \textit{heads} et leurs parents. Ce sont
les mêmes révisions que nous avions affichées avec la commande 
\hgcmd{parents}.

\interaction{tour.merge.tip}
Dans la figure~\ref{fig:tour-merge:merge}, vous pouvez voir une représentation
de ce qui se passe dans l'espace de travail pendant la fusion, et comment ceci
affecte le dépôt lors du \textit{commit}. Pendant la fusion, l'espace de travail,
qui a deux \texit{changesets} comme parents, voit ces derniers devenir le parent
%%% TODO: le parent ou "les parents" : plus logique mais si il reste seulement 
%%% un changeset, alors c'est effectivement un parent (le changeset est hermaphrodite)
d'un nouveau \textit{changeset}.

\section{Fusionner les modifications en conflit}

La plupart des fusions sont assez simple à réaliser, mais parfois 
vous vous retrouverez à fusionner des fichiers où la modification touche
la même portion de code, au sein d'un même fichier. À moins que ces
modification ne soient identiques, ceci aboutira à un \emph{conflit},
et vous devrez décider comment réconcilier les différentes modifications
dans un tout cohérent. 

\begin{figure}[ht]
  \centering
  \grafix{tour-merge-conflict}
  \caption{Modifications conflictuelles dans un document}
  \label{fig:tour-merge:conflict}
\end{figure}

La figure~\ref{fig:tour-merge:conflict} illustre un cas de modifications
conflictuelles dans un document. Nous avons commencé avec une version simple
de ce fichier, puis nous avons ajouté des modifications, pendant que 
quelqu'un d'autre modifiait le même texte. Notre tâche dans la résolution
du conflit est de décider à quoi le fichier devrait ressembler.

Mercurial n'a pas de mécanisme interne pour gérer les conflits. 
À la place, il exécute un programme externe appelé \command{hgmerge}.
Il s'agit d'un script shell qui est embarqué par Mercurial, vous
pouvez le modifier si vous le voulez. Ce qu'il fait par défaut est
d'essayer de trouver un des différents outils de fusion qui seront
probablement installés sur le système. Il commence par les outils
totalement automatiques, et si ils échouent (parce que la résolution
du conflit nécessite une intervention humaine) ou si ils sont absents,
le script tente d'exécuter certains outils graphiques de fusion.

Il est aussi possible de demander à Mercurial d'exécuter un autre
programme ou un autre script au lieu de la commande \command{hgmerge},
en définissant la variable d'environnement \envar{HGMERGE} avec le nom
du programme de votre choix.

\subsection{Utiliser un outil graphique de fusion}

Mon outil de fusion préféré est \command{kdiff3}, que j'utilise ici
pour illustrer les fonctionnalités classiques des outils graphiques 
de fusion. Vous pouvez voir une capture d'écran de l'utilisation de 
\command{kdiff3} dans la figure~\ref{fig:tour-merge:kdiff3}. Cet outil
effectue une \emph{fusion \textit{three-way}}, car il y a trois différentes
versions du fichier qui nous intéresse. Le fichier découpe la partie
supérieure de la fenêtre en trois panneaux:

\begin{itemize}
\item A gauche on la version de \emph{base} du fichier, soit la plus 
  récente version des deux versions qu'on souhaite fusionner.
\item Au centre, il y a ``notre'' version du fichier, avec le contenu 
  que nous avons modifié.
\item Sur la droite, on trouve ``leur'' version du fichier, celui qui
  contient le \textit{changeset} que nous souhaitons intégré. 
\end{itemize}

Dans le panneau en dessous, on trouve le \emph{résultat} actuel de notre
fusion. Notre tâche consiste donc à remplacement tous les textes en rouges,
qui indiquent des conflits non résolus, avec une fusion manuelle et pertinente
de ``notre'' version et de la ``leur''. 

Tous les quatre panneaux sont \emph{accrochés ensemble}, si nous déroulons
les ascenseurs verticalement ou horizontalement dans chacun d'entre eux, les
autres sont mis à jour avec la section correspondante dans leurs fichiers
respectifs.

\begin{figure}[ht]
  \centering
  \grafix{kdiff3}
  \caption{Utilisation de \command{kdiff3} pour fusionner différentes versions
  d'un fichier.}
  \label{fig:tour-merge:kdiff3}
\end{figure}

Pour chaque portion de fichier posant problème, nous pouvons choisir 
de résoudre le conflit en utilisant une combinaison 
de texte depuis la version de base, la notre, ou la leur. Nous pouvons 
aussi éditer manuellement les fichiers à tout moment, si c'est
nécessaire.

Il y a \emph{beaucoup} d'outils de fusion disponibles, bien trop pour
en parler de tous ici. Leurs disponibilités varient selon les plate formes
ainsi que leurs avantages et inconvénients. La plupart sont optimisé pour
la fusion de fichier contenant un texte plat, certains sont spécialisé
dans un format de fichier précis (généralement XML).

\subsection{Un exemple concret}

Dans cet exemple, nous allons reproduire la modification de l'historique
du fichier de la figure~\ref{fig:tour-merge:conflict} ci dessus. Commençons
par créer un dépôt avec une version de base de notre document.

\interaction{tour-merge-conflict.wife}
Créons un clone de ce dépôt et faisons une modification dans le fichier.
\interaction{tour-merge-conflict.cousin}
Et un autre clone, pour simuler que quelqu'un d'autre effectue une
modification sur le fichier. (Ceci pour suggérer qu'il n'est pas rare
de devoir effectuer des \textit{merge} avec vos propres travaux quand 
vous isolez les tâches dans des dépôts distincts. En effet, vous 
aurez alors à trouver et résoudre certains conflits).
\interaction{tour-merge-conflict.son}
Maintenant que ces deux versions différentes du même fichier sont 
créées, nous allons configurer l'environnement de manière appropriée pour
exécuter notre \textit{merge}.
\interaction{tour-merge-conflict.pull}

Dans cette exemple, je n'utiliserais pas la commande Mercurial
habituelle \command{hgmerge} pour effectuer le \textit{merge},
car il me faudrait abandonner ce joli petit exemple automatisé
pour utiliser un outil graphique. À la place, je vais définir
la variable d'environnement \envar{HGMERGE} pour indiquer à 
Mercurial d'utiliser la commande non-interactive \command{merge}.
Cette dernière est embarquée par de nombreux systèmes ``à la Unix''.
Si vous exécutez cet exemple depuis votre ordinateur, ne vous
occupez pas de définir \envar{HGMERGE}.
\interaction{tour-merge-conflict.merge}
Parce que \command{merge} ne peut pas résoudre les modifications
conflictuelles, il laisse des \emph{marqueurs de différences}
\footnote{NdT: Oui, je traduis \textit{merge markers} par un sens
inverse en Français, mais je pense vraiment que c'est plus clair 
comme ça...} à l'intérieur du fichier qui a des conflits, indiquant
clairement quelles lignes sont en conflits, et si elles viennent de
notre fichier ou du fichier externe.

Mercurial peut distinguer, à la manière dont la commande \command{merge}
se termine, qu'elle n'a pas été capable d'effectuer le \textit{merge},
alors il nous indique que nous devons effectuer de nouveau cette
opération. Ceci peut être très utile si, par exemple, nous exécutons un
outil graphique de fusion et que nous le quittons sans nous rendre compte
qu'il reste des conflits ou simplement par erreur.

Si le \textit{merge} automatique ou manuel échoue, il n'y a rien pour
nous empêcher de ``corriger le tir'' en modifiant nous même les fichiers,
et enfin effectuer le \textit{commit} du fichier:
\interaction{tour-merge-conflict.commit}

\section{Simplification de la séquence pull-merge-commit}
\label{sec:tour-merge:fetch}

La procédure pour effectuer la fusion indiquée ci-dessus est simple,
mais requiert le lancement de trois commandes à la suite.
\begin{codesample2}
  hg pull
  hg merge
  hg commit -m 'Merged remote changes'
\end{codesample2}

Lors du \textit{commit} final, vous devez également saisir un message,
qui aura vraisemblablement assez peu d'intérêt.

Il serait assez sympathique de pouvoir réduire le nombre d'opérations
nécessaire, si possible. De fait Mercurial est fourni avec une
extension appelé \hgext{fetch} qui fait justement cela.

Mercurial fourni un mécanisme d'extension flexible qui permet à chacun
d'étendre ces fonctionnalités, tout en conservant le cœur de Mercurial
léger et facile à utiliser. Certains extensions ajoutent de nouvelles
commandes que vous pouvez utiliser en ligne de commande, alors que
d'autres travaillent ``en coulisse,'' par exemple en ajoutant des
possibilités au serveur.

L'extension \hgext{fetch} ajoute une nouvelle commande nommée, sans
surprise, \hgcmd{fetch}. Cette extension résulte en une combinaison
de \hgcmd{pull}, \hgcmd{update} and \hgcmd{merge}. Elle commence par
récupérer les modifications d'un autre dépôt dans le dépôt courant.
Si elle trouve que les modifications ajoutent une nouvelle \textit{head},
elle effectue un \textit{merge}, et ensuite \texit{commit} le résultat
du \textit{merge} avec un message généré automatiquement. Si aucune
\textit{head} n'ont été ajouté, elle met à jour le répertoire de travail
au niveau du nouveau \textit{changeset} \textit{tip}.


Activer l'extension \hgext{fetch} est facile. Modifiez votre \sfilename{.hgrc},
et soit allez à la section \rcsection{extensions} soit créer une 
section \rcsection{extensions}. Ensuite ajoutez une ligne qui consiste
simplement en ``\Verb+fetch =''.

\begin{codesample2}
  [extensions]
  fetch =
\end{codesample2}
(Normalement, sur la partie droite de ``\texttt{=}'' devrait apparaître
le chemin de l'extension, mais étant donné que l'extension \hgext{fetch}
fait partie de la distribution standard, Mercurial sait où la trouver.)

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
