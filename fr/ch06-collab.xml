<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="cha:collab">
  <?dbhtml filename="collaborating-with-other-people.html"?>
  <title>Collaborer avec d'autres personnes</title>

  <para id="x_44a">Comme tout outil complètement décentralisé, Mercurial
    n'impose pas de politique sur la façon dont les personnes devraient
    travailler ensemble. Cependant, si vous êtes nouveau dans les systèmes de
    gestion de révisions distribués, cela aide d'avoir des outils et exemples
    en tête lorsque vous réfléchissez à de possibles modèles de
    workflow.</para>
  <!--TODO : workflow peut éventuellement être traduit ici par travail -->

  <sect1>
    <title>Interface web de Mercurial</title>

    <para id="x_44b">Mercurial possède une interface web puissante qui
      propose plusieurs fonctions utiles.</para>

    <para id="x_44c">Pour une utilisation intensive, l'interface web vous
      permet de naviguer dans un ou une collection de dépôt. Vous pouvez voir
      l'historique d'un dépôt, examiner chaque modification (commentaires et
      "diffs"), et voir le contenu de chaque répertoire et fichier. Vous
      pouvez même accéder à une vue de l'historique qui vous donne une vue
      graphique de la relation entre les modifications individuelles et les
      fusions (merge).</para>

    <para id="x_44d">De plus, pour l'utilisation humaine, l'interface web
      fournit des flux Atom et RSS des changements dans un dépôt. Ceci vous
      permet de <quote>souscrire</quote> à un dépôt en utilisant votre
      lecteur de flux favori, et être automatiquement avertis de l'activité
      dans ce dépôt aussi tôt qu'elle change. Je trouve cette fonctionnalité
      bien plus commode que le modèle qui consiste à souscrire à une mailing
      list à laquelle les avertissements sont envoyés, puisque cela demande
      aucune configuration supplémentaire de la part de la personne qui
      publie un dépôt.</para>

    <para id="x_44e">L'interface web permet aussi aux utilisateurs distants
      de cloner un dépôt, récupérer (pull) les changement à partir de celui
      ci, et (lorsque le serveur est configuré pour l'autoriser) lui envoyer
      (push) des changements. Le protocole de tunnel HTTP de Mercurial
      compresse agressivement les données, ainsi, il fonctionne efficacement,
      même au-dessus des réseaux avec une faible bande passante.</para>

    <para id="x_44f">La plus simple façon de démarrer avec l'interface
      utilisateur est d'utiliser votre navigateur web pour visiter un dépôt
      existant, tel que le dépôt principal de Mercurial à l'adresse <ulink
        url="http://www.selenic.com/repo/hg">http://www.selenic.com/repo/hg</ulink>.</para>

    <para id="x_450">Si vous êtes intéressés pour proposer une interface web
      de vos propres dépôts, il y a plusieurs façons de le faire.</para>
    
    <para id="x_69d">La façon la plus simple et la plus rapide pour commencer
      dans un environnement informel est d'utiliser la commande <command
        role="hg-cmd">hg serve</command> qui est la plus adaptée à un service
      à court terme et <quote>léger</quote>. Référez-vous à <xref
        linkend="sec:collab:serve"/> plus bas pour les détails d'utilisation
      de cette commande.</para>

    <para id="x_69e">Pour des dépôts dont la durée de vie est plus longue, où
      vous voudriez un service accessible en permanence, il existe plusieurs
      services publics d'hébergement qui sont accessibles. Certains sont
      libres et gratuits pour les projets Open Source, alors que d'autres
      offrent un hébergement commercial et payant. Une liste à jour est
      disponible à l'adresse : <ulink
        url="http://www.selenic.com/mercurial/wiki/index.cgi/MercurialHosting">http://www.selenic.com/mercurial/wiki/index.cgi/MercurialHosting</ulink>.</para>

    <para id="x_6a0">Si vous préférez héberger vos propres dépôts, Mercurial
      possède un support intégré pour plusieurs technologies populaires
      d'hébergement, plus particulièrement CGI (Common Gateway Interface) et
      WSGI (Web Services Gateway Interface). Référez-vous à <xref
        linkend="sec:collab:cgi"/> pour des détails sur la configuration CGI
      et WSGI.</para>
  </sect1>

  <sect1>
    <title>Modèles de collaboration</title>

    <para id="x_451">Avec un outil convenablement flexible, prendre des
      décisions sur les workflows est plus un problème d'ingénierie sociale
      qu'un problème technique. Mercurial impose peu de limitations sur
      la façon dont vous pouvez structurer le flux de travail dans un projet,
      donc, c'est à vous et votre groupe de fixer et vivre avec un modèle qui
      convient à vos besoins particuliers.</para>

    <sect2>
      <title>Facteurs à garder en tête</title>

      <para id="x_452">L'aspect le plus important de tout modèle que vous
        devez garder en tête est la façon dont il subvient aux besoins et
        capacités des personnes qui l'utiliseront. Ceci pourrait sembler
        évident en soi ; pourtant, vous ne pouvez pas vous permettre de
        l'oublier à un seul moment.</para>

      <para id="x_453">Une fois, j'ai mis en place un modèle de workflow qui
        m'apparaissait comme parfait, mais il a causé la consternation et des
        conflits au sein de mon équipe de développement. En dépit de mes
        tentatives pour expliquer pourquoi nous avions besoin d'un ensemble
        complexe de branches, et comment les changements devaient couler
        entre eux, certains membres de l'équipe se révoltèrent. Alors qu'ils
        étaient pourtant des personnes sympathiques, ils ne voulaient pas
        prêter attention aux contraintes sur lesquelles nous étions en train
        d'opérer, ou, face aux conséquences de ces contraintes dans les
        détails du modèle que je préconisais.</para>

      <para id="x_454">Ne balayez pas les problèmes sociaux ou techniques de
        la main. Quelque soit le schéma que vous établirez, vous devriez
        planifier un protocole pour prévenir, ou rapidement vous relever de
        troubles que vous pouvez anticiper. Par exemple, si vous vous
        attendez à avoir une branche pour les changements pas-pour-release,
        vous devriez penser très tôt à la possibilité qu'une personne
        fusionne (merge) accidentellement ces changements avec une branche de
        release. Vous pouvez empécher ce problème particulier en écrivant un
        hook qui prévient les changements d'être fusionnés à partir d'une
        branche inopportune.</para>
    </sect2>

    <sect2>
      <title>Anarchie informelle</title>

      <para id="x_455">Je ne voudrais pas suggérer qu'une approche
        <quote>tout peut arriver</quote> comme quelque chose de durable, mais
        il s'agit d'un modèle qui est simple à saisir et qui fonctionne
        parfaitement dans quelques situations inhabituelles.</para>

      <para id="x_456">Par exemple, beaucoup de projets ont un groupe distant
        de collaborateurs qui ne se rencontre physiquement que très rarement.
        Certains groupes aiment vaincre l'isolation du travail à distance en
        organisant occasionnellement des <quote>sprints</quote>. Dans un
        sprint, des personnes viennent ensemble dans un même
        endroit (la salle de conférence d'une société, la salle de réunion
        d'un hôtel, ce genre d'endroit) et y passent plusieurs jours, plus ou
        moins enfermés, et hackant intensément sur une poignée de
        projets.</para>

      <para id="x_457">Un "sprint" ou une session de "hacking" dans un café
        sont les endroits parfaits pour utiliser la commande <command
          role="hg-cmd">hg serve</command> puisque <command role="hg-cmd">hg
          serve</command> n'a pas besoin d'une infrastructure extraordinaire
        de serveurs. Vous pouvez commencer avec la commande <command
          role="hg-cmd">hg serve</command> en quelques instants, en lisant <xref
          linkend="sec:collab:serve"/> plus bas  Ensuite, dites simplement à
        la personne à côté de vous que vous exécutez un serveur, envoyez-lui
        l'URL par un message instantané, et vous avez immédiatement un moyen
        simple et rapide de travailler ensemble. Ils peuvent taper votre URL
        dans leur navigateur web et rapidement revoir vos
        changements ; ou ils peuvent récupérer chez vous un bugfix et le
        vérifier ; ou ils peuvent cloner une branche contenant une nouvelle
        fonctionnalité et la tester.</para>
        
      <para id="x_458">Le charme et le problème en faisant les choses ainsi,
        dans un mode ad-hoc est que seules les personnes qui sont au courant
        de vos changements, et de leur emplacement, peuvent les voir. Une
        telle approche informelle ne passe simplement pas à l'échelle au delà
        d'une poignée de personnes, puisque chacun a besoin de connaître
        <emphasis>n</emphasis> différents dépôts à partir des quels récupérer
        les changements (pull).</para>
    </sect2>

    <sect2>
      <title>Un simple dépôt central</title>

      <para id="x_459">Pour de plus petits projets qui migrent depuis un
        outil de gestion de révision centralisé, la façon la
        plus simple de commencer est certainement d'avoir un flux de
        changement à partir d'un unique dépôt central. Il s'agit aussi du
        <quote>composant</quote> pour des schémas de workflow plus
        ambitieux.</para>

      <para id="x_45a">Les contributeurs commencent par cloner une copie de
        ce dépôt. Ils peuvent récupérer les changements à n'importe quel
        moment où ils en ressentent le besoin, et certains (sûrement tous)
        développeurs ont les persmissions qui leur permettent d'envoyer leurs
        modifications (push) en retour lorsqu'elles sont prêtes pour que les
        autres personnes puissent les voir.</para>

      <para id="x_45b">Dans ce modèle, il peut encore être sensé pour les
        gens de récupérer les changements directement entre eux, sans passer
        par le dépôt central. Considérez le cas où j'ai un bug
        fix provisoire, mais je m'inquiète de savoir si, dans le cas où je le publiais,
        cela ne casserait pas l'arbre des autres contributeurs s'ils la
        récupèreraient. Pour réduire les dommages potentiels, je peux vous
        demander de cloner mon dépôt dans un dépôt temporaire qui vous
        appartient et de le tester. Ceci nous permet de ne pas publier les
        modification potentiellement dangereuses tant qu'elles n'ont pas
        encore été un peu testées.</para>

      <para id="x_45c">Si une équipe héberge son propre dépôt dans ce type de
        scénario, les personnes qui utilisent habituellement le protocole
        <command>ssh</command> pour envoyer (push) en toute sécurité leurs
        changements au dépôt central, comme docummenté dans <xref
          linkend="sec:collab:ssh"/>. Il est aussi usuel de publier une copie
        en lecture seule du dépôt sur HTTP comme dans <xref
          linkend="sec:collab:cgi"/>. Publier sur HTTP satisfait le besoin
        des personnes qui n'ont pas d'accès en écriture, et ceux qui veulent
        utiliser leur navigateur web pour explorer l'historique du
        dépôt.</para>
    </sect2>

    <sect2>
      <title>Un dépôt central hébergé</title>

      <para id="x_6a1">Une chose magnifique au sujet des services
        d'hébergement comme <ulink
          url="http://bitbucket.org/">Bitbucket</ulink> est qu'ils ne gèrent
        pas uniquement les détails minutieux de la configuration du
        serveur, tels que les comptes utilisateurs, l'authentification, les
        protocoles sécurisés, ils fournissent aussi une infrastructure
        additionnelle pour que ce modèle fonctionne
        bien.</para>

      <para id="x_6a2">Par exemple, un service d'hébergement bien conçu
        laissera les personnes cloner leurs copies d'un dépôt à l'aide d'un
        simple clic. Ceci laisse les personnes travailler dans des espaces
        séparés et partager leurs changements lorsqu'ils sont prêts.</para>

      <para id="x_6a3">De plus, un bon service d'hébergement laissera les
        personnes communiquer ensemble, par exemple pour dire <quote>Il y a
          des changements prêts pour toi pour relecture dans cet
          arbre</quote>.</para>
        
    </sect2>

    <sect2>
      <title>Travailler avec plusieurs branches</title>

      <para id="x_45d">Les projets d'une taille significative ont tendance à
        avancer sur plusieurs fronts en même temps. Dans le cas de logiciel,
        il est commun qu'un projet sorte périodiquement des releases
        officielles. Une release devrait ensuite aller dans le <quote>mode de
          maintenance</quote> pour un moment après sa première publication ;
        les releases de maintenance tendent à contenir seulement des
        corrections de bugs, et non de nouvelles fonctionnalités. En
        parallèle de ces releases de maintenance, une ou plusieurs futures
        releases doivent être en cours de développement. Les gens utilisent
        en général le mot <quote>branche</quote> pour référer à l'une de ces
        nombreuses directions légèrement différentes dans lesquelles le
        développement évolue.</para>

      <para id="x_45e">Mercurial est particulièrement bien adapté pour gérer
        plusieurs branches simultanées mais non identiques. Chaque
        <quote>direction de développement</quote> peut vivre dans son propre
        dépôt central, et vous pouvez récupérez les changements de l'un ou
        l'autre lorsque le besoin s'en fait sentir. Parce que les dépôts sont
        indépendant les uns des autres, les modifications instables dans une
        branche de développement n'affecteront jamais une branche stable,
        sauf si quelqu'un fusionne (merge) explicitement ces changements dans
        la branche stable.</para>

      <para id="x_45f">Voici un exemple sur comment cela peut se passer en
        pratique. Disons que vous avez une <quote>branche principale</quote>
        sur un serveur central.</para>

      &interaction.branching.init;

      <para id="x_460">Les contributeurs le clonent, y apportent localement
        des modifications, les testent et envoient (push) en retour leurs
        changements.</para>

      <para id="x_461">Une fois que la branche principale atteint une étape
        assez importante pour une release, vous pouvez utiliser la commande
        <command role="hg-cmd">hg tag</command> pour donner un nom permanent
        à cette étape de révision.</para>
    
      &interaction.branching.tag;

      <para id="x_462">Disons que du developpement continue sur la
        branche principale.</para>

      &interaction.branching.main;

      <para id="x_463">En utilisant le tag enregistré à l'étape importante,
        les gens qui clonent ce dépôt peuvent à tout moment dans le futur
        utiliser la commande <command role="hg-cmd">hg update</command> pour
        avoir une copie du répertoire de travail exactement comme il était
        lorsque cette révision "tag" a été committée.</para>

      &interaction.branching.update;

      <para id="x_464">De plus, immédiatement après que la branche principale
        soit taggée, nous pouvons maintenant cloner la branche principale sur
        le serveur vers une nouvelle branche <quote>stable</quote> sur le
        même serveur.</para>

      &interaction.branching.clone;

      <para id="x_465">Si nous avons besoin d'effectuer des modifications à
        la branche stable, nous pouvons alors cloner <emphasis>ce</emphasis>
        dépôt, effectuer nos modifications, committer, et envoyer nos
        changements en retour là bas.</para>

      &interaction.branching.stable;

      <para id="x_466">Puisque les dépôts Mercurial sont indépendants, et que
        Mercurial ne déplace pas les changements automatiquement, les
        branches stable et principale sont <emphasis>isolées</emphasis> l'une
        de l'autre. Les changements qui sont faits à la branche principale ne
        <quote>fuient</quote> pas vers la branche stable, et vice
        versa.</para>

      <para id="x_467">Nous allons souvent avoir envie que toutes nos
        correction de bugs sur la branche stable soient reportées sur la
        branche principale. Plutôt que de réécrire une correction de bug pour
        la branche principale, nous pouvons simplement récupérer (pull) et
        fusionner (merge) les changements de la branche stable vers la
        branche principal, et Mercurial se débrouillera pour rapporter ces
        corrections de bugs pour nous.</para>

      &interaction.branching.merge;

      <para id="x_468">La branche principale contiendra toujours des
        changements qui ne sont pas dans la branche stable, mais elle
        contiendra aussi les corrections de bugs de la branche stable. La
        branche stable restera non affectée par ces changements, tant qu'ils
        coulent de la branche stable vers la branche principale, et non dans
        l'autre sens.</para>
    </sect2>

    <sect2>
      <title>Feature branches</title>
<!-- TODO : Branches de fonctionnalité ? -->
      <para id="x_469">Pour de plus gros projets, une façon efficace de gérer
        les changements est de diviser l'équipe en plus petits groupes. Chaque
        groupe a une branche partagée qui lui est attitrée, clonée à partir
        d'une unique branche <quote>principale</quote> utilisée pour le
        projet entier. Les personnes travaillant sur une branche individuelle
        sont typiquement isolées des développements sur les autres
        branches.</para>

      <figure id="fig:collab:feature-branches">
        <title>Feature branches</title>
        <mediaobject>
          <imageobject><imagedata width="100%" fileref="figs/feature-branches.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject>
      </figure>

      <para id="x_46b">Lorsqu'une fonctionnalité particulière est réputée
        pour être dans une forme adaptée, quelqu'un de l'équipe qui s'en occupe
        récupère les changements (pull) à partir de
        la branche principale vers la branche de cette fonctionnalité,
        fusionne (merge) et renvoie (push) le tout vers la branche
        principale.</para>
    </sect2>

    <sect2>
      <title>Le train des releases</title>
<!-- J'ai laissé train en traduction à train mais peut être que suite, file,
... sont des mots qui conviennent mieux ? À méditer -->
<!-- Je mettrais suite -->

      <para id="x_46c">Certains projets sont organisés comme un
        <quote>train</quote> élémentaire : une release est planifiée tous les
        quelques mois, et, toutes les fonctionnalités disponibles lorsque le
        <quote>train</quote> est prêt à s'arrêter sont autorisées ici.</para>

      <para id="x_46d">Ce modèle ressemble à travailler avec des branches de
        fonctionnalités. La différence est que lorsqu'une branche de
        fonctionnalité rate le train, quelqu'un de l'équipe qui travaille sur
        cette fonctionnalité récupère (pull) et fusionne (merge) ce qui a été
        ajouté à la release du train dans la branche de la fonctionnalité,
        puis, l'équipe continue son travail au-dessus de cette release afin
        que leur fonctionnalité puisse être ajoutée à la prochaine
        release.</para>
    </sect2>

    <sect2>
      <title>Le modèle du noyau Linux</title>

      <para id="x_46e">Le développement du noyau Linux est doté d'une
        structure hiérarchique superficielle, entourée par un nuage de chaos
        apparent. Parce que la plupart des développeurs Linux utilisent
        <command>git</command>, un outil distribué de gestion de révisions
        avec des capacités similaires à celles de Mercurial, il est utile de
        décrire comment le travail se déroule dans cet environnement ; si
        vous aimez ces idées, l'approche se traduit correctement à travers
        les outils.</para>

      <para id="x_46f">Au centre de la communauté siège Linus Torvalds, le
        créateur de Linux. Il publie un dépôt unique de sources qui est
        considéré comme faisant <quote>autorité</quote> sur l'arborescence
        par la communauté entière de développeurs. Tout le monde peut cloner
        l'arbre de Linus, mais il ne récupère (pull) pas les changements de n'importe quelle arborescence.</para>

      <para id="x_470">Linus a plusieurs <quote>lieutenants de
          confiance</quote>. Comme règle générale, il récupère (pull) tous
        les changements qu'ils publient, dans la plupart des cas sans même
        relire ces modifications. Certains de ces lieutenants sont
        généralement autorisés à être <quote>mainteneurs</quote>,
        responsables pour un sous-système spécifique du noyau. Si un 
        hacker du noyau veut apporter des modification au sous-système
        qu'il veut voir intégré à l'arbre de Linus, il doit trouver 
        le mainteneur du sous-système, et lui demander de récupérer ses
        changements. Si le mainteneur relit ses changements et les accepte,
        ils seront transmis à Linus le moment venu.</para>

      <para id="x_471">Les lieutenants individuels ont leur propre approche
        pour relire, accepter et publier les changements ; et pour décider
        quand les apporter à Linus. De plus, il y a plusieurs branches
        connues que les personnes utilisent pour différentes choses.
        Par exemple, quelques personnes maintiennent des dépôts
        <quote>stables</quote> de leurs versions du noyau, pour lesquels ils
        apportent des corrections critiques lorsque nécessaire. Certains
        mainteneurs publient plusieurs arbres : l'un pour les changements
        expérimentaux, l'un pour les changements qu'ils vont faire remonter,
        etc. D'autres ne publient qu'un unique arbre.</para>

      <para id="x_472">Ce modèle a deux caractéristiques remarquables. La
        première est qu'il s'agit de <quote>pull seulement</quote>. Vous
        devez demander, convaincre, ou mendier auprès d'un autre développeur
        pour prendre vos modifications, puisqu'il n'y a vraisemblablement pas
        d'arbre où plus d'une personne peut envoyer des changements (push), et
        qu'il n'y a pas de possibilité d'envoyer des changements (push) vers
        un arbre que quelqu'un d'autre contrôle.</para>

      <para id="x_473">La seconde est que c'est basé sur la réputation et
        l'acclamation. Si vous êtes un inconnu, Linus va probablement ignorer
        vos changements sans même répondre. Cependant, un mainteneur de
        sous-système les relira probablement, et les acceptera sûrement s'ils
        passent ses critères d'acceptation. Plus vous enverrez du
        <quote>bon</quote> code à un mainteneur, et plus celui-ci aura
        confiance en votre jugement et acceptera vos changements. Si vous
        êtes bien connu et maintenez une branche ancienne pour quelque chose
        que Linus n'a pas encore accepté, les gens avec un intérêt similaire
        devraient récupérer vos changements régulièrement pour rester à jour
        vis-à-vis de votre travail.</para>

      <para id="x_474">La réputation et l'acclamation ne nécessite pas de
        système croisé ou de limites <quote>entre les gens</quote>. Si vous
        êtes respectés mais que vous êtes un hacker spécialisé dans la
        sauvegarde, et que vous tentez de corriger un bug réseau, ce
        changement recevra un examen approfondi de la part du mainteneur
        responsable du réseau comparable à celui d'un total étranger.</para>

      <para id="x_475">Pour les personnes qui viennent d'un projet dont
        le milieu est plus ordonné, le processus chaotique de
        développement du noyau Linux en comparaison apparaît souvent totalement
        dément. C'est sujet aux caprices d'individus ;
        des personnes font des changements considérables quand ils les
        jugent appropriés ; et l'allure du développement est
        ahurissante. Et pourtant, Linux est un bout de logiciel d'une grande
        réussite et bien considéré.</para>
    </sect2>

    <sect2>
      <title>Collaboration pull seulement versus pull partagé</title>

      <para id="x_476">Une source perpétuelle de heurts dans la communauté
        opensource est de savoir si un modèle de développement où les
        personnes ne peuvent que récupérer (pull) les changements d'autres est
        <quote>meilleur</quote> que celui dans lequel de multiples personnes peuvent
        envoyer (push) leurs changements vers un dépôt partagé.</para>

      <para id="x_477">Typiquement, les partisans du modèle push
        partagé utilisent des outils qui renforcent activement cette
        approche. Si vous utilisez un outil centralisé de gestion de révision
        comme Subversion, il n'y a pas la possibilité de choisir quel modèle
        utiliser : l'outil vous fournit un push partagé, et si vous voulez
        faire quelque chose d'autre, vous avez à changer votre propre
        approche à la base (comme appliquer les patchs manuellement).</para>

      <para id="x_478">Un bon outil de gestion distribuée de révisions doit
        supporter les deux modèles. Vous et vos collaborateurs pouvez ensuite
        structurer la façon dont vous travaillez ensemble en vous basant sur
        vos besoins et vos préférences, et non sur les contorsions que vos
        outils vous forcent à effectuer.</para>
    </sect2>
    <sect2>
      <title>Lorsque la collaboration rencontre la gestion de branches</title>

      <para id="x_479">Lorsque vous et votre équipe configurez des dépôts
        partagés et commencez à propager vos changement dans tous les sens
        entre les dépôts locaux et partagés, vous commencez à être face à un
        défi connexe, mais un peu différent : celui de gérer les
        multiples directions vers lesquelles votre équipe pourrait aller au
        même moment. Même si ce sujet est intimement lié à la façon dont
        votre équipe collabore, il est suffisement dense pour mériter un
        traitement à part dans <xref linkend="chap:branch"/>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Le côté technique du partage</title>

    <para id="x_47a">Le reste de ce chapitre est consacré à la question du
      partage des changements avec vos collaborateurs.</para>
  </sect1>

  <sect1 id="sec:collab:serve">
    <title>Partage informel avec <command role="hg-cmd">hg
    serve</command></title>

    <para id="x_47b">La commande <command role="hg-cmd">hg serve</command> de
      Mercurial est magnifiquement conçue pour un environnement de petit
      groupe, soudé et rapide. Elle fournit aussi un très bon moyen d'avoir
      un sentiment de l'utilisation des commandes Meruciral sur un
      réseau.</para>

    <para id="x_47c">Exécutez <command role="hg-cmd">hg serve</command> à
      l'intérieur d'un dépôt et en moins d'une seconde, cela mettra en place
      un serveur HTTP spécialisé ; qui va accepter les connexions de tout
      client, et servir les données pour ce dépôt jusqu'à ce que vous 
      l'arrêtiez. Toute personne qui connaît l'URL du serveur que vous venez
      de démarrer, peut ensuite utiliser un navigateur web ou Mercurial pour
      lire les données de ce dépôt. Une URL pour une instance exécutée de 
      <command role="hg-cmd">hg serve</command> sur un ordinateur portable
      ressemblera vraisemblablement à
      <literal>http://my-laptop.local:8000/</literal>.</para>

    <para id="x_47d">La commande <command role="hg-cmd">hg serve</command>
      <emphasis>n'</emphasis>est <emphasis>pas</emphasis> un serveur web
      générique. Il ne peut faire que deux choses : </para>
    <itemizedlist>
      <listitem><para id="x_47e">Autoriser les personnes à explorer
          l'historique du dépôt qu'il rend accessible, à partir d'un
          navigateur web normal.</para>
      </listitem>
      <listitem><para id="x_47f">Discuter à travers le protocole de
          communication de Mercurial, ainsi, les personnes peuvent exécuter <command
            role="hg-cmd">hg clone</command> ou <command role="hg-cmd">hg
            pull</command> sur les changements de ce dépôt.</para>
      </listitem></itemizedlist>
    <para id="x_480">En particulier, <command role="hg-cmd">hg serve</command>
      ne permettra pas aux utilisateurs distants de
      <emphasis>modifier</emphasis> votre dépôt. C'est destiné à une
      utilisation en lecture seule.</para>

    <para id="x_481">Si vous commencez avec Mercurial, il n'y a rien qui vous
      empêche d'utiliser <command role="hg-cmd">hg serve</command> pour
      publier un dépôt sur votre ordinateur, utilisez ensuite des commandes
      telles que <command role="hg-cmd">hg clone</command>, <command
        role="hg-cmd">hg incoming</command>, et ainsi de suite pour parler à
      ce serveur comme si ce dépôt était hébergé à distance. Ceci peut vous
      aider à rapidement familiarisé avec les commandes sur les dépôts
      hébergés sur un réseau.</para>

    <sect2>
      <title>Quelques choses à garder à l'esprit</title>

      <para id="x_482">Puisque il fournit un accès en lecture sans
        authentification à tous les clients, vous devriez utiliser la
        commande <command role="hg-cmd">hg serve</command> dans un
        environnement où vous ne vous inquiétez pas ou vous avez
        tout contrôle sur qui peut avoir accès au réseau et récupérer les
        données de votre dépôt.</para>

      <para id="x_483">La commande <command role="hg-cmd">hg serve</command>
        ne sait rien sur un quelconque firewall que vous auriez
        installé sur votre système ou réseau. Elle ne peut pas détecter ou
        contrôler votre logiciel de pare-feu. Si d'autre personnes ont la
        possibilité de dialoguer avec une instance de <command
          role="hg-cmd">hg serve</command> la seconde chose que vous devriez
        faire (<emphasis>après</emphasis> être sûr qu'ils utilisent l'URL
        correcte) est de vérifier la configuration de votre firewall.</para>

      <para id="x_484">Par défaut, <command role="hg-cmd">hg serve</command>
        écoute pour les connexions entrantes sur le port 8000. Si un autre
        processus est déjà en train d'écouter sur le port que vous voulez
        écouter, vous pouvez spécifier un port différent sur lequel écouter à
        l'aide de l'option <option role="hg-opt-serve">-p</option>.</para>

      <para id="x_485">Normalement, lorsque <command role="hg-cmd">hg
          serve</command> se lance, il n'affiche aucune sortie, ce qui peut
        être un peu énervant. Si vous voulez une confirmation que tout s'est
        déroulé correctement, et connaître l'URL que vous devriez fournir à
        vos collaborateurs, démarrez avec l'option <option
          role="hg-opt-global">-v</option>.</para>
    </sect2>
  </sect1>

  <sect1 id="sec:collab:ssh">
    <title>Utiliser le protocole Secure Shell (ssh)</title>

    <para id="x_486">Vous pouvez récupérer (pull) ou envoyer (push) des
      changements de façon sécurisé au dessus d'une connexion utilisant le
      protocole Secure Shell (<literal>ssh</literal>). Pour l'utiliser avec
      succès, vous pourriez avoir à faire un peu de configuration du côté
      client ou serveur.</para>

    <para id="x_487">Si vous n'êtes pas familiers avec ssh, c'est le nom de
      la commande et d'un protocole réseau qui vous permet d'établir une
      communication sécurisée avec un autre ordinateur. Pour l'utiliser avec
      Mercurial, vous allez configurer un ou plusieurs comptes utilisateurs
      sur un serveur, comme ça, les utilisateurs distants peuvent se connecter et
      exécuter les commandes.</para>

    <para id="x_488">(Si vous <emphasis>êtes</emphasis> familiers avec ssh,
      vous allez probablement trouver quelques-unes des informations qui
      suivent élémentaires par nature.)</para>

    <sect2>
      <title>Comment lire et écrire des URLs ssh</title>

      <para id="x_489">Une URL ssh a tendance à ressembler à ceci :</para>
      <programlisting>ssh://bos@hg.serpentine.com:22/hg/hgbook</programlisting>
      <orderedlist>
        <listitem><para id="x_48a">Le préfixe
            <quote><literal>ssh://</literal></quote> dit à Mercurial
            d'utiliser le protocole ssh.</para>
        </listitem>
        <listitem><para id="x_48b">Le composant
            <quote><literal>bos@</literal></quote> indique que le nom
            d'utilisateur à connecter sur le serveur. Vous pouvez le laisser
            vide si le nom d'utilisateur sur le serveur distant est le même
            que localement.</para>
        </listitem>
        <listitem><para id="x_48c">La partie
            <quote><literal>hg.serpentine.com</literal></quote> donne le nom
            d'hôte du serveur sur lequel se connecter.</para>
        </listitem>
        <listitem><para id="x_48d">Le <quote>:22</quote> identifie le numéro
            de port où se connecter au serveur. Le port par défaut est 22,
            donc vous avez besoin de spécifier ceci que si vous
            <emphasis>n'</emphasis>utilisez <emphasis>pas</emphasis> le port
            22.</para>
        </listitem>
        <listitem><para id="x_48e">Le reste de l'URL est le chemin local du
            dépôt sur le serveur.</para></listitem></orderedlist>
    
      <para id="x_48f">Il y a beaucoup de risque de confusion sur le
        chemin du composant d'une URL ssh puisqu'il n'y a pas de façon
        standard pour les outils de l'interpréter. Certains programmes se
        comportent différemment des autres lorsqu'ils traitent ces chemins. Il
        ne s'agit pas d'une situation idéale, mais ce n'est pas prêt de
        changer. Lisez les prochains paragraphes avec attention.</para>

      <para id="x_490">Mercurial traite le chemin vers un dépôt sur le
        serveur comme relatif au répertoire personnel de l'utilisateur sur le
        serveur distant. Par exemple, si un utilisateur
        <literal>foo</literal> sur le serveur a un répertoire personnel
        <filename class="directory">/home/foo</filename>, alors l'URL ssh qui
        contient un composant chemin de <filename
          class="directory">bar</filename> réfère en
        <emphasis>réalité</emphasis> au répertoire <filename
          class="directory">/home/foo/bar</filename>.</para>

      <para id="x_491">Si vous voulez spécifier un chemin relatif au
        répertoire personnel d'un autre utilisateur, vous pouvez préciser un
        chemin qui commence à l'aide du caractère tilde suivi du nom de
        l'utilisateur (appelons le <literal>otheruser</literal>),
        ainsi.</para>
      <programlisting>ssh://server/~otheruser/hg/repo</programlisting>

      <para id="x_492">Et si vous voulez vraiment spécifier un chemin
        <emphasis>absolu</emphasis> sur le serveur, débutez le composant
        chemin par deux slashs comme dans cet exemple.</para>
      <programlisting>ssh://server//absolute/path</programlisting>
    </sect2>

    <sect2>
      <title>Trouver un client ssh pour votre système</title>

      <para id="x_493">La plupart des systèmes du type Unix arrivent avec
        OpenSSH préinstallé. Si vous utilisez un tel système, utilisez
        <literal>which ssh</literal> pour trouver où la commande
        <command>ssh</command> est installée (il s'agit généralement de
        <filename class="directory">/usr/bin</filename>). Dans le cas peu
        probable où il ne serait pas présent, regarder la documentation de
        votre système pour voir comment l'installer.</para>

      <para id="x_494">Sous Windows, le paquet TortoiseHg est livré avec
        une version de l'excellente commande <command>plink</command> de
        Simon Tatham, et ne devrait pas avoir besoin de plus de
        configuration.</para>
    </sect2>

    <sect2>
      <title>Créer une paire de clef</title>

      <para id="x_499">Pour éviter d'avoir à chaque fois taper un mot de
        passe lorsque vous utilisez votre client ssh, je recommande 
        de créer une paire de clefs.</para>

      <tip>
        <title>Les paires de clefs ne sont pas obligatoires</title>
      
        <para id="x_6a4">Mercurial ne sait rien du tout de l'authentification
          de ssh ou de la paire de clefs. Vous pouvez, si vous le désirez,
          ignorer sans risque cette section et la suivante jusqu'à ce que
          vous soyez fatigué de constamment retaper des mots de passe
          ssh.</para>
      </tip>

      <itemizedlist>
        <listitem> <para id="x_6a5">Sur un système de type Unix, la commande
            <command>ssh-keygen</command> fera l'affaire.</para></listitem>
        <listitem> <para id="x_6a6">Sous Windows, si vous utilisez
            TortoiseHg, vous devriez avoir besoin de télécharger la commande
            nommée <command>puttygen</command> à partir du <ulink
              url="http://www.chiark.greenend.org.uk/~sgtatham/putty">site
              web de PuTTY</ulink> pour créer une paire de clefs.  Référez-vous
               à <ulink
              url="http://the.earth.li/~sgtatham/putty/0.60/htmldoc/Chapter8.html#pubkey-puttygen">la
              documentation <command>puttygen</command></ulink> pour les
            détails sur l'utilisation de cette commande.</para></listitem>
      </itemizedlist>

      <para id="x_49a">Lorsque vous créez une paire de clefs, il est
        habituellement <emphasis>hautement</emphasis> recommandé de la
        protéger avec un mot de passe. (Le seul moment où vous pourriez ne
        pas devoir le faire est lorsque vous utilisez le protocole ssh pour
        des tâches automatisées sur un réseau sécurisé.)</para>

      <para id="x_49b">Le simple fait de créer une paire de clefs n'est
        cependant pas suffisant. Vous aurez besoin d'ajouter la clef publique
        à l'ensemble des clefs autorisées pour tout utilisateur que vous
        utilisez pour vous connecter à distance. Pour les serveurs utilisant
        OpenSSh (la grande majorité), ceci voudra dire d'ajouter la clef
        publique à la liste dans un fichier appelé <filename
          role="special">authorized_keys</filename> dans leur répertoire
        <filename role="special" class="directory">.ssh</filename>.</para>

      <para id="x_49c">Sur un système de type Unix, votre clef publique aura
        l'extension <filename>.pub</filename>. Si vous utilisez la commande
        <command>puttygen</command> sous Windows, vous pouvez sauvegarder la
        clef publique dans un fichier que vous choisissez ou la copier à
        partir de la fenêtre qui apparait directement dans le fichier
        <filename role="special">authorized_keys</filename>.</para>
    </sect2>
    <sect2>
      <title>Utiliser un agent d'authentification</title>

      <para id="x_49d">Un agent d'authentification est un démon qui
        enregistre les mots de passe en mémoire (il oublira ainsi les mots de
        passe si vous vous déconnectez et reconnectez). Un client ssh sera averti
        si un tel agent est en fonctionnement, et lui demandera un mot de
        passe. S'il n'y a pas d'agent en fonctionnement, ou si l'agent ne
        connaît pas le mot de passe nécessaire, vous aurez à taper votre mot
        de passe chaque fois que Mercurial tente de communiquer avec un
        serveur en votre nom (ex. lorsque vous faite un pull ou un push 
        de changements).</para>

      <para id="x_49e">L'inconvénient de sauvegarder les mots de passes dans
        un agent est qu'il est possible pour un attaquant bien préparé de
        retrouver le mot de passe clair, dans certains cas, même si votre
        système a été redémarré. Vous devriez vous faire votre propre
        jugement pour savoir si ce risque est acceptable. Ceci vous exempte
        certainement d'un tas de répétitions.</para>

      <itemizedlist>
        <listitem> <para id="x_49f">Sur les systèmes de type Unix, l'agent
            est appelé <command>ssh-agent</command>, et est souvent lancé
            automatiquement pour vous lorsque vous vous connectez. Vous aurez
            besoin d'utiliser la commande <command>ssh-add</command> pour
            ajouter des mots de passe à l'entrepôt de l'agent.</para>
        </listitem>
        <listitem>
          <para id="x_6a7">Sous Windows, si vous utilisez TortoiseHg, la
            commande <command>pageant</command> agit comme un agent. Comme
            avec <command>puttygen</command>, vous aurez besoin de <ulink
              url="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">télécharger
              <command>pageant</command></ulink> à partir du site web de
            PuTTY et lire <ulink
              url="http://the.earth.li/~sgtatham/putty/0.60/htmldoc/Chapter9.html#pageant">sa
              documentation</ulink>.  La commande <command>pageant</command>
            ajoute une icône à votre zone de notification (à droite de la barre
            de tâches) qui vous permettra de
            gérer les mots de passe stockés.</para></listitem>
          <!-- TODO : J'ai traduit system tray par barre des tâches, mais ne
          conaissant pas windows, je ne suis pas sûr du nom réel. A corriger
          le cas échéant ! -->
          <!-- J'ai précisé avec ce que j'ai trouvé sur Wikipedia -->
      </itemizedlist>
    </sect2>
<!-- TODO : part 2/4 -->
    <sect2>
      <title>Configuring the server side properly</title>

      <para id="x_4a0">Because ssh can be fiddly to set up if you're new to it,
	a variety of things can go wrong.  Add Mercurial
	on top, and there's plenty more scope for head-scratching.
	Most of these potential problems occur on the server side, not
	the client side.  The good news is that once you've gotten a
	configuration working, it will usually continue to work
	indefinitely.</para>

      <para id="x_4a1">Before you try using Mercurial to talk to an ssh server,
	it's best to make sure that you can use the normal
	<command>ssh</command> or <command>putty</command> command to
	talk to the server first.  If you run into problems with using
	these commands directly, Mercurial surely won't work.  Worse,
	it will obscure the underlying problem.  Any time you want to
	debug ssh-related Mercurial problems, you should drop back to
	making sure that plain ssh client commands work first,
	<emphasis>before</emphasis> you worry about whether there's a
	problem with Mercurial.</para>

      <para id="x_4a2">The first thing to be sure of on the server side is that
	you can actually log in from another machine at all.  If you
	can't use <command>ssh</command> or <command>putty</command>
	to log in, the error message you get may give you a few hints
	as to what's wrong.  The most common problems are as
	follows.</para>
      <itemizedlist>
	<listitem><para id="x_4a3">If you get a <quote>connection refused</quote>
	    error, either there isn't an SSH daemon running on the
	    server at all, or it's inaccessible due to firewall
	    configuration.</para>
	</listitem>
	<listitem><para id="x_4a4">If you get a <quote>no route to host</quote>
	    error, you either have an incorrect address for the server
	    or a seriously locked down firewall that won't admit its
	    existence at all.</para>
	</listitem>
	<listitem><para id="x_4a5">If you get a <quote>permission denied</quote>
	    error, you may have mistyped the username on the server,
	    or you could have mistyped your key's passphrase or the
	    remote user's password.</para>
	</listitem></itemizedlist>
      <para id="x_4a6">In summary, if you're having trouble talking to the
	server's ssh daemon, first make sure that one is running at
	all.  On many systems it will be installed, but disabled, by
	default.  Once you're done with this step, you should then
	check that the server's firewall is configured to allow
	incoming connections on the port the ssh daemon is listening
	on (usually 22).  Don't worry about more exotic possibilities
	for misconfiguration until you've checked these two
	first.</para>
      <para id="x_4a7">If you're using an authentication agent on the client side
	to store passphrases for your keys, you ought to be able to
	log into the server without being prompted for a passphrase or
	a password.  If you're prompted for a passphrase, there are a
	few possible culprits.</para>
      <itemizedlist>
	<listitem><para id="x_4a8">You might have forgotten to use
	    <command>ssh-add</command> or <command>pageant</command>
	    to store the passphrase.</para>
	</listitem>
	<listitem><para id="x_4a9">You might have stored the passphrase for the
	    wrong key.</para>
	</listitem></itemizedlist>
      <para id="x_4aa">If you're being prompted for the remote user's password,
	there are another few possible problems to check.</para>
      <itemizedlist>
	<listitem><para id="x_4ab">Either the user's home directory or their
	    <filename role="special" class="directory">.ssh</filename>
	    directory might have excessively liberal permissions.  As
	    a result, the ssh daemon will not trust or read their
	    <filename role="special">authorized_keys</filename> file.
	    For example, a group-writable home or <filename
	      role="special" class="directory">.ssh</filename>
	    directory will often cause this symptom.</para>
	</listitem>
	<listitem><para id="x_4ac">The user's <filename
	      role="special">authorized_keys</filename> file may have
	    a problem. If anyone other than the user owns or can write
	    to that file, the ssh daemon will not trust or read
	    it.</para>
	</listitem></itemizedlist>

      <para id="x_4ad">In the ideal world, you should be able to run the
	following command successfully, and it should print exactly
	one line of output, the current date and time.</para>
      <programlisting>ssh myserver date</programlisting>

      <para id="x_4ae">If, on your server, you have login scripts that print
	banners or other junk even when running non-interactive
	commands like this, you should fix them before you continue,
	so that they only print output if they're run interactively.
	Otherwise these banners will at least clutter up Mercurial's
	output.  Worse, they could potentially cause problems with
	running Mercurial commands remotely.  Mercurial tries to
	detect and ignore banners in non-interactive
	<command>ssh</command> sessions, but it is not foolproof.  (If
	you're editing your login scripts on your server, the usual
	way to see if a login script is running in an interactive
	shell is to check the return code from the command
	<literal>tty -s</literal>.)</para>

      <para id="x_4af">Once you've verified that plain old ssh is working with
	your server, the next step is to ensure that Mercurial runs on
	the server.  The following command should run
	successfully:</para>

      <programlisting>ssh myserver hg version</programlisting>

      <para id="x_4b0">If you see an error message instead of normal <command
	  role="hg-cmd">hg version</command> output, this is usually
	because you haven't installed Mercurial to <filename
	  class="directory">/usr/bin</filename>.  Don't worry if this
	is the case; you don't need to do that.  But you should check
	for a few possible problems.</para>
      <itemizedlist>
	<listitem><para id="x_4b1">Is Mercurial really installed on the server at
	    all?  I know this sounds trivial, but it's worth
	    checking!</para>
	</listitem>
	<listitem><para id="x_4b2">Maybe your shell's search path (usually set
	    via the <envar>PATH</envar> environment variable) is
	    simply misconfigured.</para>
	</listitem>
	<listitem><para id="x_4b3">Perhaps your <envar>PATH</envar> environment
	    variable is only being set to point to the location of the
	    <command>hg</command> executable if the login session is
	    interactive.  This can happen if you're setting the path
	    in the wrong shell login script.  See your shell's
	    documentation for details.</para>
	</listitem>
	<listitem><para id="x_4b4">The <envar>PYTHONPATH</envar> environment
	    variable may need to contain the path to the Mercurial
	    Python modules.  It might not be set at all; it could be
	    incorrect; or it may be set only if the login is
	    interactive.</para>
	</listitem></itemizedlist>

      <para id="x_4b5">If you can run <command role="hg-cmd">hg version</command>
	over an ssh connection, well done! You've got the server and
	client sorted out.  You should now be able to use Mercurial to
	access repositories hosted by that username on that server.
	If you run into problems with Mercurial and ssh at this point,
	try using the <option role="hg-opt-global">--debug</option>
	option to get a clearer picture of what's going on.</para>
    </sect2>
    <sect2>
      <title>Using compression with ssh</title>

      <para id="x_4b6">Mercurial does not compress data when it uses the ssh
	protocol, because the ssh protocol can transparently compress
	data.  However, the default behavior of ssh clients is
	<emphasis>not</emphasis> to request compression.</para>

      <para id="x_4b7">Over any network other than a fast LAN (even a wireless
	network), using compression is likely to significantly speed
	up Mercurial's network operations.  For example, over a WAN,
	someone measured compression as reducing the amount of time
	required to clone a particularly large repository from 51
	minutes to 17 minutes.</para>

      <para id="x_4b8">Both <command>ssh</command> and <command>plink</command>
	accept a <option role="cmd-opt-ssh">-C</option> option which
	turns on compression.  You can easily edit your <filename
	  role="special">~/.hgrc</filename> to enable compression for
	all of Mercurial's uses of the ssh protocol.  Here is how to
	do so for regular <command>ssh</command> on Unix-like systems,
	for example.</para>
      <programlisting>[ui]
ssh = ssh -C</programlisting>

      <para id="x_4b9">If you use <command>ssh</command> on a
	Unix-like system, you can configure it to always use
	compression when talking to your server.  To do this, edit
	your <filename role="special">.ssh/config</filename> file
	(which may not yet exist), as follows.</para>

      <programlisting>Host hg
  Compression yes
  HostName hg.example.com</programlisting>

      <para id="x_4ba">This defines a hostname alias,
	<literal>hg</literal>.  When you use that hostname on the
	<command>ssh</command> command line or in a Mercurial
	<literal>ssh</literal>-protocol URL, it will cause
	<command>ssh</command> to connect to
	<literal>hg.example.com</literal> and use compression.  This
	gives you both a shorter name to type and compression, each of
	which is a good thing in its own right.</para>
    </sect2>
  </sect1>

  <sect1 id="sec:collab:cgi">
    <title>Serving over HTTP using CGI</title>

    <para id="x_6a8">The simplest way to host one or more repositories in a
      permanent way is to use a web server and Mercurial's CGI
      support.</para>

    <para id="x_4bb">Depending on how ambitious you are, configuring Mercurial's
      CGI interface can take anything from a few moments to several
      hours.</para>

    <para id="x_4bc">We'll begin with the simplest of examples, and work our way
      towards a more complex configuration.  Even for the most basic
      case, you're almost certainly going to need to read and modify
      your web server's configuration.</para>

    <note>
      <title>High pain tolerance required</title>

      <para id="x_4bd">Configuring a web server is a complex, fiddly,
	and highly system-dependent activity.  I can't possibly give
	you instructions that will cover anything like all of the
	cases you will encounter. Please use your discretion and
	judgment in following the sections below.  Be prepared to make
	plenty of mistakes, and to spend a lot of time reading your
	server's error logs.</para>

      <para id="x_6a9">If you don't have a strong stomach for tweaking
	configurations over and over, or a compelling need to host
	your own services, you might want to try one of the public
	hosting services that I mentioned earlier.</para>
    </note>

    <sect2>
      <title>Web server configuration checklist</title>

      <para id="x_4be">Before you continue, do take a few moments to check a few
	aspects of your system's setup.</para>

      <orderedlist>
	<listitem><para id="x_4bf">Do you have a web server installed
	    at all? Mac OS X and some Linux distributions ship with
	    Apache, but many other systems may not have a web server
	    installed.</para>
	</listitem>
	<listitem><para id="x_4c0">If you have a web server installed, is it
	    actually running?  On most systems, even if one is
	    present, it will be disabled by default.</para>
	</listitem>
	<listitem><para id="x_4c1">Is your server configured to allow you to run
	    CGI programs in the directory where you plan to do so?
	    Most servers default to explicitly disabling the ability
	    to run CGI programs.</para>
	</listitem></orderedlist>

      <para id="x_4c2">If you don't have a web server installed, and don't have
	substantial experience configuring Apache, you should consider
	using the <literal>lighttpd</literal> web server instead of
	Apache.  Apache has a well-deserved reputation for baroque and
	confusing configuration. While <literal>lighttpd</literal> is
	less capable in some ways than Apache, most of these
	capabilities are not relevant to serving Mercurial
	repositories.  And <literal>lighttpd</literal> is undeniably
	<emphasis>much</emphasis> easier to get started with than
	Apache.</para>
    </sect2>

    <sect2>
      <title>Basic CGI configuration</title>

      <para id="x_4c3">On Unix-like systems, it's common for users to have a
	subdirectory named something like <filename
	  class="directory">public_html</filename> in their home
	directory, from which they can serve up web pages.  A file
	named <filename>foo</filename> in this directory will be
	accessible at a URL of the form
	<literal>http://www.example.com/username/foo</literal>.</para>

      <para id="x_4c4">To get started, find the <filename
	  role="special">hgweb.cgi</filename> script that should be
	present in your Mercurial installation.  If you can't quickly
	find a local copy on your system, simply download one from the
	master Mercurial repository at <ulink
	  url="http://www.selenic.com/repo/hg/raw-file/tip/hgweb.cgi">http://www.selenic.com/repo/hg/raw-file/tip/hgweb.cgi</ulink>.</para>

      <para id="x_4c5">You'll need to copy this script into your <filename
	  class="directory">public_html</filename> directory, and
	ensure that it's executable.</para>
      <programlisting>cp .../hgweb.cgi ~/public_html
chmod 755 ~/public_html/hgweb.cgi</programlisting>
      <para id="x_4c6">The <literal>755</literal> argument to
	<command>chmod</command> is a little more general than just
	making the script executable: it ensures that the script is
	executable by anyone, and that <quote>group</quote> and
	<quote>other</quote> write permissions are
	<emphasis>not</emphasis> set.  If you were to leave those
	write permissions enabled, Apache's <literal>suexec</literal>
	subsystem would likely refuse to execute the script.  In fact,
	<literal>suexec</literal> also insists that the
	<emphasis>directory</emphasis> in which the script resides
	must not be writable by others.</para>
      <programlisting>chmod 755 ~/public_html</programlisting>

      <sect3 id="sec:collab:wtf">
	<title>What could <emphasis>possibly</emphasis> go
	  wrong?</title>

	<para id="x_4c7">Once you've copied the CGI script into place,
	  go into a web browser, and try to open the URL
	  <literal>http://myhostname/~myuser/hgweb.cgi</literal>,
	  <emphasis>but</emphasis> brace yourself for instant failure.
	  There's a high probability that trying to visit this URL
	  will fail, and there are many possible reasons for this.  In
	  fact, you're likely to stumble over almost every one of the
	  possible errors below, so please read carefully.  The
	  following are all of the problems I ran into on a system
	  running Fedora 7, with a fresh installation of Apache, and a
	  user account that I created specially to perform this
	  exercise.</para>

	<para id="x_4c8">Your web server may have per-user directories disabled.
	  If you're using Apache, search your config file for a
	  <literal>UserDir</literal> directive.  If there's none
	  present, per-user directories will be disabled.  If one
	  exists, but its value is <literal>disabled</literal>, then
	  per-user directories will be disabled.  Otherwise, the
	  string after <literal>UserDir</literal> gives the name of
	  the subdirectory that Apache will look in under your home
	  directory, for example <filename
	    class="directory">public_html</filename>.</para>

	<para id="x_4c9">Your file access permissions may be too restrictive.
	  The web server must be able to traverse your home directory
	  and directories under your <filename
	    class="directory">public_html</filename> directory, and
	  read files under the latter too.  Here's a quick recipe to
	  help you to make your permissions more appropriate.</para>
	<programlisting>chmod 755 ~
find ~/public_html -type d -print0 | xargs -0r chmod 755
find ~/public_html -type f -print0 | xargs -0r chmod 644</programlisting>

	<para id="x_4ca">The other possibility with permissions is that you might
	  get a completely empty window when you try to load the
	  script.  In this case, it's likely that your access
	  permissions are <emphasis>too permissive</emphasis>.  Apache's
	  <literal>suexec</literal> subsystem won't execute a script
	  that's group- or world-writable, for example.</para>

	<para id="x_4cb">Your web server may be configured to disallow execution
	  of CGI programs in your per-user web directory.  Here's
	  Apache's default per-user configuration from my Fedora
	  system.</para>

	&ch06-apache-config.lst;

	<para id="x_4cc">If you find a similar-looking
	  <literal>Directory</literal> group in your Apache
	  configuration, the directive to look at inside it is
	  <literal>Options</literal>. Add <literal>ExecCGI</literal>
	  to the end of this list if it's missing, and restart the web
	  server.</para>

	<para id="x_4cd">If you find that Apache serves you the text of the CGI
	  script instead of executing it, you may need to either
	  uncomment (if already present) or add a directive like
	  this.</para>
	<programlisting>AddHandler cgi-script .cgi</programlisting>

	<para id="x_4ce">The next possibility is that you might be served with a
	  colourful Python backtrace claiming that it can't import a
	  <literal>mercurial</literal>-related module.  This is
	  actually progress!  The server is now capable of executing
	  your CGI script.  This error is only likely to occur if
	  you're running a private installation of Mercurial, instead
	  of a system-wide version.  Remember that the web server runs
	  the CGI program without any of the environment variables
	  that you take for granted in an interactive session.  If
	  this error happens to you, edit your copy of <filename
	    role="special">hgweb.cgi</filename> and follow the
	  directions inside it to correctly set your
	  <envar>PYTHONPATH</envar> environment variable.</para>

	<para id="x_4cf">Finally, you are <emphasis>certain</emphasis> to be
	  served with another colourful Python backtrace: this one
	  will complain that it can't find <filename
	    class="directory">/path/to/repository</filename>.  Edit
	  your <filename role="special">hgweb.cgi</filename> script
	  and replace the <filename
	    class="directory">/path/to/repository</filename> string
	  with the complete path to the repository you want to serve
	  up.</para>

	<para id="x_4d0">At this point, when you try to reload the page, you
	  should be presented with a nice HTML view of your
	  repository's history.  Whew!</para>
      </sect3>

      <sect3>
	<title>Configuring lighttpd</title>

	<para id="x_4d1">To be exhaustive in my experiments, I tried configuring
	  the increasingly popular <literal>lighttpd</literal> web
	  server to serve the same repository as I described with
	  Apache above.  I had already overcome all of the problems I
	  outlined with Apache, many of which are not server-specific.
	  As a result, I was fairly sure that my file and directory
	  permissions were good, and that my <filename
	    role="special">hgweb.cgi</filename> script was properly
	  edited.</para>

	<para id="x_4d2">Once I had Apache running, getting
	  <literal>lighttpd</literal> to serve the repository was a
	  snap (in other words, even if you're trying to use
	  <literal>lighttpd</literal>, you should read the Apache
	  section).  I first had to edit the
	  <literal>mod_access</literal> section of its config file to
	  enable <literal>mod_cgi</literal> and
	  <literal>mod_userdir</literal>, both of which were disabled
	  by default on my system.  I then added a few lines to the
	  end of the config file, to configure these modules.</para>
	<programlisting>userdir.path = "public_html"
cgi.assign = (".cgi" =&gt; "" )</programlisting>
	<para id="x_4d3">With this done, <literal>lighttpd</literal> ran
	  immediately for me.  If I had configured
	  <literal>lighttpd</literal> before Apache, I'd almost
	  certainly have run into many of the same system-level
	  configuration problems as I did with Apache.  However, I
	  found <literal>lighttpd</literal> to be noticeably easier to
	  configure than Apache, even though I've used Apache for over
	  a decade, and this was my first exposure to
	  <literal>lighttpd</literal>.</para>
      </sect3>
    </sect2>
<!-- TODO : part 3/4 -->
    <sect2>
      <title>Sharing multiple repositories with one CGI script</title>

      <para id="x_4d4">The <filename role="special">hgweb.cgi</filename> script
	only lets you publish a single repository, which is an
	annoying restriction.  If you want to publish more than one
	without wracking yourself with multiple copies of the same
	script, each with different names, a better choice is to use
	the <filename role="special">hgwebdir.cgi</filename>
	script.</para>

      <para id="x_4d5">The procedure to configure <filename
	  role="special">hgwebdir.cgi</filename> is only a little more
	involved than for <filename
	  role="special">hgweb.cgi</filename>.  First, you must obtain
	a copy of the script.  If you don't have one handy, you can
	download a copy from the master Mercurial repository at <ulink
	  url="http://www.selenic.com/repo/hg/raw-file/tip/hgwebdir.cgi">http://www.selenic.com/repo/hg/raw-file/tip/hgwebdir.cgi</ulink>.</para>

      <para id="x_4d6">You'll need to copy this script into your <filename
	  class="directory">public_html</filename> directory, and
	ensure that it's executable.</para>

      <programlisting>cp .../hgwebdir.cgi ~/public_html
chmod 755 ~/public_html ~/public_html/hgwebdir.cgi</programlisting>

      <para id="x_4d7">With basic configuration out of the way, try to
	visit <literal>http://myhostname/~myuser/hgwebdir.cgi</literal>
	in your	browser.  It should
	display an empty list of repositories.  If you get a blank
	window or error message, try walking through the list of
	potential problems in <xref
	  linkend="sec:collab:wtf"/>.</para>

      <para id="x_4d8">The <filename role="special">hgwebdir.cgi</filename>
	script relies on an external configuration file.  By default,
	it searches for a file named <filename
	  role="special">hgweb.config</filename> in the same directory
	as itself.  You'll need to create this file, and make it
	world-readable.  The format of the file is similar to a
	Windows <quote>ini</quote> file, as understood by Python's
	<literal>ConfigParser</literal>
	<citation>web:configparser</citation> module.</para>

      <para id="x_4d9">The easiest way to configure <filename
	  role="special">hgwebdir.cgi</filename> is with a section
	named <literal>collections</literal>.  This will automatically
	publish <emphasis>every</emphasis> repository under the
	directories you name.  The section should look like
	this:</para>
      <programlisting>[collections]
/my/root = /my/root</programlisting>
      <para id="x_4da">Mercurial interprets this by looking at the directory name
	on the <emphasis>right</emphasis> hand side of the
	<quote><literal>=</literal></quote> sign; finding repositories
	in that directory hierarchy; and using the text on the
	<emphasis>left</emphasis> to strip off matching text from the
	names it will actually list in the web interface.  The
	remaining component of a path after this stripping has
	occurred is called a <quote>virtual path</quote>.</para>

      <para id="x_4db">Given the example above, if we have a
	repository whose local path is <filename
	  class="directory">/my/root/this/repo</filename>, the CGI
	script will strip the leading <filename
	  class="directory">/my/root</filename> from the name, and
	publish the repository with a virtual path of <filename
	  class="directory">this/repo</filename>.  If the base URL for
	our CGI script is
	<literal>http://myhostname/~myuser/hgwebdir.cgi</literal>, the
	complete URL for that repository will be
	<literal>http://myhostname/~myuser/hgwebdir.cgi/this/repo</literal>.</para>

      <para id="x_4dc">If we replace <filename
	  class="directory">/my/root</filename> on the left hand side
	of this example with <filename
	  class="directory">/my</filename>, then <filename
	  role="special">hgwebdir.cgi</filename> will only strip off
	<filename class="directory">/my</filename> from the repository
	name, and will give us a virtual path of <filename
	  class="directory">root/this/repo</filename> instead of
	<filename class="directory">this/repo</filename>.</para>

      <para id="x_4dd">The <filename role="special">hgwebdir.cgi</filename>
	script will recursively search each directory listed in the
	<literal>collections</literal> section of its configuration
	file, but it will <literal>not</literal> recurse into the
	repositories it finds.</para>

      <para id="x_4de">The <literal>collections</literal> mechanism makes it easy
	to publish many repositories in a <quote>fire and
	  forget</quote> manner.  You only need to set up the CGI
	script and configuration file one time.  Afterwards, you can
	publish or unpublish a repository at any time by simply moving
	it into, or out of, the directory hierarchy in which you've
	configured <filename role="special">hgwebdir.cgi</filename> to
	look.</para>

      <sect3>
	<title>Explicitly specifying which repositories to
	  publish</title>

	<para id="x_4df">In addition to the <literal>collections</literal>
	  mechanism, the <filename
	    role="special">hgwebdir.cgi</filename> script allows you
	  to publish a specific list of repositories.  To do so,
	  create a <literal>paths</literal> section, with contents of
	  the following form.</para>
	<programlisting>[paths]
repo1 = /my/path/to/some/repo
repo2 = /some/path/to/another</programlisting>
	<para id="x_4e0">In this case, the virtual path (the component that will
	  appear in a URL) is on the left hand side of each
	  definition, while the path to the repository is on the
	  right.  Notice that there does not need to be any
	  relationship between the virtual path you choose and the
	  location of a repository in your filesystem.</para>

	<para id="x_4e1">If you wish, you can use both the
	  <literal>collections</literal> and <literal>paths</literal>
	  mechanisms simultaneously in a single configuration
	  file.</para>

	<note>
	  <title>Beware duplicate virtual paths</title>

	  <para id="x_4e2">  If several repositories have the same
	    virtual path, <filename
	      role="special">hgwebdir.cgi</filename> will not report
	    an error.  Instead, it will behave unpredictably.</para>
	</note>
      </sect3>
    </sect2>

    <sect2>
      <title>Downloading source archives</title>

      <para id="x_4e3">Mercurial's web interface lets users download an archive
	of any revision.  This archive will contain a snapshot of the
	working directory as of that revision, but it will not contain
	a copy of the repository data.</para>

      <para id="x_4e4">By default, this feature is not enabled.  To enable it,
	you'll need to add an <envar
	  role="rc-item-web">allow_archive</envar> item to the
	<literal role="rc-web">web</literal> section of your <filename
	  role="special">~/.hgrc</filename>; see below for details.</para>
    </sect2>
    <sect2>
      <title>Web configuration options</title>

      <para id="x_4e5">Mercurial's web interfaces (the <command role="hg-cmd">hg
	  serve</command> command, and the <filename
	  role="special">hgweb.cgi</filename> and <filename
	  role="special">hgwebdir.cgi</filename> scripts) have a
	number of configuration options that you can set.  These
	belong in a section named <literal
	  role="rc-web">web</literal>.</para>
      <itemizedlist>
	<listitem><para id="x_4e6"><envar
	      role="rc-item-web">allow_archive</envar>: Determines
	    which (if any) archive download mechanisms Mercurial
	    supports.  If you enable this feature, users of the web
	    interface will be able to download an archive of whatever
	    revision of a repository they are viewing. To enable the
	    archive feature, this item must take the form of a
	    sequence of words drawn from the list below.</para>
	  <itemizedlist>
	    <listitem><para id="x_4e7"><literal>bz2</literal>: A
		<command>tar</command> archive, compressed using
		<literal>bzip2</literal> compression.  This has the
		best compression ratio, but uses the most CPU time on
		the server.</para>
	    </listitem>
	    <listitem><para id="x_4e8"><literal>gz</literal>: A
		<command>tar</command> archive, compressed using
		<literal>gzip</literal> compression.</para>
	    </listitem>
	    <listitem><para id="x_4e9"><literal>zip</literal>: A
		<command>zip</command> archive, compressed using LZW
		compression.  This format has the worst compression
		ratio, but is widely used in the Windows world.</para>
	    </listitem>
	  </itemizedlist>
	  <para id="x_4ea">  If you provide an empty list, or don't have an
	    <envar role="rc-item-web">allow_archive</envar> entry at
	    all, this feature will be disabled.  Here is an example of
	    how to enable all three supported formats.</para>
	  <programlisting>[web]
allow_archive = bz2 gz zip</programlisting>
	</listitem>
	<listitem><para id="x_4eb"><envar role="rc-item-web">allowpull</envar>:
	    Boolean.  Determines whether the web interface allows
	    remote users to <command role="hg-cmd">hg pull</command>
	    and <command role="hg-cmd">hg clone</command> this
	    repository over HTTP.  If set to <literal>no</literal> or
	    <literal>false</literal>, only the
	    <quote>human-oriented</quote> portion of the web interface
	    is available.</para>
	</listitem>
	<listitem><para id="x_4ec"><envar role="rc-item-web">contact</envar>:
	    String.  A free-form (but preferably brief) string
	    identifying the person or group in charge of the
	    repository.  This often contains the name and email
	    address of a person or mailing list.  It often makes sense
	    to place this entry in a repository's own <filename
	      role="special">.hg/hgrc</filename> file, but it can make
	    sense to use in a global <filename
	      role="special">~/.hgrc</filename> if every repository
	    has a single maintainer.</para>
	</listitem>
	<listitem><para id="x_4ed"><envar role="rc-item-web">maxchanges</envar>:
	    Integer.  The default maximum number of changesets to
	    display in a single page of output.</para>
	</listitem>
	<listitem><para id="x_4ee"><envar role="rc-item-web">maxfiles</envar>:
	    Integer.  The default maximum number of modified files to
	    display in a single page of output.</para>
	</listitem>
	<listitem><para id="x_4ef"><envar role="rc-item-web">stripes</envar>:
	    Integer.  If the web interface displays alternating
	    <quote>stripes</quote> to make it easier to visually align
	    rows when you are looking at a table, this number controls
	    the number of rows in each stripe.</para>
	</listitem>
	<listitem><para id="x_4f0"><envar
	      role="rc-item-web">style</envar>: Controls the template
	    Mercurial uses to display the web interface.  Mercurial
	    ships with several web templates.</para>
	  <itemizedlist>
	    <listitem>
	      <para id="x_6aa"><literal>coal</literal> is monochromatic.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ab"><literal>gitweb</literal> emulates the visual
		style of git's web interface.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ac"><literal>monoblue</literal> uses solid blues and
		greys.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ad"><literal>paper</literal> is the default.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ae"><literal>spartan</literal> was the default for a
		long time.</para>
	    </listitem>
	  </itemizedlist>
	  <para id="x_6af">You can
	    also specify a custom template of your own; see 
	    <xref linkend="chap:template"/> for details. Here, you can
	    see how to enable the <literal>gitweb</literal>
	    style.</para>
	  <programlisting>[web]
style = gitweb</programlisting>
	</listitem>
	<listitem><para id="x_4f1"><envar role="rc-item-web">templates</envar>:
	    Path.  The directory in which to search for template
	    files.  By default, Mercurial searches in the directory in
	    which it was installed.</para>
	</listitem></itemizedlist>
      <para id="x_4f2">If you are using <filename
	  role="special">hgwebdir.cgi</filename>, you can place a few
	configuration items in a <literal role="rc-web">web</literal>
	section of the <filename
	  role="special">hgweb.config</filename> file instead of a
	<filename role="special">~/.hgrc</filename> file, for
	convenience.  These items are <envar
	  role="rc-item-web">motd</envar> and <envar
	  role="rc-item-web">style</envar>.</para>

      <sect3>
	<title>Options specific to an individual repository</title>

	<para id="x_4f3">A few <literal role="rc-web">web</literal> configuration
	  items ought to be placed in a repository's local <filename
	    role="special">.hg/hgrc</filename>, rather than a user's
	  or global <filename role="special">~/.hgrc</filename>.</para>
	<itemizedlist>
	  <listitem><para id="x_4f4"><envar
		role="rc-item-web">description</envar>: String.  A
	      free-form (but preferably brief) string that describes
	      the contents or purpose of the repository.</para>
	  </listitem>
	  <listitem><para id="x_4f5"><envar role="rc-item-web">name</envar>:
	      String.  The name to use for the repository in the web
	      interface.  This overrides the default name, which is
	      the last component of the repository's path.</para>
	  </listitem></itemizedlist>
      </sect3>

      <sect3>
	<title>Options specific to the <command role="hg-cmd">hg
	    serve</command> command</title>

	<para id="x_4f6">Some of the items in the <literal
	    role="rc-web">web</literal> section of a <filename
	    role="special">~/.hgrc</filename> file are only for use
	  with the <command role="hg-cmd">hg serve</command>
	  command.</para>
	<itemizedlist>
	  <listitem><para id="x_4f7"><envar role="rc-item-web">accesslog</envar>:
	      Path.  The name of a file into which to write an access
	      log.  By default, the <command role="hg-cmd">hg
		serve</command> command writes this information to
	      standard output, not to a file.  Log entries are written
	      in the standard <quote>combined</quote> file format used
	      by almost all web servers.</para>
	  </listitem>
	  <listitem><para id="x_4f8"><envar role="rc-item-web">address</envar>:
	      String.  The local address on which the server should
	      listen for incoming connections.  By default, the server
	      listens on all addresses.</para>
	  </listitem>
	  <listitem><para id="x_4f9"><envar role="rc-item-web">errorlog</envar>:
	      Path.  The name of a file into which to write an error
	      log.  By default, the <command role="hg-cmd">hg
		serve</command> command writes this information to
	      standard error, not to a file.</para>
	  </listitem>
	  <listitem><para id="x_4fa"><envar role="rc-item-web">ipv6</envar>:
	      Boolean.  Whether to use the IPv6 protocol. By default,
	      IPv6 is not used.</para>
	  </listitem>
	  <listitem><para id="x_4fb"><envar role="rc-item-web">port</envar>:
	      Integer.  The TCP port number on which the server should
	      listen.  The default port number used is 8000.</para>
	  </listitem></itemizedlist>
      </sect3>

      <sect3>
	<title>Choosing the right <filename
	    role="special">~/.hgrc</filename> file to add <literal
	    role="rc-web">web</literal> items to</title>

	<para id="x_4fc">It is important to remember that a web server like
	  Apache or <literal>lighttpd</literal> will run under a user
	  ID that is different to yours. CGI scripts run by your
	  server, such as <filename
	    role="special">hgweb.cgi</filename>, will usually also run
	  under that user ID.</para>

	<para id="x_4fd">If you add <literal role="rc-web">web</literal> items to
	  your own personal <filename role="special">~/.hgrc</filename> file, CGI scripts won't read that
	  <filename role="special">~/.hgrc</filename> file.  Those
	  settings will thus only affect the behavior of the <command
	    role="hg-cmd">hg serve</command> command when you run it.
	  To cause CGI scripts to see your settings, either create a
	  <filename role="special">~/.hgrc</filename> file in the
	  home directory of the user ID that runs your web server, or
	  add those settings to a system-wide <filename
	    role="special">hgrc</filename> file.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>System-wide configuration</title>

    <para id="x_6b0">On Unix-like systems shared by multiple users (such as a
      server to which people publish changes), it often makes sense to
      set up some global default behaviors, such as what theme to use
      in web interfaces.</para>

    <para id="x_6b1">If a file named <filename>/etc/mercurial/hgrc</filename>
      exists, Mercurial will read it at startup time and apply any
      configuration settings it finds in that file.  It will also look
      for files ending in a <literal>.rc</literal> extension in a
      directory named <filename>/etc/mercurial/hgrc.d</filename>, and
      apply any configuration settings it finds in each of those
      files.</para>

    <sect2>
      <title>Making Mercurial more trusting</title>

      <para id="x_6b2">One situation in which a global <filename>hgrc</filename>
	can be useful is if users are pulling changes owned by other
	users.  By default, Mercurial will not trust most of the
	configuration items in a <filename>.hg/hgrc</filename> file
	inside a repository that is owned by a different user. If we
	clone or pull changes from such a repository, Mercurial will
	print a warning stating that it does not trust their
	<filename>.hg/hgrc</filename>.</para>

      <para id="x_6b3">If everyone in a particular Unix group is on the same team
	and <emphasis>should</emphasis> trust each other's
	configuration settings, or we want to trust particular users,
	we can override Mercurial's skeptical defaults by creating a
	system-wide <filename>hgrc</filename> file such as the
	following:</para>

    <programlisting># Save this as e.g. /etc/mercurial/hgrc.d/trust.rc
[trusted]
# Trust all entries in any hgrc file owned by the "editors" or
# "www-data" groups.
groups = editors, www-data

# Trust entries in hgrc files owned by the following users.
users = apache, bobo
</programlisting>
    </sect2>
  </sect1>
</chapter>
<!-- TODO : part 4/4 -->
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
