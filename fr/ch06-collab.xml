<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="cha:collab">
  <?dbhtml filename="collaborating-with-other-people.html"?>
  <title>Collaborer avec d'autres personnes</title>

  <para id="x_44a">Comme tout outil complètement décentralisé, Mercurial
    n'impose pas de politique sur la façon dont les personnes devraient
    travailler ensemble. Cependant, si vous êtes nouveau dans les systèmes de
    gestion de révisions distribués, cela aide d'avoir des outils et exemples
    en tête lorsque vous réfléchissez à de possibles modèles de
    workflow.</para>
  <!--TODO : workflow peut éventuellement être traduit ici par travail -->

  <sect1>
    <title>Interface web de Mercurial</title>

    <para id="x_44b">Mercurial possède une interface web puissante qui
      propose plusieurs capacités utiles.</para>

    <para id="x_44c">Pour une utilisation intensive, l'interface web vous
      permet de naviguer dans un ou une collection de dépôt. Vous pouvez voir
      l'historique d'un dépôt, examiner chaque modification (commentaires et
      "diffs"), et voir le contenu de chaque répertoire et fichier. Vous
      pouvez même accéder à une vue de l'historique qui vous donne une vue
      graphique de la relation entre les modifications individuelles et les
      fusions (merge).</para>

    <para id="x_44d">De plus, pour la consommation humaine, l'interface web
      fournit des flux Atom et RSS des changements dans un dépôt. Ceci vous
      permet de <quote>souscrire</quote> à un dépôt en utilisant votre
      lecteur de flux favori, et être automatiquement avertis de l'activité
      dans ce dépôt aussi tôt qu'elle change. Je trouve cette fonctionnalité
      bien plus commode que le modèle qui consiste à souscrire à une mailing
      list à laquelle les avertissements sont envoyés, puisque cela demande
      aucune configuration supplémentaire de la part de la personne qui
      publie un dépôt.</para>

    <para id="x_44e">L'interface web permet aussi aux utilisateurs distants
      de cloner un dépôt, récupérer (pull) les changement à partir de celui
      ci, et (lorsque le serveur est configuré pour l'autoriser) lui envoyer
      (push) des changements. Le protocole de tunnel HTTP de Mercurial
      compresse agressivement les données, ainsi, il fonctionne efficacement,
      même au dessus des réseaux avec une bande passante faible.</para>

    <para id="x_44f">La plus simple façon de démarrer avec l'interface
      utilisateur est d'utiliser votre navigateur web pour visiter un dépôt
      existant, tel que le dépôt principal de Mercurial à l'adresse <ulink
        url="http://www.selenic.com/repo/hg">http://www.selenic.com/repo/hg</ulink>.</para>

    <para id="x_450">Si vous êtes intéressés pour proposer une interface web
      de vos propres dépôts, il y a plusieurs façons de le faire.</para>
    
    <para id="x_69d">La façon la plus simple et la plus rapide pour commencer
      dans un environnement informel est d'utiliser la commande <command
        role="hg-cmd">hg serve</command> qui est la plus adaptée à un service
      à court terme et <quote>léger</quote>. Référez vous à <xref
        linkend="sec:collab:serve"/> plus pas pour les détails d'utilisation
      de cette commande.</para>

    <para id="x_69e">Pour des dépôts dont la durée de vie est plus longue, où
      vous voudriez un service accessible en permanence, il existe plusieurs
      services publics d'hébergement qui sont accessibles. Certains sont
      libres et gratuits pour les projets Open Source, alors que d'autres
      offrent un hébergement commercial et payant. Une lise à jour est
      disponible à l'adresse : <ulink
        url="http://www.selenic.com/mercurial/wiki/index.cgi/MercurialHosting">http://www.selenic.com/mercurial/wiki/index.cgi/MercurialHosting</ulink>.</para>

    <para id="x_6a0">Si vous préférez héberger vos propres dépôts, Mercurial
      possède un support intégré pour plusieurs technologies pupulaires
      d'hébergement, plus particulièrement CGI (Common Gateway Interface) et
      WSGI (Web Services Gateway Interface). Référez vous à <xref
        linkend="sec:collab:cgi"/> pour des détails sur la configuration CGI
      et WSGI.</para>
  </sect1>

  <sect1>
    <title>Modèles de collaboration</title>

    <para id="x_451">Avec un outil convenablement flexible, faire des
      décisions sur les workflow est plus un problème d'ingénierie sociale
      qu'un problème technique. Mercurial n'impose que peu de limitations sur
      la façon dont vous pouvez structurer le flux de travail dans un projet,
      donc, c'est à vous et votre groupe de fixer et vivre avec un modèle qui
      convient à vos besoins particuliers.</para>

    <sect2>
      <title>Facteurs à garder en tête</title>

      <para id="x_452">L'aspect le plus important de tout modèle que vous
        devez garder en tête est la façon dont il subvient aux besoins et
        capacités des personnes qui l'utiliseront. Ceci pourrait sembler
        évident en soi ; pourtant, vous ne pouvez pas vous permettre de
        l'oublier à un seul moment.</para>

      <para id="x_453">Une fois, j'ai mis en place un modèle de workflow qui
        m'apparaissait comme parfait, mais il a causé la consternation et des
        conflits au sein de mon équipe de développement. En dépit de mes
        tentatives pour expliquer pourquoi nous avions besoin d'un ensemble
        complexe de branches, et comment les changements devaient couler
        entre eux, certains membres de l'équipe se révoltèrent. Alors qu'ils
        étaient pourtant des personnes sympathiques, ils ne voulaient pas
        prêter attention aux contraintes sur lesquelles nous étions en train
        d'opérer, ou, face aux conséquences de ces contraintes dans les
        détails du modèle que je préconisais.</para>

      <para id="x_454">Ne balayez pas les problèmes sociaux ou techniques de
        la main. Quelquesoit le schéma que vous promulguez, vous devriez
        plannifier un protocole pour prévenir, ou rapidement vous relever de
        troubles que vous pouvez anticiper. Par exemple, si vous vous
        attentez à avoir une branche pour les changements pas-pour-release,
        vous devriez penser très tôt sur la possibilité qu'une personne
        fusionne (merge) accidentellement ces changements avec une branche de
        release. Vous pouvez empécher ce problème particulier en écrivant un
        hook qui prévient les changements d'être fusionnés à partir d'une
        branche inapropriée.</para>
    </sect2>

    <sect2>
      <title>Anarchie informelle</title>

      <para id="x_455">Je ne voudrais pas suggérer qu'une approche
        <quote>tout peut arriver</quote> comme quelque chose de durable, mais
        il s'agit d'un modèle qui est simple à saisir et qui fonctionne
        parfaitement dans quelques situations inhabituelles.</para>

      <para id="x_456">Par exemple, beaucoup de projets ont un groupe distant
        de collaborateurs qui ne se rencontre physiquement que très rarement.
        Certains groupes aiment vaincre l'isolation du travail à distance en
        organisant occasionnellement des <quote>sprints</quote>. Dans un
        sprint, le nombre de personne qui viennent ensemble dans un même
        localité (la salle de conférence d'une companie, la salle de réunion
        d'un hotel, ce type d'endroit) et y passe plusieurs jours, plus ou
        moins enfermés, et hackant intensément sur une poignée de
        projets.</para>

      <para id="x_457">Un "sprint" ou une session de "hacking" dans un café
        sont les endroits parfaits pour utiliser la commande <command
          role="hg-cmd">hg serve</command> puisque <command role="hg-cmd">hg
          serve</command> n'a pas besoin d'une infrastructure extraordinaire
        de serveurs. Vous pouvez commencer avec la commande <command
          role="hg-cmd">hg serve</command> en un moment, en lisant <xref
          linkend="sec:collab:serve"/> plus bas  Ensuite, dites simplement à
        la personne à coté de vous que vous exécutez un serveur, envoyez lui
        l'URL par un message instantané, et vous avez immédiatement un moyen
        simple et rapide de travailler ensemble. Ils peuvent taper votre URL
        dans leur navigateur web et rapidement avoir une revue des
        changements ; ou ils peuvent récupérer chez vous un bugfix et le
        vérifier ; ou ils peuvent cloner une branche contenant une nouvelle
        fonctionnalité et la tester.</para>
        
      <para id="x_458">Le charme et le problème en faisant les choses ainsi,
        dans une mode ad-hoc est que seules les personnes qui sont au courant
        de vos changements, et de leur emplacement, peuvent les voir. Une
        telle approche informelle ne passe simplement pas à l'échelle au delà
        d'une poignée de personnes, puisque chacun a besoin de connaître
        <emphasis>n</emphasis> différents dépôts à partir des quels récupérer
        les changements (pull).</para>
    </sect2>

    <sect2>
      <title>Un simple dépôt central</title>

      <para id="x_459">Pour de plus petits projets qui migrent depuis un
        outil de gestion de révision centralisé, la façon la
        plus simple de commencer est certainement d'avoir un flux de
        changement à partir d'un unique dépôt central. Il s'agit aussi du
        <quote>bloc de construction</quote> pour des schémas de workflow plus
        ambitieux.</para>

      <para id="x_45a">Les contributeurs commencent par cloner une copie de
        ce dépôt. Ils peuvent récupérer les changements à n'importe quel
        moment où ils en ressentent le besoin, et certains (sûrement tous)
        développeurs ont les persmissions qui leur permettent d'envoyer leurs
        modifications (push) en retour lorsqu'elles sont prêtes pour que les
        autres personnes puissent les voir.</para>

      <para id="x_45b">Dans ce modèle, il peut encore être sensé pour les
        gens de récupérer les changements directement entre eux, sans passer
        par le dépôt central. Considérez le cas où j'ai une tentative de bug
        fix, mais je m'inquiète de savoir si, dans le cas où je la publiais,
        cela ne casserait pas l'arbre des autres contributeurs s'ils la
        récupèrerais. Pour réduire les dommages potentiels, je peux vous
        demander de cloner mon dépôt dans un dépôt temporaire qui vous
        appartient et de le tester. Ceci nous permet de ne pas publier les
        modification potentiellement dangereuses tant qu'elles n'ont pas
        encore été un peu testées.</para>

      <para id="x_45c">Si une équipe héberge son propre dépôt dans ce type de
        scénario, les personnes qui utilisent habituellement le protocole
        <command>ssh</command> pour envoyer (push) en toute sécurité leurs
        changements au dépôt central, comme docummenté dans <xref
          linkend="sec:collab:ssh"/>. Il est aussi usuel de publier une copie
        en lecture seule du dépôt sur HTTP comme dans <xref
          linkend="sec:collab:cgi"/>. Publier sur HTTP satisfait le besoin
        des personnes qui n'ont pas d'accès en écriture, et ceux qui veulent
        utiliser leur navigateur web pour explorer l'historique du
        dépôt.</para>
    </sect2>

    <sect2>
      <title>Un dépôt central hébergé</title>

      <para id="x_6a1">Une chose magnifique au sujet des services
        d'hébergement comme <ulink
          url="http://bitbucket.org/">Bitbucket</ulink> est qu'ils ne font
        pas seulement gérer les détails minutieux de la configuration du
        serveur, tels que les comptes utilisateur, l'authentification, les
        protocoles sécurisés, ils fournissent aussi une infrastructure
        additionnelle pour faire en sorte que ce modèle fonctionne
        bien.</para>

      <para id="x_6a2">Par exemple, un service d'hébergement bien conçu
        laissera les personnes cloner leurs copies d'un dépôt à l'aide d'un
        simple click. Ceci laisse les personnes travailler dans des espaces
        séparés et partager leurs changements lorsqu'ils sont prêts.</para>

      <para id="x_6a3">De plus, un bon service d'hébergement laissera les
        personnes communiquer ensemble, par exemple pour dire <quote>Il y a
          des changements prêts pour toi pour relecture dans cet
          arbre</quote>.</para>
        
    </sect2>

    <sect2>
      <title>Travailler avec plusieurs branches</title>

      <para id="x_45d">Les projets d'une taille significative ont tendance à
        avancer sur plusieurs fronts en même temps. Dans le cas de logiciel,
        il est commun qu'un projet sorte périodiquement des releases
        officielles. Une release devrait ensuite aller dans le <quote>mode de
          maintenance</quote> pour un moment après sa première publication ;
        les releases de maintenance tendent à contenir seulement des
        corrections de bugs, et non de nouvelles fonctionnalités. En
        parallèle de ces releases de maintenance, une ou plusieurs futures
        releases doivent être en cours de développement. Les gens utilisent
        en général le mot <quote>branche</quote> pour référer à l'une de ces
        nombreuses directions légèrement différentes dans lesquelles le
        développement évolue.</para>

      <para id="x_45e">Mercurial est particulièrement bien adapté pour gérer
        plusieurs branches simultanées mais non identiques. Chaque
        <quote>direction de développement</quote> peut vivre dans son propre
        dépôt central, et vous pouvez récupérez les changements de l'un ou
        l'autre lorsque le besoin s'en fait sentir. Parce que les dépôts sont
        indépendant les un des autres, les modifications instables dans une
        branche de développement n'affecteront jamais une branche stable,
        sauf si quelqu'un fusionne (merge) explicitement ces changements dans
        la branche stable.</para>

      <para id="x_45f">Voici un exemple sur comment cela peut se passer en
        pratique. Disons que vous avez une <quote>branche principale</quote>
        sur un serveur central.</para>

      &interaction.branching.init;

      <para id="x_460">Les contributeurs le clonent, y apportent localement
        des modifications, les testent et envoient (push) en retour leurs
        changements.</para>

      <para id="x_461">Une fois que la branche principale atteint une étape
        assez importante pour une release, vous pouvez utiliser la commande
        <command role="hg-cmd">hg tag</command> pour donner un nom permanent
        à cette étape de révision.</para>
    
      &interaction.branching.tag;

      <para id="x_462">Disons que du developpement continue a lieu sur la
        branche principale.</para>

      &interaction.branching.main;

      <para id="x_463">En utilisant le tag qui enregistre l'étape importante,
        les gens qui clonenent ce dépôt peuvent à tout moment dans le futur
        utiliser la commande <command role="hg-cmd">hg update</command> pour
        avoir une copie du répertoire de travail exactement comme il était
        lorsque cette révision "tag" a été committée.</para>

      &interaction.branching.update;

      <para id="x_464">De plus, immédiatement après que la branche principale
        soit taggée, nous pouvons maintenant cloner la branche principale sur
        le serveur vers une nouvelle branche <quote>stable</quote> sur le
        même serveur.</quote>

      &interaction.branching.clone;

      <para id="x_465">Si nous avons besoin d'effectuer des modifications à
        la branche stable, nous pouvons alors cloner <emphasis>ce</emphasis>
        dépôt, effectuer nos modifications, committer, et envoyer nos
        changements en retour là bas.</para>

      &interaction.branching.stable;

      <para id="x_466">Puisque les dépôts Mercurial sont indépendants, et que
        Mercurial ne déplace pas les changements automatiquement, les
        branches stable et principale sont <emphasis>isolées</emphasis> l'une
        de l'autre. Les changements qui sont faits à la branche principale ne
        <quote>fuient</quote> pas vers la branche stable, et vice
        versa.</para>

      <para id="x_467">Nous allons souvent avoir envie que toutes nos
        correction de bugs sur la branche stable soient reportées sur la
        branche principale. Plutôt que de réécrire une correction de bug pour
        la branche principale, nous pouvons simplement récupérer (pull) et
        fusionner (merge) les changements de la branche stable vers la
        branche principal, et Mercurial se débrouillera pour rapporter ces
        corrections de bugs pour nous.</para>

      &interaction.branching.merge;

      <para id="x_468">La branche principale contiendra toujours des
        changements qui ne sont pas dans la branche stable, mais elle
        contiendra aussi les corrections de bugs de la branche stable. La
        branche stable restera non affectée par ces changements, tant qu'ils
        coulent de la branche stable vers la branche principale, et non dans
        l'autre sens.</para>
    </sect2>

    <sect2>
      <title>Feature branches</title>

      <para id="x_469">Pour de plus gros projets, une façon efficace de gérer
        les changements est de casser l'équipe en plus pettis groupes. Chaque
        groupe a une branche partagée qui lui est attitrée, clonée à partir
        d'une unique branche <quote>principale</quote> utilisée pour le
        projet entier. Les personnes travaillant sur une branche individuelle
        sont typiquement isolées des développements sur les autres
        branches.</para>

      <figure id="fig:collab:feature-branches">
        <title>Feature branches</title>
        <mediaobject>
          <imageobject><imagedata width="100%" fileref="figs/feature-branches.png"/></imageobject>
          <textobject><phrase>XXX add text</phrase></textobject>
        </mediaobject>
      </figure>

      <para id="x_46b">Lorsqu'une fonctionnalité particulière est réputée
        pour être dans une forme adaptée, quelqu'un de l'équipe qui s'occupe
        de cette fonctionnalité récupère les changements (pull) à partir de
        la branche principale vers la branche de cette fonctionnalité,
        fusionne (merge) et renvoie (push) le tout vers la branche
        principale.</para>
    </sect2>

    <sect2>
      <title>Le train des releases</title>
<!-- J'ai laissé train en traduction à train mais peut être que suite, file,
... sont des mots qui conviennent mieux ? A méditer -->

      <para id="x_46c">Certains projets sont organisés comme un
        <quote>train</quote> basique : une release est planifiée tous les
        quelques mois, et, toutes les fonctionnalités disponibles lorsque le
        <quote>train</quote> est prêt à s'arrêter sont autorisées ici.

      <para id="x_46d">Ce modèle ressemble à travailler avec des branches de
        fonctionnalités. La différence est que lorsqu'une branche de
        fonctionnalité rate le train, quelqu'un de l'équipe qui travaille sur
        cette fonctionnalité récupère (pull) et fusionne (merge) ce qui a été
        ajouté à la release du train dans la branche de la fonctionnalité,
        puis, l'équipe continue son travail au dessus de cette release afin
        que leur fonctionnalité puisse être ajoutée à la prochaine
        release.</para>
    </sect2>

    <sect2>
      <title>Le modèle du Noyau Linux</title>

      <para id="x_46e">Le développement du noyau Linux est doté d'une
        structure hiérarchique superficielle, entourée par un nuage de chaos
        apparent. Parce que la plupart des développeurs Linux utilisent
        <command>git</command>, un outil distribué de gestion de révisions
        avec des capacités similaires à celles de Mercurial, il est utile de
        décrire comment le travail se déroule dans cet environnement ; si
        vous aimez ces idées, l'approche se traduit correctement à travers
        les outils.</para>

      <para id="x_46f">Au centre de la communauté siège Linux Torvalds, le
        créateur de Linux. Il publie un unique dépôt de sources qui est
        considéré comme faisant <quote>authorité</quote> sur l'arborescence
        par la communauté entière de développeurs. Tout le monde peut cloner
        l'arbre de Linus, mais il est très difficile d'être choisi pour que
        ses changements soient intégrés à l'arbre principal.</para>

      <para id="x_470">Linus a plusieurs <quote>leutenants de
          confiance</quote>. Comme règle générale, il récupère (pull) tous
        les changements qu'ils publient, dans la plupart des cas sans même
        relire ces modifications. Certains de ces lieutenants sont
        généralement autorisés à être <quote>mainteneurs</quote>,
        responsables pour un sous-système spécifique du noyau. Si un kernel
        hacker aléatoire veut apporter des modification au sous-système
        qu'ils veut voir intégré à l'arbre de Linus, il doit trouver qui est
        le mainteneur du sous-système, et lui demander de récupérer ses
        changements. Si le mainteneur relit ses changements et les accepte,
        ils seront transmis à Linus le moment venu.</para>

      <para id="x_471">Les lieutenants individuels ont leur propre approche
        pour relire, accepter et publier les changements ; et pour décider
        quand les apporter à Linus. De plus, il y a plusieurs branches
        connues que les personnes utilisent pour différentes choses.
        Par exemple, quelques personnes maintiennent des dépôts
        <quote>stables</quote> de leurs versions du noyau, pour lesquels ils
        apportent des corrections critiques lorsque nécessaire. Certains
        mainteneurs publient plusieurs arbres : l'un pour les changements
        expérimentaux, l'un pour les changements qu'ils vont faire remonter,
        etc. D'autres ne publient qu'un unique arbre.</para>

      <para id="x_472">Ce modèle a deux caractéristiques remarquables. La
        première est qu'il s'agit de <quote>pull seulement</quote>. Vous
        devez demander, convaincre, ou mendier au près d'un autre développeur
        pour prendre vos modifications, puiqu'il n'y a vraissemblablement pas
        d'abre où plus d'une personne peut envoyer des changement (push), et
        qu'il n'y a pas de possibilité d'envoyer des changements (push) vers
        un arbre que quelqu'un d'autre contrôle.</para>

      <para id="x_473">La seconde est que c'est basé sur la réputation et
        l'acclamation. Si vous êtes un inconnu, Linus va probablement ignorer
        vos changement sans même répondre. Cependant, un mainteneur de
        sous-système les relira probablement, et les acceptera sûrement s'ils
        passent ses critaires d'acceptation. Plus vous contriburez du
        <quote>bon</quote> code à un mainteneur, et plus celui ci aura
        confiance en votre jugement pour accepter vos changements. Si vous
        êtes bien connu et maintenez une branche ancienne pour quelque chose
        que Linus n'a pas encore accepté, les gens avec un intérêt similaire
        devraient récupérer vos changements régulièrement pour rester à jour
        vis à vis de votre travail.</para>

      <para id="x_474">La réputation et l'acclamation ne nécessite pas de
        système croisé ou de limites <quote>personnelles</quote>. Si vous
        êtes respectés mais que vous êtes un hacker spécialisé dans la
        sauvegarde, et que vous tentez de corriger un bug réseau, ce
        changement recevra un examen approfondu de la part du mainteneur
        responsable du réseau comparable à celui d'un total étranger.</para>

      <para id="x_475">Pour les personnes qui viennent d'un projet dont
        l'arrière plan est plus ordonné, le processus chaotique de
        développement du noyau Linux en comparaison apparaît totalement
        dément. C'est le sujet de bien des caprices d'individualistes ;
        des personnes qui balayent les changements même s'ils croient que
        c'est approprié ; et l'allure du développement de Linux est
        ahurissant. Et pourtant, Linux est un bout de logiciel d'une grande
        réussite et bien considéré.</para>
    </sect2>
<!-- TODO : part 1/4 -->
    <sect2>
      <title>Collaboration pull seulement versus pull partagé</title>

      <para id="x_476">A perpetual source of heat in the open source community is
	whether a development model in which people only ever pull
	changes from others is <quote>better than</quote> one in which
	multiple people can push changes to a shared
	repository.</para>

      <para id="x_477">Typically, the backers of the shared-push model use tools
	that actively enforce this approach.  If you're using a
	centralised revision control tool such as Subversion, there's
	no way to make a choice over which model you'll use: the tool
	gives you shared-push, and if you want to do anything else,
	you'll have to roll your own approach on top (such as applying
	a patch by hand).</para>

      <para id="x_478">A good distributed revision control tool will
	support both models.  You and your collaborators can then
	structure how you work together based on your own needs and
	preferences, not on what contortions your tools force you
	into.</para>
    </sect2>
    <sect2>
      <title>Where collaboration meets branch management</title>

      <para id="x_479">Once you and your team set up some shared
	repositories and start propagating changes back and forth
	between local and shared repos, you begin to face a related,
	but slightly different challenge: that of managing the
	multiple directions in which your team may be moving at once.
	Even though this subject is intimately related to how your
	team collaborates, it's dense enough to merit treatment of its
	own, in <xref linkend="chap:branch"/>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>The technical side of sharing</title>

    <para id="x_47a">The remainder of this chapter is devoted to the question of
      sharing changes with your collaborators.</para>
  </sect1>

  <sect1 id="sec:collab:serve">
    <title>Informal sharing with <command role="hg-cmd">hg
	serve</command></title>

    <para id="x_47b">Mercurial's <command role="hg-cmd">hg serve</command>
      command is wonderfully suited to small, tight-knit, and
      fast-paced group environments.  It also provides a great way to
      get a feel for using Mercurial commands over a network.</para>

    <para id="x_47c">Run <command role="hg-cmd">hg serve</command> inside a
      repository, and in under a second it will bring up a specialised
      HTTP server; this will accept connections from any client, and
      serve up data for that repository until you terminate it.
      Anyone who knows the URL of the server you just started, and can
      talk to your computer over the network, can then use a web
      browser or Mercurial to read data from that repository.  A URL
      for a <command role="hg-cmd">hg serve</command> instance running
      on a laptop is likely to look something like
      <literal>http://my-laptop.local:8000/</literal>.</para>

    <para id="x_47d">The <command role="hg-cmd">hg serve</command> command is
      <emphasis>not</emphasis> a general-purpose web server. It can do
      only two things:</para>
    <itemizedlist>
      <listitem><para id="x_47e">Allow people to browse the history of the
	  repository it's serving, from their normal web
	  browsers.</para>
      </listitem>
      <listitem><para id="x_47f">Speak Mercurial's wire protocol, so that people
	  can <command role="hg-cmd">hg clone</command> or <command
	    role="hg-cmd">hg pull</command> changes from that
	  repository.</para>
      </listitem></itemizedlist>
    <para id="x_480">In particular, <command role="hg-cmd">hg serve</command>
      won't allow remote users to <emphasis>modify</emphasis> your
      repository.  It's intended for read-only use.</para>

    <para id="x_481">If you're getting started with Mercurial, there's nothing to
      prevent you from using <command role="hg-cmd">hg serve</command>
      to serve up a repository on your own computer, then use commands
      like <command role="hg-cmd">hg clone</command>, <command
	role="hg-cmd">hg incoming</command>, and so on to talk to that
      server as if the repository was hosted remotely. This can help
      you to quickly get acquainted with using commands on
      network-hosted repositories.</para>

    <sect2>
      <title>A few things to keep in mind</title>

      <para id="x_482">Because it provides unauthenticated read access to all
	clients, you should only use <command role="hg-cmd">hg
	  serve</command> in an environment where you either don't
	care, or have complete control over, who can access your
	network and pull data from your repository.</para>

      <para id="x_483">The <command role="hg-cmd">hg serve</command> command
	knows nothing about any firewall software you might have
	installed on your system or network.  It cannot detect or
	control your firewall software.  If other people are unable to
	talk to a running <command role="hg-cmd">hg serve</command>
	instance, the second thing you should do
	(<emphasis>after</emphasis> you make sure that they're using
	the correct URL) is check your firewall configuration.</para>

      <para id="x_484">By default, <command role="hg-cmd">hg serve</command>
	listens for incoming connections on port 8000.  If another
	process is already listening on the port you want to use, you
	can specify a different port to listen on using the <option
	  role="hg-opt-serve">-p</option> option.</para>

      <para id="x_485">Normally, when <command role="hg-cmd">hg serve</command>
	starts, it prints no output, which can be a bit unnerving.  If
	you'd like to confirm that it is indeed running correctly, and
	find out what URL you should send to your collaborators, start
	it with the <option role="hg-opt-global">-v</option>
	option.</para>
    </sect2>
  </sect1>

  <sect1 id="sec:collab:ssh">
    <title>Using the Secure Shell (ssh) protocol</title>

    <para id="x_486">You can pull and push changes securely over a network
      connection using the Secure Shell (<literal>ssh</literal>)
      protocol.  To use this successfully, you may have to do a little
      bit of configuration on the client or server sides.</para>

    <para id="x_487">If you're not familiar with ssh, it's the name of
      both a command and a network protocol that let you securely
      communicate with another computer.  To use it with Mercurial,
      you'll be setting up one or more user accounts on a server so
      that remote users can log in and execute commands.</para>

    <para id="x_488">(If you <emphasis>are</emphasis> familiar with ssh, you'll
      probably find some of the material that follows to be elementary
      in nature.)</para>

    <sect2>
      <title>How to read and write ssh URLs</title>

      <para id="x_489">An ssh URL tends to look like this:</para>
      <programlisting>ssh://bos@hg.serpentine.com:22/hg/hgbook</programlisting>
      <orderedlist>
	<listitem><para id="x_48a">The <quote><literal>ssh://</literal></quote>
	    part tells Mercurial to use the ssh protocol.</para>
	</listitem>
	<listitem><para id="x_48b">The <quote><literal>bos@</literal></quote>
	    component indicates what username to log into the server
	    as.  You can leave this out if the remote username is the
	    same as your local username.</para>
	</listitem>
	<listitem><para id="x_48c">The
	    <quote><literal>hg.serpentine.com</literal></quote> gives
	    the hostname of the server to log into.</para>
	</listitem>
	<listitem><para id="x_48d">The <quote>:22</quote> identifies the port
	    number to connect to the server on.  The default port is
	    22, so you only need to specify a colon and port number if
	    you're <emphasis>not</emphasis> using port 22.</para>
	</listitem>
	<listitem><para id="x_48e">The remainder of the URL is the local path to
	    the repository on the server.</para>
	</listitem></orderedlist>

      <para id="x_48f">There's plenty of scope for confusion with the path
	component of ssh URLs, as there is no standard way for tools
	to interpret it.  Some programs behave differently than others
	when dealing with these paths. This isn't an ideal situation,
	but it's unlikely to change.  Please read the following
	paragraphs carefully.</para>

      <para id="x_490">Mercurial treats the path to a repository on the server as
	relative to the remote user's home directory.  For example, if
	user <literal>foo</literal> on the server has a home directory
	of <filename class="directory">/home/foo</filename>, then an
	ssh URL that contains a path component of <filename
	  class="directory">bar</filename> <emphasis>really</emphasis>
	refers to the directory <filename
	  class="directory">/home/foo/bar</filename>.</para>

      <para id="x_491">If you want to specify a path relative to another user's
	home directory, you can use a path that starts with a tilde
	character followed by the user's name (let's call them
	<literal>otheruser</literal>), like this.</para>
      <programlisting>ssh://server/~otheruser/hg/repo</programlisting>

      <para id="x_492">And if you really want to specify an
	<emphasis>absolute</emphasis> path on the server, begin the
	path component with two slashes, as in this example.</para>
      <programlisting>ssh://server//absolute/path</programlisting>
    </sect2>

    <sect2>
      <title>Finding an ssh client for your system</title>

      <para id="x_493">Almost every Unix-like system comes with OpenSSH
	preinstalled.  If you're using such a system, run
	<literal>which ssh</literal> to find out if the
	<command>ssh</command> command is installed (it's usually in
	<filename class="directory">/usr/bin</filename>).  In the
	unlikely event that it isn't present, take a look at your
	system documentation to figure out how to install it.</para>

      <para id="x_494">On Windows, the TortoiseHg package is bundled
	with a version of Simon Tatham's excellent
	<command>plink</command> command, and you should not need to
	do any further configuration.</para>
    </sect2>

    <sect2>
      <title>Generating a key pair</title>

      <para id="x_499">To avoid the need to repetitively type a
	password every time you need to use your ssh client, I
	recommend generating a key pair.</para>

      <tip>
	<title>Key pairs are not mandatory</title>

	<para id="x_6a4">Mercurial knows nothing about ssh authentication or key
	  pairs.  You can, if you like, safely ignore this section and
	  the one that follows until you grow tired of repeatedly
	  typing ssh passwords.</para>
      </tip>

      <itemizedlist>
	<listitem>
	  <para id="x_6a5">On a Unix-like system, the
	    <command>ssh-keygen</command> command will do the
	    trick.</para>
	  <para id="x_6a6">On Windows, if you're using TortoiseHg, you may need
	    to download a command named <command>puttygen</command>
	    from <ulink
	      url="http://www.chiark.greenend.org.uk/~sgtatham/putty">the 
	      PuTTY web site</ulink> to generate a key pair.  See
	    <ulink
	      url="http://the.earth.li/~sgtatham/putty/0.60/htmldoc/Chapter8.html#pubkey-puttygen">the 
	      <command>puttygen</command> documentation</ulink> for
	    details of how use the command.</para>
	</listitem>
      </itemizedlist>

      <para id="x_49a">When you generate a key pair, it's usually
	<emphasis>highly</emphasis> advisable to protect it with a
	passphrase.  (The only time that you might not want to do this
	is when you're using the ssh protocol for automated tasks on a
	secure network.)</para>

      <para id="x_49b">Simply generating a key pair isn't enough, however.
	You'll need to add the public key to the set of authorised
	keys for whatever user you're logging in remotely as.  For
	servers using OpenSSH (the vast majority), this will mean
	adding the public key to a list in a file called <filename
	  role="special">authorized_keys</filename> in their <filename
	  role="special" class="directory">.ssh</filename>
	directory.</para>

      <para id="x_49c">On a Unix-like system, your public key will have a
	<filename>.pub</filename> extension.  If you're using
	<command>puttygen</command> on Windows, you can save the
	public key to a file of your choosing, or paste it from the
	window it's displayed in straight into the <filename
	  role="special">authorized_keys</filename> file.</para>
    </sect2>
    <sect2>
      <title>Using an authentication agent</title>

      <para id="x_49d">An authentication agent is a daemon that stores
	passphrases in memory (so it will forget passphrases if you
	log out and log back in again). An ssh client will notice if
	it's running, and query it for a passphrase.  If there's no
	authentication agent running, or the agent doesn't store the
	necessary passphrase, you'll have to type your passphrase
	every time Mercurial tries to communicate with a server on
	your behalf (e.g. whenever you pull or push changes).</para>

      <para id="x_49e">The downside of storing passphrases in an agent is that
	it's possible for a well-prepared attacker to recover the
	plain text of your passphrases, in some cases even if your
	system has been power-cycled. You should make your own
	judgment as to whether this is an acceptable risk.  It
	certainly saves a lot of repeated typing.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_49f">On Unix-like systems, the agent is called
	    <command>ssh-agent</command>, and it's often run
	    automatically for you when you log in.  You'll need to use
	    the <command>ssh-add</command> command to add passphrases
	    to the agent's store.</para>
	</listitem>
	<listitem>
	  <para id="x_6a7">On Windows, if you're using TortoiseHg, the
	    <command>pageant</command> command acts as the agent.  As
	    with <command>puttygen</command>, you'll need to <ulink
	      url="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">download 
	      <command>pageant</command></ulink> from the PuTTY web
	    site and read <ulink
	      url="http://the.earth.li/~sgtatham/putty/0.60/htmldoc/Chapter9.html#pageant">its 
	      documentation</ulink>.  The <command>pageant</command>
	    command adds an icon to your system tray that will let you
	    manage stored passphrases.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Configuring the server side properly</title>

      <para id="x_4a0">Because ssh can be fiddly to set up if you're new to it,
	a variety of things can go wrong.  Add Mercurial
	on top, and there's plenty more scope for head-scratching.
	Most of these potential problems occur on the server side, not
	the client side.  The good news is that once you've gotten a
	configuration working, it will usually continue to work
	indefinitely.</para>

      <para id="x_4a1">Before you try using Mercurial to talk to an ssh server,
	it's best to make sure that you can use the normal
	<command>ssh</command> or <command>putty</command> command to
	talk to the server first.  If you run into problems with using
	these commands directly, Mercurial surely won't work.  Worse,
	it will obscure the underlying problem.  Any time you want to
	debug ssh-related Mercurial problems, you should drop back to
	making sure that plain ssh client commands work first,
	<emphasis>before</emphasis> you worry about whether there's a
	problem with Mercurial.</para>

      <para id="x_4a2">The first thing to be sure of on the server side is that
	you can actually log in from another machine at all.  If you
	can't use <command>ssh</command> or <command>putty</command>
	to log in, the error message you get may give you a few hints
	as to what's wrong.  The most common problems are as
	follows.</para>
      <itemizedlist>
	<listitem><para id="x_4a3">If you get a <quote>connection refused</quote>
	    error, either there isn't an SSH daemon running on the
	    server at all, or it's inaccessible due to firewall
	    configuration.</para>
	</listitem>
	<listitem><para id="x_4a4">If you get a <quote>no route to host</quote>
	    error, you either have an incorrect address for the server
	    or a seriously locked down firewall that won't admit its
	    existence at all.</para>
	</listitem>
	<listitem><para id="x_4a5">If you get a <quote>permission denied</quote>
	    error, you may have mistyped the username on the server,
	    or you could have mistyped your key's passphrase or the
	    remote user's password.</para>
	</listitem></itemizedlist>
      <para id="x_4a6">In summary, if you're having trouble talking to the
	server's ssh daemon, first make sure that one is running at
	all.  On many systems it will be installed, but disabled, by
	default.  Once you're done with this step, you should then
	check that the server's firewall is configured to allow
	incoming connections on the port the ssh daemon is listening
	on (usually 22).  Don't worry about more exotic possibilities
	for misconfiguration until you've checked these two
	first.</para>
<!-- TODO : part 2/4 -->
      <para id="x_4a7">If you're using an authentication agent on the client side
	to store passphrases for your keys, you ought to be able to
	log into the server without being prompted for a passphrase or
	a password.  If you're prompted for a passphrase, there are a
	few possible culprits.</para>
      <itemizedlist>
	<listitem><para id="x_4a8">You might have forgotten to use
	    <command>ssh-add</command> or <command>pageant</command>
	    to store the passphrase.</para>
	</listitem>
	<listitem><para id="x_4a9">You might have stored the passphrase for the
	    wrong key.</para>
	</listitem></itemizedlist>
      <para id="x_4aa">If you're being prompted for the remote user's password,
	there are another few possible problems to check.</para>
      <itemizedlist>
	<listitem><para id="x_4ab">Either the user's home directory or their
	    <filename role="special" class="directory">.ssh</filename>
	    directory might have excessively liberal permissions.  As
	    a result, the ssh daemon will not trust or read their
	    <filename role="special">authorized_keys</filename> file.
	    For example, a group-writable home or <filename
	      role="special" class="directory">.ssh</filename>
	    directory will often cause this symptom.</para>
	</listitem>
	<listitem><para id="x_4ac">The user's <filename
	      role="special">authorized_keys</filename> file may have
	    a problem. If anyone other than the user owns or can write
	    to that file, the ssh daemon will not trust or read
	    it.</para>
	</listitem></itemizedlist>

      <para id="x_4ad">In the ideal world, you should be able to run the
	following command successfully, and it should print exactly
	one line of output, the current date and time.</para>
      <programlisting>ssh myserver date</programlisting>

      <para id="x_4ae">If, on your server, you have login scripts that print
	banners or other junk even when running non-interactive
	commands like this, you should fix them before you continue,
	so that they only print output if they're run interactively.
	Otherwise these banners will at least clutter up Mercurial's
	output.  Worse, they could potentially cause problems with
	running Mercurial commands remotely.  Mercurial tries to
	detect and ignore banners in non-interactive
	<command>ssh</command> sessions, but it is not foolproof.  (If
	you're editing your login scripts on your server, the usual
	way to see if a login script is running in an interactive
	shell is to check the return code from the command
	<literal>tty -s</literal>.)</para>

      <para id="x_4af">Once you've verified that plain old ssh is working with
	your server, the next step is to ensure that Mercurial runs on
	the server.  The following command should run
	successfully:</para>

      <programlisting>ssh myserver hg version</programlisting>

      <para id="x_4b0">If you see an error message instead of normal <command
	  role="hg-cmd">hg version</command> output, this is usually
	because you haven't installed Mercurial to <filename
	  class="directory">/usr/bin</filename>.  Don't worry if this
	is the case; you don't need to do that.  But you should check
	for a few possible problems.</para>
      <itemizedlist>
	<listitem><para id="x_4b1">Is Mercurial really installed on the server at
	    all?  I know this sounds trivial, but it's worth
	    checking!</para>
	</listitem>
	<listitem><para id="x_4b2">Maybe your shell's search path (usually set
	    via the <envar>PATH</envar> environment variable) is
	    simply misconfigured.</para>
	</listitem>
	<listitem><para id="x_4b3">Perhaps your <envar>PATH</envar> environment
	    variable is only being set to point to the location of the
	    <command>hg</command> executable if the login session is
	    interactive.  This can happen if you're setting the path
	    in the wrong shell login script.  See your shell's
	    documentation for details.</para>
	</listitem>
	<listitem><para id="x_4b4">The <envar>PYTHONPATH</envar> environment
	    variable may need to contain the path to the Mercurial
	    Python modules.  It might not be set at all; it could be
	    incorrect; or it may be set only if the login is
	    interactive.</para>
	</listitem></itemizedlist>

      <para id="x_4b5">If you can run <command role="hg-cmd">hg version</command>
	over an ssh connection, well done! You've got the server and
	client sorted out.  You should now be able to use Mercurial to
	access repositories hosted by that username on that server.
	If you run into problems with Mercurial and ssh at this point,
	try using the <option role="hg-opt-global">--debug</option>
	option to get a clearer picture of what's going on.</para>
    </sect2>
    <sect2>
      <title>Using compression with ssh</title>

      <para id="x_4b6">Mercurial does not compress data when it uses the ssh
	protocol, because the ssh protocol can transparently compress
	data.  However, the default behavior of ssh clients is
	<emphasis>not</emphasis> to request compression.</para>

      <para id="x_4b7">Over any network other than a fast LAN (even a wireless
	network), using compression is likely to significantly speed
	up Mercurial's network operations.  For example, over a WAN,
	someone measured compression as reducing the amount of time
	required to clone a particularly large repository from 51
	minutes to 17 minutes.</para>

      <para id="x_4b8">Both <command>ssh</command> and <command>plink</command>
	accept a <option role="cmd-opt-ssh">-C</option> option which
	turns on compression.  You can easily edit your <filename
	  role="special">~/.hgrc</filename> to enable compression for
	all of Mercurial's uses of the ssh protocol.  Here is how to
	do so for regular <command>ssh</command> on Unix-like systems,
	for example.</para>
      <programlisting>[ui]
ssh = ssh -C</programlisting>

      <para id="x_4b9">If you use <command>ssh</command> on a
	Unix-like system, you can configure it to always use
	compression when talking to your server.  To do this, edit
	your <filename role="special">.ssh/config</filename> file
	(which may not yet exist), as follows.</para>

      <programlisting>Host hg
  Compression yes
  HostName hg.example.com</programlisting>

      <para id="x_4ba">This defines a hostname alias,
	<literal>hg</literal>.  When you use that hostname on the
	<command>ssh</command> command line or in a Mercurial
	<literal>ssh</literal>-protocol URL, it will cause
	<command>ssh</command> to connect to
	<literal>hg.example.com</literal> and use compression.  This
	gives you both a shorter name to type and compression, each of
	which is a good thing in its own right.</para>
    </sect2>
  </sect1>

  <sect1 id="sec:collab:cgi">
    <title>Serving over HTTP using CGI</title>

    <para id="x_6a8">The simplest way to host one or more repositories in a
      permanent way is to use a web server and Mercurial's CGI
      support.</para>

    <para id="x_4bb">Depending on how ambitious you are, configuring Mercurial's
      CGI interface can take anything from a few moments to several
      hours.</para>

    <para id="x_4bc">We'll begin with the simplest of examples, and work our way
      towards a more complex configuration.  Even for the most basic
      case, you're almost certainly going to need to read and modify
      your web server's configuration.</para>

    <note>
      <title>High pain tolerance required</title>

      <para id="x_4bd">Configuring a web server is a complex, fiddly,
	and highly system-dependent activity.  I can't possibly give
	you instructions that will cover anything like all of the
	cases you will encounter. Please use your discretion and
	judgment in following the sections below.  Be prepared to make
	plenty of mistakes, and to spend a lot of time reading your
	server's error logs.</para>

      <para id="x_6a9">If you don't have a strong stomach for tweaking
	configurations over and over, or a compelling need to host
	your own services, you might want to try one of the public
	hosting services that I mentioned earlier.</para>
    </note>

    <sect2>
      <title>Web server configuration checklist</title>

      <para id="x_4be">Before you continue, do take a few moments to check a few
	aspects of your system's setup.</para>

      <orderedlist>
	<listitem><para id="x_4bf">Do you have a web server installed
	    at all? Mac OS X and some Linux distributions ship with
	    Apache, but many other systems may not have a web server
	    installed.</para>
	</listitem>
	<listitem><para id="x_4c0">If you have a web server installed, is it
	    actually running?  On most systems, even if one is
	    present, it will be disabled by default.</para>
	</listitem>
	<listitem><para id="x_4c1">Is your server configured to allow you to run
	    CGI programs in the directory where you plan to do so?
	    Most servers default to explicitly disabling the ability
	    to run CGI programs.</para>
	</listitem></orderedlist>

      <para id="x_4c2">If you don't have a web server installed, and don't have
	substantial experience configuring Apache, you should consider
	using the <literal>lighttpd</literal> web server instead of
	Apache.  Apache has a well-deserved reputation for baroque and
	confusing configuration. While <literal>lighttpd</literal> is
	less capable in some ways than Apache, most of these
	capabilities are not relevant to serving Mercurial
	repositories.  And <literal>lighttpd</literal> is undeniably
	<emphasis>much</emphasis> easier to get started with than
	Apache.</para>
    </sect2>

    <sect2>
      <title>Basic CGI configuration</title>

      <para id="x_4c3">On Unix-like systems, it's common for users to have a
	subdirectory named something like <filename
	  class="directory">public_html</filename> in their home
	directory, from which they can serve up web pages.  A file
	named <filename>foo</filename> in this directory will be
	accessible at a URL of the form
	<literal>http://www.example.com/username/foo</literal>.</para>

      <para id="x_4c4">To get started, find the <filename
	  role="special">hgweb.cgi</filename> script that should be
	present in your Mercurial installation.  If you can't quickly
	find a local copy on your system, simply download one from the
	master Mercurial repository at <ulink
	  url="http://www.selenic.com/repo/hg/raw-file/tip/hgweb.cgi">http://www.selenic.com/repo/hg/raw-file/tip/hgweb.cgi</ulink>.</para>

      <para id="x_4c5">You'll need to copy this script into your <filename
	  class="directory">public_html</filename> directory, and
	ensure that it's executable.</para>
      <programlisting>cp .../hgweb.cgi ~/public_html
chmod 755 ~/public_html/hgweb.cgi</programlisting>
      <para id="x_4c6">The <literal>755</literal> argument to
	<command>chmod</command> is a little more general than just
	making the script executable: it ensures that the script is
	executable by anyone, and that <quote>group</quote> and
	<quote>other</quote> write permissions are
	<emphasis>not</emphasis> set.  If you were to leave those
	write permissions enabled, Apache's <literal>suexec</literal>
	subsystem would likely refuse to execute the script.  In fact,
	<literal>suexec</literal> also insists that the
	<emphasis>directory</emphasis> in which the script resides
	must not be writable by others.</para>
      <programlisting>chmod 755 ~/public_html</programlisting>

      <sect3 id="sec:collab:wtf">
	<title>What could <emphasis>possibly</emphasis> go
	  wrong?</title>

	<para id="x_4c7">Once you've copied the CGI script into place,
	  go into a web browser, and try to open the URL
	  <literal>http://myhostname/~myuser/hgweb.cgi</literal>,
	  <emphasis>but</emphasis> brace yourself for instant failure.
	  There's a high probability that trying to visit this URL
	  will fail, and there are many possible reasons for this.  In
	  fact, you're likely to stumble over almost every one of the
	  possible errors below, so please read carefully.  The
	  following are all of the problems I ran into on a system
	  running Fedora 7, with a fresh installation of Apache, and a
	  user account that I created specially to perform this
	  exercise.</para>

	<para id="x_4c8">Your web server may have per-user directories disabled.
	  If you're using Apache, search your config file for a
	  <literal>UserDir</literal> directive.  If there's none
	  present, per-user directories will be disabled.  If one
	  exists, but its value is <literal>disabled</literal>, then
	  per-user directories will be disabled.  Otherwise, the
	  string after <literal>UserDir</literal> gives the name of
	  the subdirectory that Apache will look in under your home
	  directory, for example <filename
	    class="directory">public_html</filename>.</para>

	<para id="x_4c9">Your file access permissions may be too restrictive.
	  The web server must be able to traverse your home directory
	  and directories under your <filename
	    class="directory">public_html</filename> directory, and
	  read files under the latter too.  Here's a quick recipe to
	  help you to make your permissions more appropriate.</para>
	<programlisting>chmod 755 ~
find ~/public_html -type d -print0 | xargs -0r chmod 755
find ~/public_html -type f -print0 | xargs -0r chmod 644</programlisting>

	<para id="x_4ca">The other possibility with permissions is that you might
	  get a completely empty window when you try to load the
	  script.  In this case, it's likely that your access
	  permissions are <emphasis>too permissive</emphasis>.  Apache's
	  <literal>suexec</literal> subsystem won't execute a script
	  that's group- or world-writable, for example.</para>

	<para id="x_4cb">Your web server may be configured to disallow execution
	  of CGI programs in your per-user web directory.  Here's
	  Apache's default per-user configuration from my Fedora
	  system.</para>

	&ch06-apache-config.lst;

	<para id="x_4cc">If you find a similar-looking
	  <literal>Directory</literal> group in your Apache
	  configuration, the directive to look at inside it is
	  <literal>Options</literal>. Add <literal>ExecCGI</literal>
	  to the end of this list if it's missing, and restart the web
	  server.</para>

	<para id="x_4cd">If you find that Apache serves you the text of the CGI
	  script instead of executing it, you may need to either
	  uncomment (if already present) or add a directive like
	  this.</para>
	<programlisting>AddHandler cgi-script .cgi</programlisting>

	<para id="x_4ce">The next possibility is that you might be served with a
	  colourful Python backtrace claiming that it can't import a
	  <literal>mercurial</literal>-related module.  This is
	  actually progress!  The server is now capable of executing
	  your CGI script.  This error is only likely to occur if
	  you're running a private installation of Mercurial, instead
	  of a system-wide version.  Remember that the web server runs
	  the CGI program without any of the environment variables
	  that you take for granted in an interactive session.  If
	  this error happens to you, edit your copy of <filename
	    role="special">hgweb.cgi</filename> and follow the
	  directions inside it to correctly set your
	  <envar>PYTHONPATH</envar> environment variable.</para>

	<para id="x_4cf">Finally, you are <emphasis>certain</emphasis> to be
	  served with another colourful Python backtrace: this one
	  will complain that it can't find <filename
	    class="directory">/path/to/repository</filename>.  Edit
	  your <filename role="special">hgweb.cgi</filename> script
	  and replace the <filename
	    class="directory">/path/to/repository</filename> string
	  with the complete path to the repository you want to serve
	  up.</para>

	<para id="x_4d0">At this point, when you try to reload the page, you
	  should be presented with a nice HTML view of your
	  repository's history.  Whew!</para>
      </sect3>

      <sect3>
	<title>Configuring lighttpd</title>

	<para id="x_4d1">To be exhaustive in my experiments, I tried configuring
	  the increasingly popular <literal>lighttpd</literal> web
	  server to serve the same repository as I described with
	  Apache above.  I had already overcome all of the problems I
	  outlined with Apache, many of which are not server-specific.
	  As a result, I was fairly sure that my file and directory
	  permissions were good, and that my <filename
	    role="special">hgweb.cgi</filename> script was properly
	  edited.</para>

	<para id="x_4d2">Once I had Apache running, getting
	  <literal>lighttpd</literal> to serve the repository was a
	  snap (in other words, even if you're trying to use
	  <literal>lighttpd</literal>, you should read the Apache
	  section).  I first had to edit the
	  <literal>mod_access</literal> section of its config file to
	  enable <literal>mod_cgi</literal> and
	  <literal>mod_userdir</literal>, both of which were disabled
	  by default on my system.  I then added a few lines to the
	  end of the config file, to configure these modules.</para>
	<programlisting>userdir.path = "public_html"
cgi.assign = (".cgi" =&gt; "" )</programlisting>
	<para id="x_4d3">With this done, <literal>lighttpd</literal> ran
	  immediately for me.  If I had configured
	  <literal>lighttpd</literal> before Apache, I'd almost
	  certainly have run into many of the same system-level
	  configuration problems as I did with Apache.  However, I
	  found <literal>lighttpd</literal> to be noticeably easier to
	  configure than Apache, even though I've used Apache for over
	  a decade, and this was my first exposure to
	  <literal>lighttpd</literal>.</para>
      </sect3>
    </sect2>
<!-- TODO : part 3/4 -->
    <sect2>
      <title>Sharing multiple repositories with one CGI script</title>

      <para id="x_4d4">The <filename role="special">hgweb.cgi</filename> script
	only lets you publish a single repository, which is an
	annoying restriction.  If you want to publish more than one
	without wracking yourself with multiple copies of the same
	script, each with different names, a better choice is to use
	the <filename role="special">hgwebdir.cgi</filename>
	script.</para>

      <para id="x_4d5">The procedure to configure <filename
	  role="special">hgwebdir.cgi</filename> is only a little more
	involved than for <filename
	  role="special">hgweb.cgi</filename>.  First, you must obtain
	a copy of the script.  If you don't have one handy, you can
	download a copy from the master Mercurial repository at <ulink
	  url="http://www.selenic.com/repo/hg/raw-file/tip/hgwebdir.cgi">http://www.selenic.com/repo/hg/raw-file/tip/hgwebdir.cgi</ulink>.</para>

      <para id="x_4d6">You'll need to copy this script into your <filename
	  class="directory">public_html</filename> directory, and
	ensure that it's executable.</para>

      <programlisting>cp .../hgwebdir.cgi ~/public_html
chmod 755 ~/public_html ~/public_html/hgwebdir.cgi</programlisting>

      <para id="x_4d7">With basic configuration out of the way, try to
	visit <literal>http://myhostname/~myuser/hgwebdir.cgi</literal>
	in your	browser.  It should
	display an empty list of repositories.  If you get a blank
	window or error message, try walking through the list of
	potential problems in <xref
	  linkend="sec:collab:wtf"/>.</para>

      <para id="x_4d8">The <filename role="special">hgwebdir.cgi</filename>
	script relies on an external configuration file.  By default,
	it searches for a file named <filename
	  role="special">hgweb.config</filename> in the same directory
	as itself.  You'll need to create this file, and make it
	world-readable.  The format of the file is similar to a
	Windows <quote>ini</quote> file, as understood by Python's
	<literal>ConfigParser</literal>
	<citation>web:configparser</citation> module.</para>

      <para id="x_4d9">The easiest way to configure <filename
	  role="special">hgwebdir.cgi</filename> is with a section
	named <literal>collections</literal>.  This will automatically
	publish <emphasis>every</emphasis> repository under the
	directories you name.  The section should look like
	this:</para>
      <programlisting>[collections]
/my/root = /my/root</programlisting>
      <para id="x_4da">Mercurial interprets this by looking at the directory name
	on the <emphasis>right</emphasis> hand side of the
	<quote><literal>=</literal></quote> sign; finding repositories
	in that directory hierarchy; and using the text on the
	<emphasis>left</emphasis> to strip off matching text from the
	names it will actually list in the web interface.  The
	remaining component of a path after this stripping has
	occurred is called a <quote>virtual path</quote>.</para>

      <para id="x_4db">Given the example above, if we have a
	repository whose local path is <filename
	  class="directory">/my/root/this/repo</filename>, the CGI
	script will strip the leading <filename
	  class="directory">/my/root</filename> from the name, and
	publish the repository with a virtual path of <filename
	  class="directory">this/repo</filename>.  If the base URL for
	our CGI script is
	<literal>http://myhostname/~myuser/hgwebdir.cgi</literal>, the
	complete URL for that repository will be
	<literal>http://myhostname/~myuser/hgwebdir.cgi/this/repo</literal>.</para>

      <para id="x_4dc">If we replace <filename
	  class="directory">/my/root</filename> on the left hand side
	of this example with <filename
	  class="directory">/my</filename>, then <filename
	  role="special">hgwebdir.cgi</filename> will only strip off
	<filename class="directory">/my</filename> from the repository
	name, and will give us a virtual path of <filename
	  class="directory">root/this/repo</filename> instead of
	<filename class="directory">this/repo</filename>.</para>

      <para id="x_4dd">The <filename role="special">hgwebdir.cgi</filename>
	script will recursively search each directory listed in the
	<literal>collections</literal> section of its configuration
	file, but it will <literal>not</literal> recurse into the
	repositories it finds.</para>

      <para id="x_4de">The <literal>collections</literal> mechanism makes it easy
	to publish many repositories in a <quote>fire and
	  forget</quote> manner.  You only need to set up the CGI
	script and configuration file one time.  Afterwards, you can
	publish or unpublish a repository at any time by simply moving
	it into, or out of, the directory hierarchy in which you've
	configured <filename role="special">hgwebdir.cgi</filename> to
	look.</para>

      <sect3>
	<title>Explicitly specifying which repositories to
	  publish</title>

	<para id="x_4df">In addition to the <literal>collections</literal>
	  mechanism, the <filename
	    role="special">hgwebdir.cgi</filename> script allows you
	  to publish a specific list of repositories.  To do so,
	  create a <literal>paths</literal> section, with contents of
	  the following form.</para>
	<programlisting>[paths]
repo1 = /my/path/to/some/repo
repo2 = /some/path/to/another</programlisting>
	<para id="x_4e0">In this case, the virtual path (the component that will
	  appear in a URL) is on the left hand side of each
	  definition, while the path to the repository is on the
	  right.  Notice that there does not need to be any
	  relationship between the virtual path you choose and the
	  location of a repository in your filesystem.</para>

	<para id="x_4e1">If you wish, you can use both the
	  <literal>collections</literal> and <literal>paths</literal>
	  mechanisms simultaneously in a single configuration
	  file.</para>

	<note>
	  <title>Beware duplicate virtual paths</title>

	  <para id="x_4e2">  If several repositories have the same
	    virtual path, <filename
	      role="special">hgwebdir.cgi</filename> will not report
	    an error.  Instead, it will behave unpredictably.</para>
	</note>
      </sect3>
    </sect2>

    <sect2>
      <title>Downloading source archives</title>

      <para id="x_4e3">Mercurial's web interface lets users download an archive
	of any revision.  This archive will contain a snapshot of the
	working directory as of that revision, but it will not contain
	a copy of the repository data.</para>

      <para id="x_4e4">By default, this feature is not enabled.  To enable it,
	you'll need to add an <envar
	  role="rc-item-web">allow_archive</envar> item to the
	<literal role="rc-web">web</literal> section of your <filename
	  role="special">~/.hgrc</filename>; see below for details.</para>
    </sect2>
    <sect2>
      <title>Web configuration options</title>

      <para id="x_4e5">Mercurial's web interfaces (the <command role="hg-cmd">hg
	  serve</command> command, and the <filename
	  role="special">hgweb.cgi</filename> and <filename
	  role="special">hgwebdir.cgi</filename> scripts) have a
	number of configuration options that you can set.  These
	belong in a section named <literal
	  role="rc-web">web</literal>.</para>
      <itemizedlist>
	<listitem><para id="x_4e6"><envar
	      role="rc-item-web">allow_archive</envar>: Determines
	    which (if any) archive download mechanisms Mercurial
	    supports.  If you enable this feature, users of the web
	    interface will be able to download an archive of whatever
	    revision of a repository they are viewing. To enable the
	    archive feature, this item must take the form of a
	    sequence of words drawn from the list below.</para>
	  <itemizedlist>
	    <listitem><para id="x_4e7"><literal>bz2</literal>: A
		<command>tar</command> archive, compressed using
		<literal>bzip2</literal> compression.  This has the
		best compression ratio, but uses the most CPU time on
		the server.</para>
	    </listitem>
	    <listitem><para id="x_4e8"><literal>gz</literal>: A
		<command>tar</command> archive, compressed using
		<literal>gzip</literal> compression.</para>
	    </listitem>
	    <listitem><para id="x_4e9"><literal>zip</literal>: A
		<command>zip</command> archive, compressed using LZW
		compression.  This format has the worst compression
		ratio, but is widely used in the Windows world.</para>
	    </listitem>
	  </itemizedlist>
	  <para id="x_4ea">  If you provide an empty list, or don't have an
	    <envar role="rc-item-web">allow_archive</envar> entry at
	    all, this feature will be disabled.  Here is an example of
	    how to enable all three supported formats.</para>
	  <programlisting>[web]
allow_archive = bz2 gz zip</programlisting>
	</listitem>
	<listitem><para id="x_4eb"><envar role="rc-item-web">allowpull</envar>:
	    Boolean.  Determines whether the web interface allows
	    remote users to <command role="hg-cmd">hg pull</command>
	    and <command role="hg-cmd">hg clone</command> this
	    repository over HTTP.  If set to <literal>no</literal> or
	    <literal>false</literal>, only the
	    <quote>human-oriented</quote> portion of the web interface
	    is available.</para>
	</listitem>
	<listitem><para id="x_4ec"><envar role="rc-item-web">contact</envar>:
	    String.  A free-form (but preferably brief) string
	    identifying the person or group in charge of the
	    repository.  This often contains the name and email
	    address of a person or mailing list.  It often makes sense
	    to place this entry in a repository's own <filename
	      role="special">.hg/hgrc</filename> file, but it can make
	    sense to use in a global <filename
	      role="special">~/.hgrc</filename> if every repository
	    has a single maintainer.</para>
	</listitem>
	<listitem><para id="x_4ed"><envar role="rc-item-web">maxchanges</envar>:
	    Integer.  The default maximum number of changesets to
	    display in a single page of output.</para>
	</listitem>
	<listitem><para id="x_4ee"><envar role="rc-item-web">maxfiles</envar>:
	    Integer.  The default maximum number of modified files to
	    display in a single page of output.</para>
	</listitem>
	<listitem><para id="x_4ef"><envar role="rc-item-web">stripes</envar>:
	    Integer.  If the web interface displays alternating
	    <quote>stripes</quote> to make it easier to visually align
	    rows when you are looking at a table, this number controls
	    the number of rows in each stripe.</para>
	</listitem>
	<listitem><para id="x_4f0"><envar
	      role="rc-item-web">style</envar>: Controls the template
	    Mercurial uses to display the web interface.  Mercurial
	    ships with several web templates.</para>
	  <itemizedlist>
	    <listitem>
	      <para id="x_6aa"><literal>coal</literal> is monochromatic.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ab"><literal>gitweb</literal> emulates the visual
		style of git's web interface.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ac"><literal>monoblue</literal> uses solid blues and
		greys.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ad"><literal>paper</literal> is the default.</para>
	    </listitem>
	    <listitem>
	      <para id="x_6ae"><literal>spartan</literal> was the default for a
		long time.</para>
	    </listitem>
	  </itemizedlist>
	  <para id="x_6af">You can
	    also specify a custom template of your own; see 
	    <xref linkend="chap:template"/> for details. Here, you can
	    see how to enable the <literal>gitweb</literal>
	    style.</para>
	  <programlisting>[web]
style = gitweb</programlisting>
	</listitem>
	<listitem><para id="x_4f1"><envar role="rc-item-web">templates</envar>:
	    Path.  The directory in which to search for template
	    files.  By default, Mercurial searches in the directory in
	    which it was installed.</para>
	</listitem></itemizedlist>
      <para id="x_4f2">If you are using <filename
	  role="special">hgwebdir.cgi</filename>, you can place a few
	configuration items in a <literal role="rc-web">web</literal>
	section of the <filename
	  role="special">hgweb.config</filename> file instead of a
	<filename role="special">~/.hgrc</filename> file, for
	convenience.  These items are <envar
	  role="rc-item-web">motd</envar> and <envar
	  role="rc-item-web">style</envar>.</para>

      <sect3>
	<title>Options specific to an individual repository</title>

	<para id="x_4f3">A few <literal role="rc-web">web</literal> configuration
	  items ought to be placed in a repository's local <filename
	    role="special">.hg/hgrc</filename>, rather than a user's
	  or global <filename role="special">~/.hgrc</filename>.</para>
	<itemizedlist>
	  <listitem><para id="x_4f4"><envar
		role="rc-item-web">description</envar>: String.  A
	      free-form (but preferably brief) string that describes
	      the contents or purpose of the repository.</para>
	  </listitem>
	  <listitem><para id="x_4f5"><envar role="rc-item-web">name</envar>:
	      String.  The name to use for the repository in the web
	      interface.  This overrides the default name, which is
	      the last component of the repository's path.</para>
	  </listitem></itemizedlist>
      </sect3>

      <sect3>
	<title>Options specific to the <command role="hg-cmd">hg
	    serve</command> command</title>

	<para id="x_4f6">Some of the items in the <literal
	    role="rc-web">web</literal> section of a <filename
	    role="special">~/.hgrc</filename> file are only for use
	  with the <command role="hg-cmd">hg serve</command>
	  command.</para>
	<itemizedlist>
	  <listitem><para id="x_4f7"><envar role="rc-item-web">accesslog</envar>:
	      Path.  The name of a file into which to write an access
	      log.  By default, the <command role="hg-cmd">hg
		serve</command> command writes this information to
	      standard output, not to a file.  Log entries are written
	      in the standard <quote>combined</quote> file format used
	      by almost all web servers.</para>
	  </listitem>
	  <listitem><para id="x_4f8"><envar role="rc-item-web">address</envar>:
	      String.  The local address on which the server should
	      listen for incoming connections.  By default, the server
	      listens on all addresses.</para>
	  </listitem>
	  <listitem><para id="x_4f9"><envar role="rc-item-web">errorlog</envar>:
	      Path.  The name of a file into which to write an error
	      log.  By default, the <command role="hg-cmd">hg
		serve</command> command writes this information to
	      standard error, not to a file.</para>
	  </listitem>
	  <listitem><para id="x_4fa"><envar role="rc-item-web">ipv6</envar>:
	      Boolean.  Whether to use the IPv6 protocol. By default,
	      IPv6 is not used.</para>
	  </listitem>
	  <listitem><para id="x_4fb"><envar role="rc-item-web">port</envar>:
	      Integer.  The TCP port number on which the server should
	      listen.  The default port number used is 8000.</para>
	  </listitem></itemizedlist>
      </sect3>

      <sect3>
	<title>Choosing the right <filename
	    role="special">~/.hgrc</filename> file to add <literal
	    role="rc-web">web</literal> items to</title>

	<para id="x_4fc">It is important to remember that a web server like
	  Apache or <literal>lighttpd</literal> will run under a user
	  ID that is different to yours. CGI scripts run by your
	  server, such as <filename
	    role="special">hgweb.cgi</filename>, will usually also run
	  under that user ID.</para>

	<para id="x_4fd">If you add <literal role="rc-web">web</literal> items to
	  your own personal <filename role="special">~/.hgrc</filename> file, CGI scripts won't read that
	  <filename role="special">~/.hgrc</filename> file.  Those
	  settings will thus only affect the behavior of the <command
	    role="hg-cmd">hg serve</command> command when you run it.
	  To cause CGI scripts to see your settings, either create a
	  <filename role="special">~/.hgrc</filename> file in the
	  home directory of the user ID that runs your web server, or
	  add those settings to a system-wide <filename
	    role="special">hgrc</filename> file.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>System-wide configuration</title>

    <para id="x_6b0">On Unix-like systems shared by multiple users (such as a
      server to which people publish changes), it often makes sense to
      set up some global default behaviors, such as what theme to use
      in web interfaces.</para>

    <para id="x_6b1">If a file named <filename>/etc/mercurial/hgrc</filename>
      exists, Mercurial will read it at startup time and apply any
      configuration settings it finds in that file.  It will also look
      for files ending in a <literal>.rc</literal> extension in a
      directory named <filename>/etc/mercurial/hgrc.d</filename>, and
      apply any configuration settings it finds in each of those
      files.</para>

    <sect2>
      <title>Making Mercurial more trusting</title>

      <para id="x_6b2">One situation in which a global <filename>hgrc</filename>
	can be useful is if users are pulling changes owned by other
	users.  By default, Mercurial will not trust most of the
	configuration items in a <filename>.hg/hgrc</filename> file
	inside a repository that is owned by a different user. If we
	clone or pull changes from such a repository, Mercurial will
	print a warning stating that it does not trust their
	<filename>.hg/hgrc</filename>.</para>

      <para id="x_6b3">If everyone in a particular Unix group is on the same team
	and <emphasis>should</emphasis> trust each other's
	configuration settings, or we want to trust particular users,
	we can override Mercurial's skeptical defaults by creating a
	system-wide <filename>hgrc</filename> file such as the
	following:</para>

    <programlisting># Save this as e.g. /etc/mercurial/hgrc.d/trust.rc
[trusted]
# Trust all entries in any hgrc file owned by the "editors" or
# "www-data" groups.
groups = editors, www-data

# Trust entries in hgrc files owned by the following users.
users = apache, bobo
</programlisting>
    </sect2>
  </sect1>
</chapter>
<!-- TODO : part 4/4 -->
<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
