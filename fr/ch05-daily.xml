<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="chap:daily">
  <?dbhtml filename="mercurial-in-daily-use.html"?>
  <title>Mercurial in daily use</title>

  <sect1>
    <title>Telling Mercurial which files to track</title>

    <para id="x_1a3">Mercurial ne fonctionne pas avec les fichiers de votre
      dépôt tant que vous ne lui avez pas dit de les gérer. La commande
      <command role="hg-cmd">hg status</command> vous dira quels fichier sont
      inconnus de Mercurial. Il utilise un
      <quote><literal>?</literal></quote> pour montrer ces fichiers.</para>

    <para id="x_1a4">Pour informer Mercurial de suivre un fichier, utilisez
      la commande <command role="hg-cmd">hg add</command>. Une fois que vous
      avez ajouté un fichier, la ligne correspondante à ce fichier dans la
      sortie de <command role="hg-cmd">hg status</command> change de
      <quote><literal>?</literal></quote> à
      <quote><literal>A</literal></quote>.</para>

    &interaction.daily.files.add;

    <para id="x_1a5">Après avoir exécuté un <command role="hg-cmd">hg
        commit</command>, les fichiers que vous avez ajouté avant le commit
      ne seront plus listé dans la sortie de <command role="hg-cmd">hg
        status</command>. La raison de ceci est que par défaut, <command
        role="hg-cmd">hg status</command> ne vous montre que les fichiers
      <quote>intéressants</quote> &emdash;ceux que vous avez (par exemple)
      modifiés, supprimés ou renommés. Si vous avez un dépôt qui contient un
      millier de fichiers, vous ne voudrez certainement que rarement entendre
      parler des fichiers que Mercurial suit, mais qui n'ont pas changés.
      (Vous pouvez quand même avoir cette information, nous y reviendrons
      plus tard.)</para>

    <para id="x_1a6">Une fois que vous ajoutez un fichier, Mercurial ne fait
      rien du tout avec celui-ci immédiatement. A lieu de ça, il va prendre
      un "snapshot" de l'état du fichier la prochaine fois que vous
      exécuterez un commit. Il continuera ensuite à suivre les changements
      que vous avez fait au fichier chaque fois que vous committerez, jusqu'à
      ce que vous supprimiez le fichier.</para>

    <sect2>
      <title>Nommage des fichiers explicite versus implicite</title>

      <para id="x_1a7">Un comportement utile que Mercurial possède est que si
        vous passez le nom d'un répertoire à une commande, toute commande
        Mercurial la traitera comme <quote>Je veux opérer sur chaque fichier
          dans ce répertoire et ses sous-répertoires</quote>.</para>

      &interaction.daily.files.add-dir;

      <para id="x_1a8">Remarquez que dans cet exemple, Mercurial affiche le
        nom des fichiers qu'il a ajouté, alors qu'il ne l'a pas fait lorsque
        nous avons ajouté le fichier nommé <filename>myfile.txt</filename>
        dans l'exemple précédent.</para>

      <para id="x_1a9">Ce qu'il se passe est que dans le premier cas, nous
        avons nommé explicitement le fichier à ajouter sur la ligne de
        commande. La supposition que Mercurial fait dans ces cas est que nous
        savons ce que nous faisons, il n'affiche dont rien en sortie.</para>

      <para id="x_1aa">Cependant, lorsque nous avons
        <emphasis>implicitement</emphasis> donné les fichiers à l'aide du nom
        d'un répertoire, Mercurial prend le l'initiative d'afficher le nom de
        chaque fichier avec lequel il fait quelque chose. Ceci clarifie ce
        qu'il se passe, et réduit la probabilité d'une surprise silencieuse
        et désagréable. Ce comportement est commun à la plupart des commandes
        Mercurial.</para>
    </sect2>
    <sect2>
      <title>Mercurial suit les fichiers, pas les répertoires</title>

      <para id="x_1ab">Mercurial ne suit pas les informations sur les
        répertoire. En contrepartie, il suit le chemin vers un fichier. Avant
        de créer un fichier, il crée au préalable les répertoires manquants
        dans le chemin. Après avoir supprimé un fichier, il supprime chaque
        répertoire vide qui apparaît dans le chemin du fichier. Ceci apparaît
        comme une distinction triviale, cependant, ceci a une conséquence
        pratique mineure : il n'est pas possible de représenter un répertoire
        totalement vide dans Mercurial.</para>

      <para id="x_1ac">Les répertoires vides sont rarement utiles. Il existe
        des solutions alternatives et non intrusives que vous pouvez utiliser
        pour obtenir l'effet approprié. Les développeurs de Mercurial ont
        ainsi pensé que la complexité requise pour gérer les répertoires
        n'était pas aussi importante que le bénéfice que cette fonctionnalité
        apporterait.</para>

      <para id="x_1ad">Si vous avez besoin d'un répertoire vide dans votre
        dépôt, il existe quelques façons d'y arriver. L'une d'elles est de
        créer un répertoire et d'ensuite, faire un <command role="hg-cmd">hg
          add</command> sur un fichier <quote>hidden</quote> file dans ce
        répertoire. Sur les fichiers de type Unix, tout fichier dont le nom
        commence avec un point (<quote><literal>.</literal></quote>) est
        considéré comme caché par la plupart des commandes et outils
        graphiques. Cette approche est illustré ci-après.</para>
      
      &interaction.daily.files.hidden;

      <para id="x_1ae">Une autre façon de s'attaquer au besoin d'un
        répertoire vide est de simplement en créer un dans vos scripts
        de construction avant qu'ils n'en aient le besoin.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Comment arrêter de suivre un fichier</title>

    <para id="x_1af">Une fois que vous décidez qu'un fichier n'appartient
      plus à votre dépôt, utilisez la commande <command role="hg-cmd">hg
        remove</command>. Ceci supprime le fichier et informe Mercurial
      d'arrêter de le suivre (ce qui prendra effet lors du prochain commit).
      Un fichier supprimé est représenté dans la sortie de la commande
      <command role="hg-cmd">hg status</command> par un
      <quote><literal>R</literal></quote>.</para>

    &interaction.daily.files.remove;

    <para id="x_1b0">Après avoir fait un <command role="hg-cmd">hg
        remove</command> sur un fichier, Mercurial ne suivra plus aucun
      changement sur ce fichier, même si vous recréez un fichier avec le même
      nom dans le répertoire de travail. Si vous recréez un fichier avec le
      même nom et que vous désirez que Mercurial suive ce dernier, faite
      simplement un <command role="hg-cmd">hg add</command> sur celui-ci.
      Mercurial saura alors que le nouveau fichier ne fait pas référence à
      l'ancien fichier qui portait le même nom.</para>

    <sect2>
      <title>Supprimer un fichier n'affecte pas son historique</title>

      <para id="x_1b1">Il est important de comprendre que supprmer un fichier
        n'a que deux effets.</para>

      <itemizedlist>
        <listitem><para id="x_1b2">Il supprime la version actuelle de ce
            fichier du répertoire de travail.</para>
        </listitem>
        <listitem><para id="x_1b3">Il arrête, à partir du prochain commit, le
            suivi de Mercurial sur les changements qui ont lieu sur ce
            fichier.</para>
        </listitem></itemizedlist>
        
      <para id="x_1b4">Supprimer un fichier <emphasis>n'</emphasis>affecte en
        <emphasis>aucun</emphasis> cas l'<emphasis>historique</emphasis> du
        fichier.</para>

      <para id="x_1b5">Si vous mettez à jour le répertoire de travail à un
        changeset qui a été commité alors que le fichier que vous venez de
        supprimer était encore suivi, ce fichier réaparaittra dans le
        répertoire de travail, avec le contenu qu'il avait lorsque vous aviez
        commité ce changeset. Si vous mettez à jour (update) le répertoire de
        travail à un changeset ultérieur, dans lequel le fichier a été
        supprimé, Mercurial supprimera une nouvelle fois le fichier du
        répertoire de travail.</para>
    </sect2>

    <sect2>
      <title>Fichier manquants</title>

      <para id="x_1b6">Mercurial considère qu'un fichier que vous avez
        supprimé sans utiliser<command role="hg-cmd">hg remove</command>
        comme étant <emphasis>manquant</emphasis>.  Un fichier manquant est
        représenté avec un <quote><literal>!</literal></quote> en sortie de
        <command role="hg-cmd">hg status</command>.
        Les commandes Mercurial ne feront rien avec les fichiers
        manquants.</para>

      &interaction.daily.files.missing;

      <para id="x_1b7">Si votre dépôt contient un fichier que <command
          role="hg-cmd">hg status</command> repporte comme manquant, et que
        vous voulez que ce fichier reste supprimé, vous pouvez exécuter
        <command role="hg-cmd">hg remove <option
            role="hg-opt-remove">--after</option></command> à tout moment
        pour dire à Mercurial que vous aviez bien voulu supprimer ce
        fichier.</para>

      &interaction.daily.files.remove-after;

      <para id="x_1b8">D'un autre coté, si vous avez supprimé le fichier
        manquant par accident, donnez à la commande <command role="hg-cmd">hg
          revert</command> le nom du fichier à retrouver. Il réaparaitra dans
        sa forme non modifiée.</para>

      &interaction.daily.files.recover-missing;
    
    </sect2>

    <sect2>
      <title>Entre nous : Pourquoi dire explicitement à Mercurial de supprimer un
      fichier ?</title>

      <para id="x_1b9">Vous pourriez vous demander pourquoi il est nécessaire
        de dire exprécement à Mercurial que vous souhaitez supprimer un
        fichier. Au début du développement de Mercurial, celui ci vous
        laissait pourtant supprimer un fichier sans soucis ; Mercurial vous
        aurait automatiquement informé de l'absence du fichier lorsque vous
        auriez lancé un <command role="hg-cmd">hg commit</command> et arrêté
        de le suivre. En pratique, ceci a montré qu'il était trop facile de
        supprimer accidentellement un fichier sans le remarquer.</para>
    </sect2>

    <sect2>
      <title>Racourcis utile&emdash;ajouter et supprimer des fichiers en une
      seule étape.</title>

      <para id="x_1ba">Mercurial offre une commande combinée, <command
          role="hg-cmd">hg addremove</command>, qui ajoute les fichiers non
        suivis et marque les fichiers manquants comme supprimés.</para>

      &interaction.daily.files.addremove;

      <para id="x_1bb">La commande <command role="hg-cmd">hg commit</command>
        fournit aussi une option <option role="hg-opt-commit">-A</option> qui
        exécute le même ajouter-et-supprimer, immédiatement suivi d'un
        commit.</para>

      &interaction.daily.files.commit-addremove;
    
    </sect2>
  </sect1>

  <sect1 id="chap:daily.copy">
    <title>Copier des fichiers</title>

    <para id="x_1bc">Mercurial fournit une commande <command role="hg-cmd">hg
        copy</command> qui vous permet de faire une nouvelle copie d'un
      fichier. Lorsque vous copiez un fichier en utilisant cette commande,
      Mercurial crée un enregistrement du fait que ce nouveau fichier est une
      copie du fichier originel. Il traite ces fichiers copiés spécialement
      lorsque vous faites une fusion (merge) de votre travail avec quelqu'un
      d'autre.</para>

    <sect2>
      <title>Les résultat d'une copie durant une fusion (merge)</title>

      <para id="x_1bd">Ce qu'il se passe durant une fusion (merge) est que
        les changements <quote>suivent</quote> une copie. Pour illustrer ce
        que ça veut dire de la meilleure façon, créons un exemple. Nous
        allons commencer avec le mini dépôt usuel qui contient un simple
        fichier.</para>

      &interaction.daily.copy.init;

      <para id="x_1be">Nous devons faire du travail en parallèle, ainsi,
        nous aurons quelque chose à fusionner (merge). Donc clonons notre
        dépôt.</para>

      &interaction.daily.copy.clone;

      <para id="x_1bf">De retour dans notre dépôt initial, utilisons la
        commande <command role="hg-cmd">hg copy</command> pour faire une
        copie du premier fichier que nous avons créé.</para>

      &interaction.daily.copy.copy;

      <para id="x_1c0">Si nous regardons ensuite à la sortie de la commande
        <command role="hg-cmd">hg status</command>, les fichiers copiés
        ont l'air de fichiers normalement ajoutés.</para>

      &interaction.daily.copy.status;

      <para id="x_1c1">Mais si nous passons l'option <option
          role="hg-opt-status">-C</option> à <command role="hg-cmd">hg
          status</command>, il affiche une autre ligne de sortie : il s'agit
        du fichier <emphasis>source</emphasis> pour notre copie.</para>

      &interaction.daily.copy.status-copy;

      <para id="x_1c2">Maintenant, de retour dans le dépôt que nous avons
        cloné, et créons un changement en parallèle. Nous allons ajouter une
        ligne de contenu au fichier original qui a été créé.</para>

      &interaction.daily.copy.other;

      <para id="x_1c3">Maintenant, nous avons un fichier
        <filename>file</filename> modifié dans ce dépôt. Lorsque nous
        récupérons (pull) les changements depuis le premier répertoire et
        fusionnons (merge) les deux HEADS, Mercurial propagera les
        changements que nous avons fait localement au fichier
        <filename>file</filename> dans sa copie
        <filename>new-file</filename>.</para>

      &interaction.daily.copy.merge;
    
    </sect2>
    <sect2 id="sec:daily:why-copy">
      <title>Pourquoi les changements devraient suivre les copies ?</title>

      <para id="x_1c4">Ce comportement&emdash;des changements d'un fichiers
        qui se propagent aux copies de ce fichier&emdash;peut sembler
        ésotérique, mais, dans la plupart des cas, c'est hautement
        désirable.</para>

      <para id="x_1c5">Pour commencer, souvenez vous que cette propagation
        a lieue <emphasis>seulement</emphasis> lors des fusions (merge).
        Donc, si vous faites un	<command role="hg-cmd">hg copy</command> sur
        un fichier, et par la suite modifiez le fichier original durant le
        cours normal de votre travail, rien n'a lieu.</para>

      <para id="x_1c6">La deuxième chose à savoir c'est que les modifications
        ne se propageront à travers une copie que si le changeset à partir
        duquel vous faites une fusion (merge) <emphasis>n'a pas encore
          vu</emphasis> la copie.</para>
          
      <para id="x_1c7">La raison pour laquelle Mercurial fait ainsi est une
        règle. Disons que je corrige un important bug dans un fichier source
        et commit mes changements. Pendant ce temps, vous avez décidé de
        faire un <command role="hg-cmd">hg copy</command> du fichier dans
        votre dépôt, sans rien savoir au sujet du bug ou sans avoir rien vu à
        propos de la correction, et vous avez commencé à "hacker" sur votre
        copie du fichier.</para>

      <para id="x_1c8">Si vous aviez récupéré (pull) et fusionné (merge) mes
        changements, et que Mercurial <emphasis>n'avait pas</emphasis>
        propagé les changements à travers les copies, votre nouveau fichier
        source contiendrait maintenant le bug, et à moins que vous sachiez
        qu'il faille propager la correction du bug à la main, le bug aurait
        <emphasis>subsisté</emphasis> dans votre copie du fichier.</para>

      <para id="x_1c9">En propageant automatiquement les changements qui
        fixent les bugs à partir du fichier original vers les copies,
        Mercurial prévient ce type de problèmes. A ma connaissance, Mercurial
        est le <emphasis>seul</emphasis> système de gestion de révisions qui
        propage les changements à travers les copies comme ceci.</para>

      <para id="x_1ca">Une fois que votre historique des changements a un
        enregistrement concernant une copie et une fusion postérieure qui a
        eu lieue, il n'y a d'habitude pas d'autre besoin de propager les
        changements du fichier originel vers le fichier copié, et c'est
        pourquoi Mercurial ne propage les changements à travers les copies
        seulement à la première fusion, et pas d'avantage.</para>
    </sect2>

    <sect2>
      <title>Comment faire des changements qui <emphasis>ne</emphasis>
      suivent <emphasis>pas</emphasis> une copie</title>

      <para id="x_1cb">Si pour une raison ou une autre, vous décidez que
        cette fonctionnalité de propager automatiquement les changements à
        travers les copies n'est pas pour vous, utilisez simplement la
        commande normale de copie de votre système (sur les systèmes de type
        Unix, il s'agit de <command>cp</command>) pour faire une copie d'un
        fichier. Utilisez ensuite <command role="hg-cmd">hg add</command>
        pour ajouter les nouveaux fichiers à la main. Cependant, avant d'en
        faire ainsi, relisez <xref linkend="sec:daily:why-copy"/>, et faites
        un choix en tout état de cause que cette fonctionnalité n'est pas
        appropriée à votre cas spécifique.</para>

    </sect2>
    <sect2>
      <title>Comportement de la commande <command role="hg-cmd">hg copy</command></title>

      <para id="x_1cc">Lorsque vous utilisez la commande <command
          role="hg-cmd">hg copy</command>, Mercurial crée une copie de chaque
        fichier source tel qu'il est actuellement dans le répertoire de
        travail. Cela signifie que si vous faites des modifications à un
        fichier, puis faites un <command role="hg-cmd">hg copy</command> sur
        celui-ci sans avoir au préalable commité ces changements, la nouvelle
        copie contiendra aussi les modifications que vous avez fait jusqu'à
        ce point.	modifications you have made up until that point.  (Je
        trouve ce comportement quelque peu contre intuitif, c'est pourquoi
        j'en fais mention ici.)</para>

      <para id="x_1cd">La commande <command role="hg-cmd">hg copy</command>
        agit comme la commande Unix <command>cp</command> (vous pouvez
        utilisez l'alias <command role="hg-cmd">hg cp</command> si vous
        préférez).  Nous devons lui donner deux ou plus arguments où le
        dernier est considéré comme la <emphasis>destination</emphasis>, et
        les autres comme les <emphasis>sources</emphasis>.</para>

      <para id="x_685">Si vous passez à <command role="hg-cmd">hg
          copy</command> un seul fichier source, et que la destination
        n'existe pas, ceci créera un nouveau fichier avec ce nom.</para>

      &interaction.daily.copy.simple;

      <para id="x_1ce">Si la destination est un répertoire, Mercurial copie
        les sources dans ce répertoire.</para>

      &interaction.daily.copy.dir-dest;

      <para id="x_1cf">La copie de répertoire est récursive et préserve la
        structure du répertoire source.</para>

      &interaction.daily.copy.dir-src;

      <para id="x_1d0">Si la source et la destination sont tous deux des
        répertoires, l'arborescence de la source est recrée dans le
        répertoire destination.</para>
    
      &interaction.daily.copy.dir-src-dest;

      <para id="x_1d1">Comme avec la commande <command role="hg-cmd">hg
          remove</command>, si vous copiez un fichier manuellement et voulez
        que Mercurial sache qu'il s'agit d'une copie, utilisez simplement
        l'option <option role="hg-opt-copy">--after</option> avec <command
          role="hg-cmd">hg copy</command>.</para>

      &interaction.daily.copy.after;
    </sect2>
  </sect1>

  <sect1>
    <title>Renommer les fichiers</title>

    <para id="x_1d2">Il est plus commun d'avoir besoin de renommer un
      fichier que d'en faire une copie. La raison pour laquelle j'ai discuté
      de la commande <command role="hg-cmd">hg copy</command> avant de parler
      de renommage des fichiers est que Mercurial traite les renommages
      essenciellement comme une copie. Ainsi, savoir comment Mercurial traite
      les copies de fichiers vous informe sur ce que vous êtes en droit
      d'attendre lorsque vous renommez un fichier.</para>

    <para id="x_1d3">Lorsque vous utilisez la commande <command
        role="hg-cmd">hg rename</command>, Mercurial crée uen copie de chaque
      fichier source, les supprime et marque ces fichiers comme étant
      supprimés.</para>

    &interaction.daily.rename.rename;

    <para id="x_1d4">La commande <command role="hg-cmd">hg status</command>
      montre le nouveau fichier comme ajouté et le fichier origine comme
      supprimé.</para>

    &interaction.daily.rename.status;

    <para id="x_1d5">A cause du <command role="hg-cmd">hg	copy</command>,
      nous devons utiliser l'option <option role="hg-opt-status">-C</option>
      pour <command	role="hg-cmd">hg status</command> afin d'observer que le
      fichier ajouté est bien suivi par Mercurial comme étant une copie de
      l'original maintenant supprimé.</para>

    &interaction.daily.rename.status-copy;

    <para id="x_1d6">Comme avec <command role="hg-cmd">hg remove</command> et
      <command role="hg-cmd">hg copy</command>, vous pouvez informer
      Mercurial à propos d'un renommage après coup en utilisant l'option
      <option role="hg-opt-rename">--after</option>. Dans le plus grand
      respet, le comportement de la commande <command role="hg-cmd">hg
        rename</command>, et les options qu'il accepte sont similaires à la
      commande <command role="hg-cmd">hg copy</command>.</para>

    <para id="x_686">Si vous êtes familié avec la ligne de commande Unix,
      vous serez heureux d'apprendre que la commande <command
        role="hg-cmd">hg rename</command> peut être invoquée par <command
        role="hg-cmd">hg mv</command>.</para>

    <sect2>
      <title>Renommer les fichiers et fusionner (merge) les changements</title>

      <para id="x_1d7">Puise que le rename de Mercurial est implanté comme un
        "copy-and-remove", la même propagation des changements a lieue
        lorsque vous fusionnez (merge) après un "rename" qu'après un
        "copy".</para>

      <para id="x_1d8">Si je modifie un fichier et que vous le renommez, si
        ensuite nous fusionnons nos changements respectifs, mes modifications
        sur le fichier sous son nom originel seront propagés vers le même
        fichier sous son nouveau nom. (C'est quelque chose que vous pourriez
        espérer voir <quote>fonctionner simplement</quote>, mais tous les
        systèmes de gestion de version ne le font pas.)</para>

      <para id="x_1d9">Tandis qu'avoir des changements qui suivent une copie
        est une fonctionnalité où vous hocheriez sûrement la tête en disant
        <quote>oui, cela pourrait être utile</quote>, il est clair que les
        voir suivre un renommage est définitivement important. Sans cette
        aptitude, il serait simplement trop facile d'avoir des changements
        qui deviennent orphelins lorsque des fichiers sont renommés.</para>
    </sect2>

    <sect2>
      <title>Renommages divergeants et fusion (merge)</title>

      <para id="x_1da">Le cas de noms divergeants a lieu lorsque deux
        développeurs commencent avec un fichier&emdash;apprelons le
        <filename>foo</filename>&emdash;dans leurs dépôts respectifs.</para>

      &interaction.rename.divergent.clone;

      <para id="x_1db">Anne renomme le fichier en
        <filename>bar</filename>.</para>

      &interaction.rename.divergent.rename.anne;

      <para id="x_1dc">Pendant ce temps, Bob le renomme en
        <filename>quux</filename>. (Souvenez vous que <command
          role="hg-cmd">hg mv</command> est un alias pour <command
          role="hg-cmd">hg rename</command>.)</para>
    
      &interaction.rename.divergent.rename.bob;

      <para id="x_1dd">J'aime à penser qu'il s'agit d'un conflit puisque
        chaque développeur a exprimé différentes intentions au sujet de ce
        que le nom de ce fichier aurait du être.</para>

      <para id="x_1de">Que pensez vous qu'il devrait se produire lorsqu'ils
        fusionnent (merge) leurs travaux ? Le comportement actuel de
        Mercurial est qu'il préserve toujours les <emphasis>deux</emphasis>
        noms lorsqu'il fusionne (merge) des changesets qui contiennent des
        renommages divergeants.</para>

      &interaction.rename.divergent.merge;

      <para id="x_1df">Remarquez que bien que Mercurial vous avertisse au
        sujet de la divergeance des renommages, il vous laisse faire quelque
        chose au sujet de la divergeance après la fusion (merge).</para>
    </sect2>

    <sect2>
      <title>Renommages et fusion convergeants</title>

      <para id="x_1e0">Un autre type de conflit de renommage intervient
        lorsque deux personne choisissent de renommer différents fichiers
        <emphasis>source</emphasis> vers la même
        <emphasis>destination</emphasis>. Dans ce cas, Mercurial exécute la
        machinerie normale de fusion (merge) et vous guide vers une
        solution convenable.</para>
    </sect2>

    <sect2>
      <title>Autres cas anguleux relatifs aux noms</title>

      <para id="x_1e1">Mercurial possède un bug de longue date dans lequel il
        échoue à traiter une fusion (merge) où un coté a un fichier avec un
        nom donné, alors que l'autre coté a un répertoire avec le même nom.
        Ceci est documenté dans l'<ulink role="hg-bug"
          url="http://www.selenic.com/mercurial/bts/issue29">issue
          29</ulink>.</para>

      &interaction.issue29.go;

    </sect2>
  </sect1>

  <sect1>
    <title>Récupération d'erreurs</title>

    <para id="x_1e2">Mercurial possède certaines commandes utiles qui vont
      vous aider à récupérer certaines erreurs communes.</para>

    <para id="x_1e3">La commande <command role="hg-cmd">hg revert</command>
      vous permet d'annuler les changements que vous avez fait dans votre
      répertoire de travail. Par exemple, si vous faites un <command
        role="hg-cmd">hg add</command> sur un fichier par accident, exécutez
      juste <command role="hg-cmd">hg	revert</command> avec le nom du fichier
      que vous avez ajouté et tandis que le fichier ne touché d'une
      quelconque manière, il ne sera plus suivi comme ajouté par Mercurial.
      Vous pouvez aussi utiliser la commande <command role="hg-cmd">hg
        revert</command> pour vous débarasser de modifications erronés
      apportées à un fichier.</para>

    <para id="x_1e4">Il est utile de se souvenir que la commande <command
        role="hg-cmd">hg revert</command> est utile pour les modifications
      qui n'ont pas encore été commitées. Une fois que vous avez committé un
      changement, si vous décidez qu'il s'agissait d'une erreur, vous pouvez
      toujours faire quelquechose à ce sujet, bien que vos options seront
      un peu plus limitées.</para>

    <para id="x_1e5">Pour plus d'informations au sujet de la commande
      <command role="hg-cmd">hg revert</command>, et des détails sur comment
      traiter les modifications que vous avez déjà committées, référez vous à
      <xref linkend="chap:undo"/>.</para>
  </sect1>

  <sect1>
    <title>Traiter avec les fusions (merge) malicieuses</title>

    <para id="x_687">Dans des projets compliqués ou conséquents, il n'est pas
      rare qu'une fusion (merge) de deux changesets finisse par une migraine.
      Supposez qu'il y a un gros fichier source qui a été largement édité de
      chaque coté de la fusion (merge) : ceci va inévitablement résulter en
      conflits, dont certains peuvent prendre quelques essais pour s'en
      sortir.</para>

    <para id="x_688">Développons en un cas simple pour voir comment traiter
      avec. Nous allons commencer avec un dépôt contenant un fichier, et le
      cloner deux fois.</para>

    &interaction.ch04-resolve.init;

    <para id="x_689">Dans un des clones, nous allons modifier le fichier
      d'une façon.</para>

    &interaction.ch04-resolve.left;

    <para id="x_68a">Dans un autre, nous allons modifier le fichier
      différamment.</para>

    &interaction.ch04-resolve.right;

    <para id="x_68b">Ensuite, nous allons récupérer (pull) chaque ensemble de
      changement dans notre dépôt original.</para>

    &interaction.ch04-resolve.pull;

    <para id="x_68c">Nous nous attendons à ce que notre dépôt contienne deux
      HEADS.</para>

    &interaction.ch04-resolve.heads;

    <para id="x_68d">Normalement, si nous lançons <command role="hg-cmd">hg
        merge</command> à ce point, il nous renverra vers une interface
      utilisateur qui nous permettra de résoudre manuellement les éditions
      conflictuelles sur le fichier <filename>myfile.txt</filename>.
      Cependant, pour simplifier les choses dans la présentation ici, nous
      aimerions que la fusion (merge) échoue immédiatement plutôt. Voici une
      façon de le faire.</para>

    &interaction.ch04-resolve.export;

    <para id="x_68e">Nous avons dit à la machinerie de fusion de Mercurial
      d'exécuter la commande <command>false</command> (qui échoue
      immédiatement, à la demande) s'il détecte une fusion (merge) qu'il ne
      peut pas arranger automatiquement.</para>

    <para id="x_68f">Si nous appelons maintenant <command role="hg-cmd">hg
        merge</command>, il devrait planter et reporter une erreur.</para>

    &interaction.ch04-resolve.merge;

    <para id="x_690">Même si nous ne remarquons pas qu'une fusion (merge) a
      échoué, Mercurial nous empéchera de committer le résultat d'une fusion
      ratée.</para>

    &interaction.ch04-resolve.cifail;

    <para id="x_691">Lorsque <command role="hg-cmd">hg commit</command>
      échoue dans ce cas, il suggère que nous utilisons la commande peu
      connue <command	role="hg-cmd">hg resolve</command>.  Comme d'habitude,
      <command role="hg-cmd">hg help resolve</command> affichera une aide
      sommaire.</para>

    <sect2>
      <title>File resolution states</title>

      <para id="x_692">When a merge occurs, most files will usually remain
	unmodified.  For each file where Mercurial has to do
	something, it tracks the state of the file.</para>

      <itemizedlist>
	<listitem>
	  <para id="x_693">A <emphasis>resolved</emphasis> file has been
	    successfully merged, either automatically by Mercurial or
	    manually with human intervention.</para>
	</listitem>
	<listitem>
	  <para id="x_694">An <emphasis>unresolved</emphasis> file was not merged
	    successfully, and needs more attention.</para>
	</listitem>
      </itemizedlist>

      <para id="x_695">If Mercurial sees <emphasis>any</emphasis> file in the
	unresolved state after a merge, it considers the merge to have
	failed.  Fortunately, we do not need to restart the entire
	merge from scratch.</para>

      <para id="x_696">The <option role="hg-opt-resolve">--list</option> or
	<option role="hg-opt-resolve">-l</option> option to <command
	  role="hg-cmd">hg resolve</command> prints out the state of
	each merged file.</para>

      &interaction.ch04-resolve.list;

      <para id="x_697">In the output from <command role="hg-cmd">hg
	  resolve</command>, a resolved file is marked with
	<literal>R</literal>, while an unresolved file is marked with
	<literal>U</literal>.  If any files are listed with
	<literal>U</literal>, we know that an attempt to commit the
	results of the merge will fail.</para>
    </sect2>

    <sect2>
      <title>Resolving a file merge</title>

      <para id="x_698">We have several options to move a file from the unresolved
	into the resolved state.  By far the most common is to rerun
	<command role="hg-cmd">hg resolve</command>.  If we pass the
	names of individual files or directories, it will retry the
	merges of any unresolved files present in those locations. We
	can also pass the <option role="hg-opt-resolve">--all</option>
	or <option role="hg-opt-resolve">-a</option> option, which
	will retry the merges of <emphasis>all</emphasis> unresolved
	files.</para>

      <para id="x_699">Mercurial also lets us modify the resolution state of a
	file directly.  We can manually mark a file as resolved using
	the <option role="hg-opt-resolve">--mark</option> option, or
	as unresolved using the <option
	  role="hg-opt-resolve">--unmark</option> option.  This allows
	us to clean up a particularly messy merge by hand, and to keep
	track of our progress with each file as we go.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>More useful diffs</title>

    <para id="x_6c7">The default output of the <command role="hg-cmd">hg
	diff</command> command is backwards compatible with the
      regular <command>diff</command> command, but this has some
      drawbacks.</para>

    <para id="x_6c8">Consider the case where we use <command role="hg-cmd">hg
	rename</command> to rename a file.</para>

    &interaction.ch04-diff.rename.basic;

    <para id="x_6c9">The output of <command role="hg-cmd">hg diff</command> above
      obscures the fact that we simply renamed a file.  The <command
	role="hg-cmd">hg diff</command> command accepts an option,
      <option>--git</option> or <option>-g</option>, to use a newer
      diff format that displays such information in a more readable
      form.</para>

    &interaction.ch04-diff.rename.git;

    <para id="x_6ca">This option also helps with a case that can otherwise be
      confusing: a file that appears to be modified according to
      <command role="hg-cmd">hg status</command>, but for which
      <command role="hg-cmd">hg diff</command> prints nothing. This
      situation can arise if we change the file's execute
      permissions.</para>

    &interaction.ch04-diff.chmod;

    <para id="x_6cb">The normal <command>diff</command> command pays no attention
      to file permissions, which is why <command role="hg-cmd">hg
	diff</command> prints nothing by default.  If we supply it
      with the <option>-g</option> option, it tells us what really
      happened.</para>

    &interaction.ch04-diff.chmod.git;
  </sect1>

  <sect1>
    <title>Which files to manage, and which to avoid</title>

    <para id="x_6cc">Revision control systems are generally best at managing text
      files that are written by humans, such as source code, where the
      files do not change much from one revision to the next.  Some
      centralized revision control systems can also deal tolerably
      well with binary files, such as bitmap images.</para>

    <para id="x_6cd">For instance, a game development team will typically manage
      both its source code and all of its binary assets (e.g. geometry
      data, textures, map layouts) in a revision control
      system.</para>

    <para id="x_6ce">Because it is usually impossible to merge two conflicting
      modifications to a binary file, centralized systems often
      provide a file locking mechanism that allow a user to say
      <quote>I am the only person who can edit this
	file</quote>.</para>

    <para id="x_6cf">Compared to a centralized system, a distributed revision
      control system changes some of the factors that guide decisions
      over which files to manage and how.</para>

    <para id="x_6d0">For instance, a distributed revision control system cannot,
      by its nature, offer a file locking facility.  There is thus no
      built-in mechanism to prevent two people from making conflicting
      changes to a binary file.  If you have a team where several
      people may be editing binary files frequently, it may not be a
      good idea to use Mercurial&emdash;or any other distributed
      revision control system&emdash;to manage those files.</para>

    <para id="x_6d1">When storing modifications to a file, Mercurial usually
      saves only the differences between the previous and current
      versions of the file.  For most text files, this is extremely
      efficient. However, some files (particularly binary files) are
      laid out in such a way that even a small change to a file's
      logical content results in many or most of the bytes inside the
      file changing.  For instance, compressed files are particularly
      susceptible to this. If the differences between each successive
      version of a file are always large, Mercurial will not be able
      to store the file's revision history very efficiently.  This can
      affect both local storage needs and the amount of time it takes
      to clone a repository.</para>

    <para id="x_6d2">To get an idea of how this could affect you in practice,
      suppose you want to use Mercurial to manage an OpenOffice
      document.  OpenOffice stores documents on disk as compressed zip
      files. Edit even a single letter of your document in OpenOffice,
      and almost every byte in the entire file will change when you
      save it. Now suppose that file is 2MB in size.  Because most of
      the file changes every time you save, Mercurial will have to
      store all 2MB of the file every time you commit, even though
      from your perspective, perhaps only a few words are changing
      each time.  A single frequently-edited file that is not friendly
      to Mercurial's storage assumptions can easily have an outsized
      effect on the size of the repository.</para>

    <para id="x_6d3">Even worse, if both you and someone else edit the OpenOffice
      document you're working on, there is no useful way to merge your
      work. In fact, there isn't even a good way to tell what the
      differences are between your respective changes.</para>

    <para id="x_6d4">There are thus a few clear recommendations about specific
      kinds of files to be very careful with.</para>

    <itemizedlist>
      <listitem>
	<para id="x_6d5">Files that are very large and incompressible, e.g. ISO
	  CD-ROM images, will by virtue of sheer size make clones over
	  a network very slow.</para>
      </listitem>
      <listitem>
	<para id="x_6d6">Files that change a lot from one revision to the next
	  may be expensive to store if you edit them frequently, and
	  conflicts due to concurrent edits may be difficult to
	  resolve.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1>
    <title>Backups and mirroring</title>

    <para id="x_6d7">Since Mercurial maintains a complete copy of history in each
      clone, everyone who uses Mercurial to collaborate on a project
      can potentially act as a source of backups in the event of a
      catastrophe.  If a central repository becomes unavailable, you
      can construct a replacement simply by cloning a copy of the
      repository from one contributor, and pulling any changes they
      may not have seen from others.</para>

    <para id="x_6d8">It is simple to use Mercurial to perform off-site backups
      and remote mirrors.  Set up a periodic job (e.g. via the
      <command>cron</command> command) on a remote server to pull
      changes from your master repositories every hour.  This will
      only be tricky in the unlikely case that the number of master
      repositories you maintain changes frequently, in which case
      you'll need to do a little scripting to refresh the list of
      repositories to back up.</para>

    <para id="x_6d9">If you perform traditional backups of your master
      repositories to tape or disk, and you want to back up a
      repository named <filename>myrepo</filename>, use <command>hg
	clone -U myrepo myrepo.bak</command> to create a
      clone of <filename>myrepo</filename> before you start your
      backups.  The <option>-U</option> option doesn't check out a
      working directory after the clone completes, since that would be
      superfluous and make the backup take longer.</para>

    <para id="x_6da">If you then back up <filename>myrepo.bak</filename> instead
      of <filename>myrepo</filename>, you will be guaranteed to have a
      consistent snapshot of your repository that won't be pushed to
      by an insomniac developer in mid-backup.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
