\chapter{Una gira de Mercurial: lo básico}
\label{chap:tour-basic}

\section{Instalar Mercurial en su sistema}
\label{sec:tour:install}
Hay paquetes binarios precompilados de Mercurial disponibles para cada
sistema operativo popular. Esto hace fácil empezar a usar Mercurial
en su computador inmediatamente.

\subsection{Linux}

Dado que cada distribución de Linux tiene sus propias herramientas de
manejo de paquetes, políticas, y ritmos de desarrollo, es difícil dar
un conjunto exhaustivo de instrucciones sobre cómo instalar el paquete
de Mercurial. La versión de Mercurial que usted tenga a disposición
puede variar dependiendo de qué tan activa sea la persona que mantiene
el paquete para su distribución.

Para mantener las cosas simples, me enfocaré en instalar Mercurial
desde la línea de comandos en las distribuciones de Linux más
populares. La mayoría de estas distribuciones proveen administradores
de paquetes gráficos que le permitirán instalar Mercurial con un solo
clic; el nombre de paquete a buscar es \texttt{mercurial}.

\begin{itemize}
\item[Debian]
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}

\item[Fedora Core]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Gentoo]
  \begin{codesample4}
    emerge mercurial
  \end{codesample4}

\item[OpenSUSE]
  \begin{codesample4}
    yum install mercurial
  \end{codesample4}

\item[Ubuntu] El paquete de Mercurial de Ubuntu está basado en el de
    Debian. Para instalarlo, ejecute el siguiente comando.
  \begin{codesample4}
    apt-get install mercurial
  \end{codesample4}
  El paquete de Mercurial para Ubuntu tiende a atrasarse con respecto
  a la versión de Debian por un margen de tiempo considerable
  (al momento de escribir esto, 7 meses), lo que en algunos casos
  significará que usted puede encontrarse con problemas que ya habrán
  sido resueltos en el paquete de Debian.
\end{itemize}

\subsection{Solaris}

SunFreeWare, en \url{http://www.sunfreeware.com}, es una buena fuente
para un gran número de paquetes compilados para Solaris para las
arquitecturas Intel y Sparc de 32 y 64 bits, incluyendo versiones
actuales de Mercurial.

\subsection{Mac OS X}

Lee Cantey publica un instalador de Mercurial para Mac OS~X en 
\url{http://mercurial.berkwood.com}.  Este paquete funciona en tanto
en Macs basados en Intel como basados en PowerPC. Antes de que pueda
usarlo, usted debe instalar una versión compatible de Universal
MacPython~\cite{web:macpython}. Esto es fácil de hacer; simplemente
siga las instrucciones de el sitio de Lee.

También es posible instalar Mercurial usando Fink o MacPorts, dos
administradores de paquetes gratuitos y populares para Mac OS X. Si
usted tiene Fink, use \command{sudo apt-get install mercurial-py25}.
Si usa MacPorts, \command{sudo port install mercurial}.

\subsection{Windows}

Lee Cantey publica un instalador de Mercurial para Windows en
\url{http://mercurial.berkwood.com}. Este paquete no tiene
% TODO traducción de it just works. Agreed?
dependencias externas; ``simplemente funciona''.

\begin{note}
    La versión de Windows de Mercurial no convierte automáticamente
    los fines de línea entre estilos Windows y Unix. Si usted desea
    compartir trabajo con usuarios de Unix, deberá hacer un trabajo
    adicional de configuración. XXX Terminar esto.
\end{note}

\section{Arrancando}

Para empezar, usaremos el comando \hgcmd{version} para revisar si
Mercurial está instalado adecuadamente. La información de la versión
que es impresa no es tan importante; lo que nos importa es si imprime
algo en absoluto.

\interaction{tour.version}

% TODO builtin-> integrado?
\subsection{Ayuda integrada}

Mercurial provee un sistema de ayuda integrada. Esto es invaluable
para ésas ocasiones en la que usted está atorado tratando de recordar
cómo ejecutar un comando. Si está completamente atorado, simplemente
ejecute \hgcmd{help}; esto imprimirá una breve lista de comandos,
junto con una descripción de qué hace cada uno. Si usted solicita
ayuda sobre un comando específico (como abajo), se imprime información
más detallada.
\interaction{tour.help}
Para un nivel más impresionante de detalle (que usted no va a
necesitar usualmente) ejecute \hgcmdargs{help}{\hggopt{-v}}. La opción
\hggopt{-v} es la abreviación para \hggopt{--verbose}, y le indica a
Mercurial que imprima más información de lo que haría usualmente.

\section{Trabajar con un repositorio}

En Mercurial, todo sucede dentro de un \emph{repositorio}. El
repositorio para un proyecto contiene todos los ficheros que
``pertenecen a'' ése proyecto, junto con un registro histórico de los
ficheros de ese proyecto.

No hay nada particularmente mágico acerca de un repositorio; es
simplemente un árbol de directorios en su sistema de ficheros que
Mercurial trata como especial. Usted puede renombrar o borrar un
repositorio en el momento que lo desee, usando bien sea la línea de
comandos o su explorador de ficheros.

\subsection{Hacer una copia local de un repositorio}

\emph{Copiar} un repositorio es sólo ligeramente especial. Aunque
usted podría usar un programa normal de copia de ficheros para hacer
una copia del repositorio, es mejor usar el comando integrado que
Mercurial ofrece. Este comando se llama \hgcmd{clone}\ndt{Del término
``clonar'' en inglés.}, porque crea una copia idéntica de un
repositorio existente.
\interaction{tour.clone}
Si nuestro clonado tiene éxito, deberíamos tener un directorio local
llamado \dirname{hello}. Este directorio contendrá algunos ficheros.
\interaction{tour.ls}
Estos ficheros tienen el mismo contenido e historial en nuestro
repositorio y en el repositorio que clonamos.

Cada repositorio Mercurial está completo, es autocontenido e
independiente. Contiene su propia copia de los ficheros y la historia
de un proyecto. Un repositorio clonado recuerda la ubicación de la que
fue clonado, pero no se comunica con ese repositorio, ni con ningún
otro, a menos que usted le indique que lo haga.

Lo que esto significa por ahora es que somos libres de experimentar
con nuestro repositorio, con la tranquilidad de saber que es una
% TODO figure out what to say instead of sandbox
``caja de arena'' privada que no afectará a nadie más.

\subsection{Qué hay en un repositorio?}

Cuando miramos en detalle dentro de un repositorio, podemos ver que
contiene un directorio llamado \dirname{.hg}. Aquí es donde Mercurial
mantiene todos los metadatos del repositorio.
\interaction{tour.ls-a}

Los contenidos del directorio \dirname{.hg} y sus subdirectorios son
exclusivos de Mercurial. Usted es libre de hacer lo que desee con
cualquier otro fichero o directorio en el repositorio.

Para introducir algo de terminología, el directorio \dirname{.hg} es
el repositorio ``real'', y todos los ficheros y directorios que
coexisten con él están en el \emph{directorio de trabajo}. Una forma
sencilla de recordar esta distinción es que el \emph{repositorio}
% TODO unificar con Igor, si historia o historial
contiene el \emph{historial} de su proyecto, mientras que el
\emph{directorio de trabajo} contiene una \emph{instantánea} de su
proyecto en un punto particular del historial.

\section{Vistazo rápido al historial}

Una de las primeras cosas que se desea hacer con un repositorio nuevo,
poco conocido, es conocer su historial. el comando \hgcmd{log} nos
permite ver el mismo.
\interaction{tour.log}
Por defecto este programa imprime un párrafo breve por cada cambio al
proyecto que haya sido grabado. Dentro de la terminología de
Mercurial, cada uno de estos eventos es llamado \emph{conjuntos de
cambios}, porque pueden contener un registro de cambios a varios
ficheros.

Los campos de la salida de \hgcmd{log} son los siguientes.
\begin{itemize}
    \item[\texttt{changeset}]\hspace{-0.5em}\ndt{Conjunto de cambios.} Este campo
        tiene un número, seguido por un
        % TODO digo mejor seguido por un dos puntos ? string =>
        % cadena?
        \texttt{:}, seguido por una cadena hexadecimal. Ambos son
        \emph{identificadores} para el conjunto de cambios. Hay dos
        identificadores porque el número es más corto y más fácil de
        recordar que la cadena hexadecimal.
        
\item[\texttt{user}]\hspace{-0.5em}\ndt{Usuario.} La identidad de la
    persona que creó el conjunto de cambios. Este es un campo en el
    que se puede almacenar cualquier valor, pero en la mayoría de los
    casos contiene el nombre de una persona y su dirección de correo
    electrónico.
    
\item[\texttt{date}]\hspace{-0.5em}\ndt{Fecha.} La fecha y hora en la
    que el conjunto de cambios fue creado, y la zona horaria en la que
    fue creado. (La fecha y hora son locales a dicha zona horaria;
    ambos muestran la fecha y hora para la persona que creó el
    changeset).
    
\item[\texttt{summary}]\hspace{-0.5em}\ndt{Sumario.} 
    La primera línea del texto que usó la persona que creó el conjunto
    de cambios para describir el mismo.
\end{itemize}
El texto impreso por \hgcmd{log} es sólo un sumario; omite una gran
cantidad de detalles.

La figura~\ref{fig:tour-basic:history} es una representación
gráfica del historial del repositorio \dirname{hello}, para hacer más
fácil ver en qué dirección está ``fluyendo'' el historial. Volveremos
a esto varias veces en este capítulo y en los siguientes.

\begin{figure}[ht]
  \centering
  \grafix{tour-history}
  \caption{Historial gráfico de el repositorio \dirname{hello}}
  \label{fig:tour-basic:history}
\end{figure}

\subsection{Conjuntos de cambios, revisiones, y comunicándose con
otras personas}

%TODO sloppy => desordenado ?  TODO hablar del inglés? o de español?
Ya que el inglés es un lenguaje notablemente desordenado, y el área de
ciencias de la computación tiene una notable historia de confusión de
% TODO insertar ? al revés. no sé cómo en un teclado de estos.
términos (porqué usar sólo un término cuando cuatro pueden servir?),
el control de revisiones tiene una variedad de frases y palabras que
tienen el mismo significado. Si usted habla acerca del historial de
Mercurial con alguien, encontrará que la expresión ``conjunto de
cambios'' es abreviada a menudo como ``cambio'' o (por escrito)
``cset''\ndt{Abreviatura para la expresión ``changeset'' en inglés.},
y algunas veces un se hace referencia a un conjunto de cambios como
una ``revisión'' o ``rev''\ndt{De nuevo, como abreviación para el
término en inglés para ``revisión'' (``revision'').}.

Si bien no es relevante qué \emph{palabra} use usted para referirse al
concepto ``conjunto de cambios'', el \emph{identificador} que usted
use para referise a ``un \emph{conjunto de cambios} particular'' es
muy importante. Recuerde que el campo \texttt{changeset} en la salida
de \hgcmd{log} identifica un conjunto de cambios usando tanto un
número como una cadena hexadecimal.

\begin{itemize}
    \item El número de revisión \emph{sólo es válido dentro del
        repositorio}.
    \item Por otro lado, la cadena hexadecimal es el
        \emph{identificador permanente e inmutable} que siempre
        identificará ése conjunto de cambios en \emph{todas} las
        copias del repositorio.
\end{itemize}
La diferencia es importante. Si usted le envía a alguien un correo
electrónico hablando acerca de la ``revisión~33'', hay una
probabilidad alta de que la revisión~33 de esa persona \emph{no sea la
misma suya}. Esto sucede porque el número de revisión depende de el
orden en que llegan los cambios al repositorio, y no hay ninguna
garantía de que los mismos cambios llegarán en el mismo orden en
diferentes repositorios. Tres cambios dados $a,b,c$ pueden aparecer en
un repositorio como $0,1,2$, mientras que en otro aparecen como
$1,0,2$.

Mercurial usa los números de revisión simplemente como una abreviación
conveniente. Si usted necesita hablar con alguien acerca de un
conjunto de cambios, o llevar el registro de un conjunto de cambios
por alguna otra razón (por ejemplo, en un reporte de fallo), use el
identificador hexadecimal.

\subsection{Ver revisiones específicas}

Para reducir la salida de \hgcmd{log} a una sola revisión, use la  
opción \hgopt{log}{-r} (o \hgopt{log}{--rev}).  Puede usar un número
de revisión o un identificador hexadecimal de conjunto de cambios, y
puede pasar tantas revisiones como desee.

\interaction{tour.log-r}

Si desea ver el historial de varias revisiones sin tener que mencionar
cada una de ellas, puede usar la \emph{notación de rango}; esto le
permite expresar el concepto ``quiero ver todas las revisiones entre
$a$ y $b$, inclusive''.
\interaction{tour.log.range}
Mercurial también respeta el orden en que usted especifica las
revisiones, así que \hgcmdargs{log}{-r 2:4} muestra $2,3,4$ mientras
que \hgcmdargs{log}{-r 4:2} muestra $4,3,2$.

\subsection{Información más detallada}
Aunque la información presentada por \hgcmd{log} es útil si usted sabe
de antemano qué está buscando, puede que necesite ver una descripción
completa de el cambio, o una lista de los ficheros que cambiaron, si
está tratando de averiguar si un conjunto de cambios dado es el que
usted está buscando. La opción \hggopt{-v} (or \hggopt{--verbose}) del
comando \hgcmd{log} le da este nivel extra de detalle.
\interaction{tour.log-v}

Si desea ver tanto la descripción como el contenido de un cambio,
añada la opción \hgopt{log}{-p} (o \hgopt{log}{--patch}). Esto muestra
% TODO qué hacemos con diff unificado? convervarlo, por ser la
% acepción usual?
el contenido de un cambio como un \emph{diff unificado} (si usted
nunca ha visto un diff unificado antes, vea la
sección~\ref{sec:mq:patch} para un vistazo global).
\interaction{tour.log-vp}

\section{Todo acerca de las opciones para comandos}

Tomemos un breve descanso de la tarea de explorar los comandos de
Mercurial para hablar de un patrón en la manera en qué trabajan; será
útil tener esto en mente a medida que avanza nuestra gira.

Mercurial tiene un enfoque consistente y directo en el manejo de las
opciones que usted le puede pasar a los comandos. Se siguen las
convenciones para opciones que son comunes en sistemas Linux y Unix
modernos.
\begin{itemize}
\item Cada opción tiene un nombre largo. Por ejemplo, el comando
    \hgcmd{log} acepta la opción \hgopt{log}{--rev}, como ya hemos
    visto.
\item Muchas opciones tienen también un nombre corto. En vez de
    \hgopt{log}{--rev}, podemos usar \hgopt{log}{-r}.  (El motivo para
    que algunas opciones no tengan nombres cortos es que dichas
    opciones se usan rara vez.)
\item Las opciones largas empiezan con dos guiones (p.ej.~\hgopt{log}{--rev}),
    mientras que las opciones cortas empiezan con uno (e.g.~\hgopt{log}{-r}).
\item El nombre  y uso de las opciones es consistente en todos los
    comandos. Por ejemplo, cada comando que le permite pasar un ID de
    conjunto de cambios o un número de revisión acepta tanto la opción
    \hgopt{log}{-r} como la \hgopt{log}{--rev}.
\end{itemize}
En los ejemplos en este libro, uso las opciones cortas en vez de las
largas. Esto sólo muestra mis preferencias, así que no le dé
significado especial a eso.

Muchos de los comandos que generan salida de algún tipo mostrarán más
salida cuando se les pase la opción \hggopt{-v} (o
\hggopt{--verbose}\ndt{Prolijo.}), y menos cuando se les pase la opción \hggopt{-q}
(o \hggopt{--quiet}\ndt{Silencioso.}).

\section{Making and reviewing changes}

Now that we have a grasp of viewing history in Mercurial, let's take a
look at making some changes and examining them.

The first thing we'll do is isolate our experiment in a repository of
its own.  We use the \hgcmd{clone} command, but we don't need to
clone a copy of the remote repository.  Since we already have a copy
of it locally, we can just clone that instead.  This is much faster
than cloning over the network, and cloning a local repository uses
less disk space in most cases, too.
\interaction{tour.reclone}
As an aside, it's often good practice to keep a ``pristine'' copy of a
remote repository around, which you can then make temporary clones of
to create sandboxes for each task you want to work on.  This lets you
work on multiple tasks in parallel, each isolated from the others
until it's complete and you're ready to integrate it back.  Because
local clones are so cheap, there's almost no overhead to cloning and
destroying repositories whenever you want.

In our \dirname{my-hello} repository, we have a file
\filename{hello.c} that contains the classic ``hello, world'' program.
Let's use the ancient and venerable \command{sed} command to edit this
file so that it prints a second line of output.  (I'm only using
\command{sed} to do this because it's easy to write a scripted example
this way.  Since you're not under the same constraint, you probably
won't want to use \command{sed}; simply use your preferred text editor to
do the same thing.)
\interaction{tour.sed}

Mercurial's \hgcmd{status} command will tell us what Mercurial knows
about the files in the repository.
\interaction{tour.status}
The \hgcmd{status} command prints no output for some files, but a line
starting with ``\texttt{M}'' for \filename{hello.c}.  Unless you tell
it to, \hgcmd{status} will not print any output for files that have
not been modified.  

The ``\texttt{M}'' indicates that Mercurial has noticed that we
modified \filename{hello.c}.  We didn't need to \emph{inform}
Mercurial that we were going to modify the file before we started, or
that we had modified the file after we were done; it was able to
figure this out itself.

It's a little bit helpful to know that we've modified
\filename{hello.c}, but we might prefer to know exactly \emph{what}
changes we've made to it.  To do this, we use the \hgcmd{diff}
command.
\interaction{tour.diff}

\section{Recording changes in a new changeset}

We can modify files, build and test our changes, and use
\hgcmd{status} and \hgcmd{diff} to review our changes, until we're
satisfied with what we've done and arrive at a natural stopping point
where we want to record our work in a new changeset.

The \hgcmd{commit} command lets us create a new changeset; we'll
usually refer to this as ``making a commit'' or ``committing''.  

\subsection{Setting up a username}

When you try to run \hgcmd{commit} for the first time, it is not
guaranteed to succeed.  Mercurial records your name and address with
each change that you commit, so that you and others will later be able
to tell who made each change.  Mercurial tries to automatically figure
out a sensible username to commit the change with.  It will attempt
each of the following methods, in order:
\begin{enumerate}
\item If you specify a \hgopt{commit}{-u} option to the \hgcmd{commit}
  command on the command line, followed by a username, this is always
  given the highest precedence.
\item If you have set the \envar{HGUSER} environment variable, this is
  checked next.
\item If you create a file in your home directory called
  \sfilename{.hgrc}, with a \rcitem{ui}{username} entry, that will be
  used next.  To see what the contents of this file should look like,
  refer to section~\ref{sec:tour-basic:username} below.
\item If you have set the \envar{EMAIL} environment variable, this
  will be used next.
\item Mercurial will query your system to find out your local user
  name and host name, and construct a username from these components.
  Since this often results in a username that is not very useful, it
  will print a warning if it has to do this.
\end{enumerate}
If all of these mechanisms fail, Mercurial will fail, printing an
error message.  In this case, it will not let you commit until you set
up a username.

You should think of the \envar{HGUSER} environment variable and the
\hgopt{commit}{-u} option to the \hgcmd{commit} command as ways to
\emph{override} Mercurial's default selection of username.  For normal
use, the simplest and most robust way to set a username for yourself
is by creating a \sfilename{.hgrc} file; see below for details.

\subsubsection{Creating a Mercurial configuration file}
\label{sec:tour-basic:username}

To set a user name, use your favourite editor to create a file called
\sfilename{.hgrc} in your home directory.  Mercurial will use this
file to look up your personalised configuration settings.  The initial
contents of your \sfilename{.hgrc} should look like this.
\begin{codesample2}
  # This is a Mercurial configuration file.
  [ui]
  username = Firstname Lastname <email.address@domain.net>
\end{codesample2}
The ``\texttt{[ui]}'' line begins a \emph{section} of the config file,
so you can read the ``\texttt{username = ...}'' line as meaning ``set
the value of the \texttt{username} item in the \texttt{ui} section''.
A section continues until a new section begins, or the end of the
file.  Mercurial ignores empty lines and treats any text from
``\texttt{\#}'' to the end of a line as a comment.

\subsubsection{Choosing a user name}

You can use any text you like as the value of the \texttt{username}
config item, since this information is for reading by other people,
but for interpreting by Mercurial.  The convention that most people
follow is to use their name and email address, as in the example
above.

\begin{note}
  Mercurial's built-in web server obfuscates email addresses, to make
  it more difficult for the email harvesting tools that spammers use.
  This reduces the likelihood that you'll start receiving more junk
  email if you publish a Mercurial repository on the web.
\end{note}

\subsection{Writing a commit message}

When we commit a change, Mercurial drops us into a text editor, to
enter a message that will describe the modifications we've made in
this changeset.  This is called the \emph{commit message}.  It will be
a record for readers of what we did and why, and it will be printed by
\hgcmd{log} after we've finished committing.
\interaction{tour.commit}

The editor that the \hgcmd{commit} command drops us into will contain
an empty line, followed by a number of lines starting with
``\texttt{HG:}''.
\begin{codesample2}
  \emph{empty line}
  HG: changed hello.c
\end{codesample2}
Mercurial ignores the lines that start with ``\texttt{HG:}''; it uses
them only to tell us which files it's recording changes to.  Modifying
or deleting these lines has no effect.

\subsection{Writing a good commit message}

Since \hgcmd{log} only prints the first line of a commit message by
default, it's best to write a commit message whose first line stands
alone.  Here's a real example of a commit message that \emph{doesn't}
follow this guideline, and hence has a summary that is not readable.
\begin{codesample2}
  changeset:   73:584af0e231be
  user:        Censored Person <censored.person@example.org>
  date:        Tue Sep 26 21:37:07 2006 -0700
  summary:     include buildmeister/commondefs.   Add an exports and install
\end{codesample2}

As far as the remainder of the contents of the commit message are
concerned, there are no hard-and-fast rules.  Mercurial itself doesn't
interpret or care about the contents of the commit message, though
your project may have policies that dictate a certain kind of
formatting.

My personal preference is for short, but informative, commit messages
that tell me something that I can't figure out with a quick glance at
the output of \hgcmdargs{log}{--patch}.

\subsection{Aborting a commit}

If you decide that you don't want to commit while in the middle of
editing a commit message, simply exit from your editor without saving
the file that it's editing.  This will cause nothing to happen to
either the repository or the working directory.

If we run the \hgcmd{commit} command without any arguments, it records
all of the changes we've made, as reported by \hgcmd{status} and
\hgcmd{diff}.

\subsection{Admiring our new handiwork}

Once we've finished the commit, we can use the \hgcmd{tip} command to
display the changeset we just created.  This command produces output
that is identical to \hgcmd{log}, but it only displays the newest
revision in the repository.
\interaction{tour.tip}
We refer to the newest revision in the repository as the tip revision,
or simply the tip.

\section{Sharing changes}

We mentioned earlier that repositories in Mercurial are
self-contained.  This means that the changeset we just created exists
only in our \dirname{my-hello} repository.  Let's look at a few ways
that we can propagate this change into other repositories.

\subsection{Pulling changes from another repository}
\label{sec:tour:pull}

To get started, let's clone our original \dirname{hello} repository,
which does not contain the change we just committed.  We'll call our
temporary repository \dirname{hello-pull}.
\interaction{tour.clone-pull}

We'll use the \hgcmd{pull} command to bring changes from
\dirname{my-hello} into \dirname{hello-pull}.  However, blindly
pulling unknown changes into a repository is a somewhat scary
prospect.  Mercurial provides the \hgcmd{incoming} command to tell us
what changes the \hgcmd{pull} command \emph{would} pull into the
repository, without actually pulling the changes in.
\interaction{tour.incoming}
(Of course, someone could cause more changesets to appear in the
repository that we ran \hgcmd{incoming} in, before we get a chance to
\hgcmd{pull} the changes, so that we could end up pulling changes that we
didn't expect.)

Bringing changes into a repository is a simple matter of running the
\hgcmd{pull} command, and telling it which repository to pull from.
\interaction{tour.pull}
As you can see from the before-and-after output of \hgcmd{tip}, we
have successfully pulled changes into our repository.  There remains
one step before we can see these changes in the working directory.

\subsection{Updating the working directory}

We have so far glossed over the relationship between a repository and
its working directory.  The \hgcmd{pull} command that we ran in
section~\ref{sec:tour:pull} brought changes into the repository, but
if we check, there's no sign of those changes in the working
directory.  This is because \hgcmd{pull} does not (by default) touch
the working directory.  Instead, we use the \hgcmd{update} command to
do this.
\interaction{tour.update}

It might seem a bit strange that \hgcmd{pull} doesn't update the
working directory automatically.  There's actually a good reason for
this: you can use \hgcmd{update} to update the working directory to
the state it was in at \emph{any revision} in the history of the
repository.  If you had the working directory updated to an old
revision---to hunt down the origin of a bug, say---and ran a
\hgcmd{pull} which automatically updated the working directory to a
new revision, you might not be terribly happy.

However, since pull-then-update is such a common thing to do,
Mercurial lets you combine the two by passing the \hgopt{pull}{-u}
option to \hgcmd{pull}.
\begin{codesample2}
  hg pull -u
\end{codesample2}
If you look back at the output of \hgcmd{pull} in
section~\ref{sec:tour:pull} when we ran it without \hgopt{pull}{-u},
you can see that it printed a helpful reminder that we'd have to take
an explicit step to update the working directory:
\begin{codesample2}
  (run 'hg update' to get a working copy)
\end{codesample2}

To find out what revision the working directory is at, use the
\hgcmd{parents} command.
\interaction{tour.parents}
If you look back at figure~\ref{fig:tour-basic:history}, you'll see
arrows connecting each changeset.  The node that the arrow leads
\emph{from} in each case is a parent, and the node that the arrow
leads \emph{to} is its child.  The working directory has a parent in
just the same way; this is the changeset that the working directory
currently contains.

To update the working directory to a particular revision, give a
revision number or changeset~ID to the \hgcmd{update} command.
\interaction{tour.older}
If you omit an explicit revision, \hgcmd{update} will update to the
tip revision, as shown by the second call to \hgcmd{update} in the
example above.

\subsection{Pushing changes to another repository}

Mercurial lets us push changes to another repository, from the
repository we're currently visiting.  As with the example of
\hgcmd{pull} above, we'll create a temporary repository to push our
changes into.
\interaction{tour.clone-push}
The \hgcmd{outgoing} command tells us what changes would be pushed
into another repository.
\interaction{tour.outgoing}
And the \hgcmd{push} command does the actual push.
\interaction{tour.push}
As with \hgcmd{pull}, the \hgcmd{push} command does not update the
working directory in the repository that it's pushing changes into.
(Unlike \hgcmd{pull}, \hgcmd{push} does not provide a \texttt{-u}
option that updates the other repository's working directory.)

What happens if we try to pull or push changes and the receiving
repository already has those changes?  Nothing too exciting.
\interaction{tour.push.nothing}

\subsection{Sharing changes over a network}

The commands we have covered in the previous few sections are not
limited to working with local repositories.  Each works in exactly the
same fashion over a network connection; simply pass in a URL instead
of a local path.
\interaction{tour.outgoing.net}
In this example, we can see what changes we could push to the remote
repository, but the repository is understandably not set up to let
anonymous users push to it.
\interaction{tour.push.net}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
