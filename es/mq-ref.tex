\chapter{Referencia de las Colas de Mercurial}
\label{chap:mqref}

\section{Referencia de órdenes MQ}
\label{sec:mqref:cmdref}

Si desea dar un vistazo a las órdenes que ofrece MQ, use la orden
\hgcmdargs{help}{mq}.

\subsection{\hgxcmd{mq}{qapplied}---imprimir los parches aplicados}

La orden \hgxcmd{mq}{qapplied} imprime la pila actual de parches
aplicados.  Los parches se imprimen en orden de antigüedad, primero
los más antiguos y después los más recientes, por lo tanto el último
parche de la lista es el que está en el ``tope''.

\subsection{\hgxcmd{mq}{qcommit}---consignar cambios en la cola del repositorio}

La orden \hgxcmd{mq}{qcommit} consigna cualquier cambio sobresaliente
en el repositorio \sdirname{.hg/patches}.  Esta orden solamente
funciona si el directorio \sdirname{.hg/patches} es un repositorio,
p.e.~usted creó el directorio con
\hgcmdargs{qinit}{\hgxopt{mq}{qinit}{-c}} o ejecutó
\hgcmd{init} en el directorio después de correr \hgxcmd{mq}{qinit}.

Esta orden es un atajo para \hgcmdargs{commit}{--cwd .hg/patches}.

\subsection{\hgxcmd{mq}{qdelete}---eliminar un parche del fichero
  \sfilename{series}}

La orden \hgxcmd{mq}{qdelete} elimina la entrada del fichero
\sfilename{series} para el parche en el directorio
\sdirname{.hg/patches}.  No sca el parche si ha sido aplicado.  De
forma predeterminada no borra el fichero del parche; use la opción
\hgxopt{mq}{qdel}{-f} para hacerlo.

Opciones:
\begin{itemize}
\item[\hgxopt{mq}{qdel}{-f}] Elimina el fichero del parche.
\end{itemize}

\subsection{\hgxcmd{mq}{qdiff}---imprimir la diferencia del último
  parche aplicado}

La orden \hgxcmd{mq}{qdiff} imprime un diff del parche más
recientemente aplicado.  Es equivalente a \hgcmdargs{diff}{-r-2:-1}.

\subsection{\hgxcmd{mq}{qfold}---fusionar (``integrar'') varios parches en
  uno solo}

La orden \hgxcmd{mq}{qfold} fusiona muchos parches en el último parche
aplicado, de tal forma que el último parche aplicado es la unión de
todos los cambios de los parches en cuestión.

Los parches a fusionar no deben haber sido aplicados;
\hgxcmd{mq}{qfold} saldrá indicando un error si alguno ha sido
aplicado.  El orden en el cual los parches se pliegan es
significativo; \hgcmdargs{qfold}{a b} significa ``aplique el parche
más reciente, seguido de \texttt{a}, y seguido de \texttt{b}''.

Los comentarios de los parches integrados se colocan al final de los
comentarios del parche destino, con cada bloque de comentarios
separado con tres asteriscos(``\texttt{*}'').  Se usa la opción
\hgxopt{mq}{qfold}{-e} para editar el mensaje de consignación para el
conjunto de cambios/parches después de completarse el pliegue.

Opciones:
\begin{itemize}
\item[\hgxopt{mq}{qfold}{-e}] Edita el mensaje de consignación y la
  descripción del parche del parche que se ha integrado.
\item[\hgxopt{mq}{qfold}{-l}] Usa los contenidos del fichero dado como
  el nuevo mensaje de consignación y descripción del parche para el
  parche a integrar.
\item[\hgxopt{mq}{qfold}{-m}] Usa el texto dado como el mensaje de
  consignación y descripción del parche para el parche integrado.
\end{itemize}

\subsection{\hgxcmd{mq}{qheader}---desplegar el encabezado/descripción
  de un parche}

La orden \hgxcmd{mq}{qheader} imprime el encabezado o descripción de
un parche.  De forma predeterminada, imprime el encabezado del último
parche aplicado. Si se da un argumento, imprime el encabezado del
parche referenciado.

\subsection{\hgxcmd{mq}{qimport}---importar el parche de un tercero en
  la cola}

La orden \hgxcmd{mq}{qimport} añade una entrada de un parche externo
al fichero \sfilename{series} y copia el parche en el directorio
\sdirname{.hg/patches}.  Añade la entrada inmediatamente después del
último parche aplicado, pero no introduce el parche.

Si el directorio \sdirname{.hg/patches} es un repositorio, 
\hgxcmd{mq}{qimport} automáticamente hace un \hgcmd{add} del parche
importado.

\subsection{\hgxcmd{mq}{qinit}---preparar un repositorio para trabajar
  con MQ}

La orden \hgxcmd{mq}{qinit} prepara un repositorio para trabajar con
MQ.  Crea un directorio llamado \sdirname{.hg/patches}.

Opciones:
\begin{itemize}
\item[\hgxopt{mq}{qinit}{-c}] Crea \sdirname{.hg/patches} como un
  repositorio por sí mismo.  También crea un fichero
  \sfilename{.hgignore} que ignorará el fichero \sfilename{status}.
\end{itemize}

Cuando el directorio \sdirname{.hg/patches} es un repositorio, las órdenes
\hgxcmd{mq}{qimport} y \hgxcmd{mq}{qnew} hacen \hgcmd{add}
automáticamente a los parches nuevos.

\subsection{\hgxcmd{mq}{qnew}---crear un parche nuevo}

La orden \hgxcmd{mq}{qnew} crea un parche nuevo.  Exige un argumento,
el nombre que se usará para tal parche.  El parche recién creado está
vacío inicialmente.   Se añade al fichero \sfilename{series} después
del último parche aplicado, y se introduce en el tope de ese parche.

Si \hgxcmd{mq}{qnew} encuentra ficheros modificados en el directorio
de trabajo, rehusará crear un parche nuevo a meos que se emplee
\hgxopt{mq}{qnew}{-f} la opción(ver más adelante).  Este
comportamiento le permite hacer \hgxcmd{mq}{qrefresh} al último parche
aplicado antes de aplicar un parche nuevo encima de este.

Opciones:
\begin{itemize}
\item[\hgxopt{mq}{qnew}{-f}] Crea un parche nuevo si los contenidos
  del directorio actual han sido modificados.  Cualquier modificación
  significativa se añade al parche recientemente creado,  de tal forma
  que al finalizar la orden, el directorio de trabajo no lucirá
  modificado.
\item[\hgxopt{mq}{qnew}{-m}] Usa el texto dado como el mensaje de
  consignación.  Este texto se almacenará al principio del fichero del
  parche, antes de los datos del parche.
\end{itemize}

\subsection{\hgxcmd{mq}{qnext}---print the name of the next patch}

The \hgxcmd{mq}{qnext} command prints the name name of the next patch in
the \sfilename{series} file after the topmost applied patch.  This
patch will become the topmost applied patch if you run \hgxcmd{mq}{qpush}.

\subsection{\hgxcmd{mq}{qpop}---pop patches off the stack}

The \hgxcmd{mq}{qpop} command removes applied patches from the top of the
stack of applied patches.  By default, it removes only one patch.

This command removes the changesets that represent the popped patches
from the repository, and updates the working directory to undo the
effects of the patches.

This command takes an optional argument, which it uses as the name or
index of the patch to pop to.  If given a name, it will pop patches
until the named patch is the topmost applied patch.  If given a
number, \hgxcmd{mq}{qpop} treats the number as an index into the entries in
the series file, counting from zero (empty lines and lines containing
only comments do not count).  It pops patches until the patch
identified by the given index is the topmost applied patch.

The \hgxcmd{mq}{qpop} command does not read or write patches or the
\sfilename{series} file.  It is thus safe to \hgxcmd{mq}{qpop} a patch that
you have removed from the \sfilename{series} file, or a patch that you
have renamed or deleted entirely.  In the latter two cases, use the
name of the patch as it was when you applied it.

By default, the \hgxcmd{mq}{qpop} command will not pop any patches if the
working directory has been modified.  You can override this behaviour
using the \hgxopt{mq}{qpop}{-f} option, which reverts all modifications in
the working directory.

Options:
\begin{itemize}
\item[\hgxopt{mq}{qpop}{-a}] Pop all applied patches.  This returns the
  repository to its state before you applied any patches.
\item[\hgxopt{mq}{qpop}{-f}] Forcibly revert any modifications to the
  working directory when popping.
\item[\hgxopt{mq}{qpop}{-n}] Pop a patch from the named queue.
\end{itemize}

The \hgxcmd{mq}{qpop} command removes one line from the end of the
\sfilename{status} file for each patch that it pops.

\subsection{\hgxcmd{mq}{qprev}---print the name of the previous patch}

The \hgxcmd{mq}{qprev} command prints the name of the patch in the
\sfilename{series} file that comes before the topmost applied patch.
This will become the topmost applied patch if you run \hgxcmd{mq}{qpop}.

\subsection{\hgxcmd{mq}{qpush}---push patches onto the stack}
\label{sec:mqref:cmd:qpush}

The \hgxcmd{mq}{qpush} command adds patches onto the applied stack.  By
default, it adds only one patch.

This command creates a new changeset to represent each applied patch,
and updates the working directory to apply the effects of the patches.

The default data used when creating a changeset are as follows:
\begin{itemize}
\item The commit date and time zone are the current date and time
  zone.  Because these data are used to compute the identity of a
  changeset, this means that if you \hgxcmd{mq}{qpop} a patch and
  \hgxcmd{mq}{qpush} it again, the changeset that you push will have a
  different identity than the changeset you popped.
\item The author is the same as the default used by the \hgcmd{commit}
  command.
\item The commit message is any text from the patch file that comes
  before the first diff header.  If there is no such text, a default
  commit message is used that identifies the name of the patch.
\end{itemize}
If a patch contains a Mercurial patch header (XXX add link), the
information in the patch header overrides these defaults.

Options:
\begin{itemize}
\item[\hgxopt{mq}{qpush}{-a}] Push all unapplied patches from the
  \sfilename{series} file until there are none left to push.
\item[\hgxopt{mq}{qpush}{-l}] Add the name of the patch to the end
  of the commit message.
\item[\hgxopt{mq}{qpush}{-m}] If a patch fails to apply cleanly, use the
  entry for the patch in another saved queue to compute the parameters
  for a three-way merge, and perform a three-way merge using the
  normal Mercurial merge machinery.  Use the resolution of the merge
  as the new patch content.
\item[\hgxopt{mq}{qpush}{-n}] Use the named queue if merging while pushing.
\end{itemize}

The \hgxcmd{mq}{qpush} command reads, but does not modify, the
\sfilename{series} file.  It appends one line to the \hgcmd{status}
file for each patch that it pushes.

\subsection{\hgxcmd{mq}{qrefresh}---update the topmost applied patch}

The \hgxcmd{mq}{qrefresh} command updates the topmost applied patch.  It
modifies the patch, removes the old changeset that represented the
patch, and creates a new changeset to represent the modified patch.

The \hgxcmd{mq}{qrefresh} command looks for the following modifications:
\begin{itemize}
\item Changes to the commit message, i.e.~the text before the first
  diff header in the patch file, are reflected in the new changeset
  that represents the patch.
\item Modifications to tracked files in the working directory are
  added to the patch.
\item Changes to the files tracked using \hgcmd{add}, \hgcmd{copy},
  \hgcmd{remove}, or \hgcmd{rename}.  Added files and copy and rename
  destinations are added to the patch, while removed files and rename
  sources are removed.
\end{itemize}

Even if \hgxcmd{mq}{qrefresh} detects no changes, it still recreates the
changeset that represents the patch.  This causes the identity of the
changeset to differ from the previous changeset that identified the
patch.

Options:
\begin{itemize}
\item[\hgxopt{mq}{qrefresh}{-e}] Modify the commit and patch description,
  using the preferred text editor.
\item[\hgxopt{mq}{qrefresh}{-m}] Modify the commit message and patch
  description, using the given text.
\item[\hgxopt{mq}{qrefresh}{-l}] Modify the commit message and patch
  description, using text from the given file.
\end{itemize}

\subsection{\hgxcmd{mq}{qrename}---rename a patch}

The \hgxcmd{mq}{qrename} command renames a patch, and changes the entry for
the patch in the \sfilename{series} file.

With a single argument, \hgxcmd{mq}{qrename} renames the topmost applied
patch.  With two arguments, it renames its first argument to its
second.

\subsection{\hgxcmd{mq}{qrestore}---restore saved queue state}

XXX No idea what this does.

\subsection{\hgxcmd{mq}{qsave}---save current queue state}

XXX Likewise.

\subsection{\hgxcmd{mq}{qseries}---print the entire patch series}

The \hgxcmd{mq}{qseries} command prints the entire patch series from the
\sfilename{series} file.  It prints only patch names, not empty lines
or comments.  It prints in order from first to be applied to last.

\subsection{\hgxcmd{mq}{qtop}---print the name of the current patch}

The \hgxcmd{mq}{qtop} prints the name of the topmost currently applied
patch.

\subsection{\hgxcmd{mq}{qunapplied}---print patches not yet applied}

The \hgxcmd{mq}{qunapplied} command prints the names of patches from the
\sfilename{series} file that are not yet applied.  It prints them in
order from the next patch that will be pushed to the last.

\subsection{\hgcmd{strip}---remove a revision and descendants}

The \hgcmd{strip} command removes a revision, and all of its
descendants, from the repository.  It undoes the effects of the
removed revisions from the repository, and updates the working
directory to the first parent of the removed revision.

The \hgcmd{strip} command saves a backup of the removed changesets in
a bundle, so that they can be reapplied if removed in error.

Options:
\begin{itemize}
\item[\hgopt{strip}{-b}] Save unrelated changesets that are intermixed
  with the stripped changesets in the backup bundle.
\item[\hgopt{strip}{-f}] If a branch has multiple heads, remove all
  heads. XXX This should be renamed, and use \texttt{-f} to strip revs
  when there are pending changes.
\item[\hgopt{strip}{-n}] Do not save a backup bundle.
\end{itemize}

\section{MQ file reference}

\subsection{The \sfilename{series} file}

The \sfilename{series} file contains a list of the names of all
patches that MQ can apply.  It is represented as a list of names, with
one name saved per line.  Leading and trailing white space in each
line are ignored.

Lines may contain comments.  A comment begins with the ``\texttt{\#}''
character, and extends to the end of the line.  Empty lines, and lines
that contain only comments, are ignored.

You will often need to edit the \sfilename{series} file by hand, hence
the support for comments and empty lines noted above.  For example,
you can comment out a patch temporarily, and \hgxcmd{mq}{qpush} will skip
over that patch when applying patches.  You can also change the order
in which patches are applied by reordering their entries in the
\sfilename{series} file.

Placing the \sfilename{series} file under revision control is also
supported; it is a good idea to place all of the patches that it
refers to under revision control, as well.  If you create a patch
directory using the \hgxopt{mq}{qinit}{-c} option to \hgxcmd{mq}{qinit}, this
will be done for you automatically.

\subsection{The \sfilename{status} file}

The \sfilename{status} file contains the names and changeset hashes of
all patches that MQ currently has applied.  Unlike the
\sfilename{series} file, this file is not intended for editing.  You
should not place this file under revision control, or modify it in any
way.  It is used by MQ strictly for internal book-keeping.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
