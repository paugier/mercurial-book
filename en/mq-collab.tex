\chapter{Advanced uses of Mercurial Queues}

While it's easy to pick up straightforward uses of Mercurial Queues,
use of a little discipline and some of MQ's less frequently used
capabilities makes it possible to work in complicated development
environments.

In this chapter, I will use as an example a technique I have used to
manage the development of an Infiniband device driver for the Linux
kernel.  The driver in question is large (at least as drivers go),
with 25,000 lines of code spread across 35 source files.  It is
maintained by a small team of developers.

While much of the material in this chapter is specific to Linux, the
same principles apply to any code base for which you're not the
primary owner, and upon which you need to do a lot of development.

\section{The problem of many targets}

The Linux kernel changes rapidly, and has never been internally
stable; developers frequently make drastic changes between releases.
This means that a version of the driver that works well with a
particular released version of the kernel will not even \emph{compile}
correctly against, typically, any other version.

To maintain a driver, we have to keep a number of distinct versions of
Linux in mind.
\begin{itemize}
\item One target is the main Linux kernel development tree.
  Maintenance of the code is in this case partly shared by other
  developers in the kernel community, who make ``drive-by''
  modifications to the driver as they develop and refine kernel
  subsystems.
\item We also maintain a number of ``backports'' to older versions of
  the Linux kernel, to support the needs of customers who are running
  older Linux distributions that do not incorporate our drivers.  (To
  \emph{backport} a piece of code is to modify it to work in an older
  version of its target environment than the version it was developed
  for.)
\item Finally, we make software releases on a schedule that is
  necessarily not aligned with those used by Linux distributors and
  kernel developers, so that we can deliver new features to customers
  without forcing them to upgrade their entire kernels or
  distributions.
\end{itemize}

\subsection{Tempting approaches that don't work well}

There are two ``standard'' ways to maintain a piece of software that
has to target many different environments.

The first is to maintain a number of branches, each intended for a
single target.  The trouble with this approach is that you must
maintain iron discipline in the flow of changes between repositories.
A new feature or bug fix must start life in a ``pristine'' repository,
then percolate out to every backport repository.  Backport changes are
more limited in the branches they should propagate to; a backport
change that is applied to a branch where it doesn't belong will
probably stop the driver from compiling.

The second is to maintain a single source tree filled with conditional
statements that turn chunks of code on or off depending on the
intended target.  Because these ``ifdefs'' are not allowed in the
Linux kernel tree, a manual or automatic process must be followed to
strip them out and yield a clean tree.  A code base maintained in this
fashion rapidly becomes a rat's nest of conditional blocks that are
difficult to understand and maintain.

Neither of these approaches is well suited to a situation where you
don't ``own'' the canonical copy of a source tree.  In the case of a
Linux driver that is distributed with the standard kernel, Linus's
tree contains the copy of the code that will be treated by the world
as canonical.  The upstream version of ``my'' driver can be modified
by people I don't know, without me even finding out about it until
after the changes show up in Linus's tree.  

These approaches have the added weakness of making it difficult to
generate well-formed patches to submit upstream.

In principle, Mercurial Queues seems like a good candidate to manage a
development scenario such as the above.  While this is indeed the
case, MQ contains a few added features that make the job more
pleasant.

\section{Conditionally applying patches with 
  guards}

Perhaps the best way to maintain sanity with so many targets is to be
able to choose specific patches to apply for a given situation.  MQ
provides a feature called ``guards'' (which originates with quilt's
\texttt{guards} command) that does just this.  To start off, let's
create a simple repository for experimenting in.
\interaction{mq.guards.init}
This gives us a tiny repository that contains two patches that don't
have any dependencies on each other, because they touch different files.

The idea behind conditional application is that you can ``tag'' a
patch with a \emph{guard}, which is simply a text string of your
choosing, then tell MQ to select specific guards to use when applying
patches.  MQ will then either apply, or skip over, a guarded patch,
depending on the guards that you have selected.

A patch can have an arbitrary number of guards;
each one is \emph{positive} (``apply this patch if this guard is
selected'') or \emph{negative} (``skip this patch if this guard is
selected'').  A patch with no guards is always applied.

\section{Controlling the guards on a patch}

The \hgcmd{qguard} command lets you determine which guards should
apply to a patch, or display the guards that are already in effect.
Without any arguments, it displays the guards on the current topmost
patch.
\interaction{mq.guards.qguard}
To set a positive guard on a patch, prefix the name of the guard with
a ``\texttt{+}''.
\interaction{mq.guards.qguard.pos}
To set a negative guard on a patch, prefix the name of the guard with
a ``\texttt{-}''.
\interaction{mq.guards.qguard.neg}

\begin{note}
  The \hgcmd{qguard} command \emph{sets} the guards on a patch; it
  doesn't \emph{modify} them.  What this means is that if you run
  \hgcmdargs{qguard}{+a +b} on a patch, then \hgcmdargs{qguard}{+c} on
  the same patch, the \emph{only} guard that will be set on it
  afterwards is \texttt{+c}.
\end{note}

Mercurial stores guards in the \sfilename{series} file; the form in
which they are stored is easy both to understand and to edit by hand.
(In other words, you don't have to use the \hgcmd{qguard} command if
you don't want to; it's okay to simply edit the \sfilename{series}
file.)
\interaction{mq.guards.series}

\section{Selecting the guards to use}

The \hgcmd{qselect} command determines which guards are active at a
given time.  The effect of this is to determine which patches MQ will
apply the next time you run \hgcmd{qpush}.  It has no other effect; in
particular, it doesn't do anything to patches that are already
applied.

With no arguments, the \hgcmd{qselect} command lists the guards
currently in effect, one per line of output.  Each argument is treated
as the name of a guard to apply.
\interaction{mq.guards.qselect.foo}
In case you're interested, the currently selected guards are stored in
the \sfilename{guards} file.
\interaction{mq.guards.qselect.cat}
We can see the effect the selected guards have when we run
\hgcmd{qpush}.
\interaction{mq.guards.qselect.qpush}

A guard cannot start with a ``\texttt{+}'' or ``\texttt{-}''
character.  The name of a guard must start with an alphabetic
character (upper or lower case) or an underscore.  The rest of the
guard's name can contain any of these characters, or a digit.  These
rules are similar to those used for variable naming in most popular
programming languages.  If you try to use a guard with an invalid
name, MQ will complain:
\interaction{mq.guards.qselect.error}
Changing the selected guards changes the patches that are applied.
\interaction{mq.guards.qselect.quux}
You can see in the example below that negative guards take precedence
over positive guards.
\interaction{mq.guards.qselect.foobar}

\section{MQ's rules for applying patches}

The rules that MQ uses when deciding whether to apply a patch
are as follows.
\begin{itemize}
\item A patch that has no guards is always applied.
\item If the patch has any negative guard that matches any currently
  selected guard, the patch is skipped.
\item If the patch has any positive guard that matches any currently
  selected guard, the patch is applied.
\item If the patch has positive or negative guards, but none matches
  any currently selected guard, the patch is skipped.
\end{itemize}

\section{Trimming the work environment}

In working on the device driver I mentioned earlier, I don't apply the
patches to a normal Linux kernel tree.  Instead, I use a repository
that contains only a snapshot of the source files and headers that are
relevant to Infiniband development.  This repository is~1\% the size
of a kernel repository, so it's easier to work with.

I then choose a ``base'' version on top of which the patches are
applied.  This is a snapshot of the Linux kernel tree as of a revision
of my choosing.  When I take the snapshot, I record the changeset ID
from the kernel repository in the commit message.  Since the snapshot
preserves the ``shape'' and content of the relevant parts of the
kernel tree, I can apply my patches on top of either my tiny
repository or a normal kernel tree.

Normally, the base tree atop which the patches apply should be a
snapshot of a very recent upstream tree.  This best facilitates the
development of patches that can easily be submitted upstream with few
or no modifications.

\section{Dividing up the \sfilename{series} file}

I categorise the patches in the \sfilename{series} file into a number
of logical groups.  Each section of like patches begins with a block
of comments that describes the purpose of the patches that follow.

The sequence of patch groups that I maintain follows.  The ordering of
these groups is important; I'll describe why after I introduce the
groups.
\begin{itemize}
\item The ``accepted'' group.  Patches that the development team has
  submitted to the maintainer of the Infiniband subsystem, and which
  he has accepted, but which are not present in the snapshot that the
  tiny repository is based on.  These are ``read only'' patches,
  present only to transform the tree into a similar state as it is in
  the upstream maintainer's repository.
\item The ``rework'' group.  Patches that I have submitted, but that
  the upstream maintainer has requested modifications to before he
  will accept them.
\item The ``pending'' group.  Patches that I have not yet submitted to
  the upstream maintainer, but which we have finished working on.
  These will be ``read only'' for a while.  If the upstream maintainer
  accepts them upon submission, I'll move them to the end of the
  ``accepted'' group.  If he requests that I modify any, I'll move
  them to the beginning of the ``rework'' group.
\item The ``in progress'' group.  Patches that are actively being
  developed, and should not be submitted anywhere yet.
\item The ``backport'' group.  Patches that adapt the source tree to
  older versions of the kernel tree.
\item The ``do not ship'' group.  Patches that for some reason should
  never be submitted upstream.  For example, one such patch might
  change embedded driver identification strings to make it easier to
  distinguish, in the field, between an out-of-tree version of the
  driver and a version shipped by a distribution vendor.
\end{itemize}

Now to return to the reasons for ordering groups of patches in this
way.  We would like the lowest patches in the stack to be as stable as
possible, so that we will not need to rework higher patches due to
changes in context.  Putting patches that will never be changed first
in the \sfilename{series} file serves this purpose.

We would also like the patches that we know we'll need to modify to be
applied on top of a source tree that resembles the upstream tree as
closely as possible.  This is why we keep accepted patches around for
a while.

The ``backport'' and ``do not ship'' patches float at the end of the
\sfilename{series} file in part because they'll never be shipped
upstream.  Additionally, the backport patches must be applied on top
of all other patches.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
