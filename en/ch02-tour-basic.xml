<!-- vim: set filetype=docbkxml shiftwidth=2 autoindent expandtab tw=77 : -->

<chapter id="chap:tour-basic">
  <?dbhtml filename="a-tour-of-mercurial-the-basics.html"?>
  <title>A tour of Mercurial: the basics</title>

  <sect1 id="sec:tour:install">
    <title>Installing Mercurial on your system</title>

    <para id="x_1">Prebuilt binary packages of Mercurial are available for
      every popular operating system from the Mercurial website at
      <ulink url="https://mercurial.selenic.com">https://mercurial.selenic.com</ulink>.
      These make it easy to start using Mercurial
      on your computer immediately.
      Additionally, specifically for Linux, your package manager should
      include the possibility to install Mercurial.</para>

    <sect2>
      <title>Tortoisehg</title>

      <para>One of the most popular front-ends for Mercurial is TortoiseHg.
        It provides a very nice graphical interface for Mercurial,
        but also allows you to access the command line interface.
        TortoiseHg can be found at
        <ulink url="http://tortoisehg.bitbucket.org/">http://tortoisehg.bitbucket.org/</ulink>
        and is available for Windows, Mac OS X and Linux.</para>
    </sect2>

    <sect2>
      <title>Atlassian SourceTree</title>

      <para>Another popular Mercurial front-end is Atlassian SourceTree,
        which provides a nice graphical interface and can be freely downloaded
        from <ulink url="https://www.sourcetreeapp.com/">https://www.sourcetreeapp.com/</ulink>.
        Atlassian SourceTree is available for Windows and Mac OS X.</para>
    </sect2>

    <sect2>
      <title>Other choices</title>

      <para>The above only gives an overview of the most popular graphical
        interfaces for Mercurial. There are more such applications,
        and many editors, IDE's, review tools, continuous integration tools...
        have Mercurial integration as well.
        You can find an overview of these on the Mercurial wiki at
        <ulink url="https://mercurial.selenic.com/wiki/OtherTools">https://mercurial.selenic.com/wiki/OtherTools</ulink>.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Basic configuration</title>

    <para>Mercurial requires very little configuration.
      You can run quite a few commands without configuring anything.
      However, you need to configure at least your username if you wish
      to contribute yourself to a project that uses Mercurial.
    </para>

    <para>Mercurial has a number of ways to determine your username.
      The advised way for most users is through a file in your home
      directory called <filename
      role="special">.hgrc</filename>, with a <envar
      role="rc-item-ui">username</envar> entry, that will be
      used next.  To see what the contents of this file should
      look like, refer to <xref
	  linkend="sec:tour-basic:username"/>.
    </para>

    <para>Mercurial checks quite a few additional locations to determine
      what username to use.</para>

    <orderedlist>
      <listitem><para>If you specify a <option
	    role="hg-opt-commit">-u</option> or
        <option role="hg-opt-commit">--user</option> option to Mercurial commands
        that need a username, this will be used with highest priority.</para></listitem>
      <listitem><para id="x_44">If you have set the <envar>HGUSER</envar>
	    environment variable, this is checked
	    next.</para></listitem>
      <listitem><para>The above mentioned <filename role="special">.hgrc</filename>
        file is next to be checked.</para></listitem>
      <listitem><para id="x_46">If you have set the <envar>EMAIL</envar>
	    environment variable, this will be used
	    next.</para></listitem>
	<listitem><para id="x_47">Mercurial will query your system to find out
	    your local user name and host name, and construct a
	    username from these components. Since this often results
	    in a username that is not very useful, it will print a
	    warning if it has to do
	    this.</para></listitem>
      </orderedlist>
      <para id="x_48">If all of these mechanisms fail, Mercurial will
	  fail, printing an error message.  In this case, it will not
	  let you commit until you set up a
	  username.</para>

      <para id="x_49">You should think of the <envar>HGUSER</envar> environment
	variable and the <option role="hg-opt-commit">-u</option>
	option as ways to <emphasis>override</emphasis> Mercurial's
	default selection of username.  For normal use, the simplest
	and most robust way to set a username for yourself is by
	creating a <filename role="special">.hgrc</filename> file; see
	below for details.</para>

    <sect2 id="sec:tour-basic:username">
      <title>Creating a Mercurial configuration file</title>

      <para id="x_4a">To set a user name, use your favorite editor
      to create a file called <filename
      role="special">.hgrc</filename> in your home directory.
      Mercurial will use this file to look up your personalised
	  configuration settings.  The initial contents of your
	  <filename role="special">.hgrc</filename> should look like
	  this.</para>

	  <programlisting># This is a Mercurial configuration file.
[ui]
username = Firstname Lastname &lt;email.address@example.net&gt;</programlisting>

      <para id="x_4b">The <quote><literal>[ui]</literal></quote> line begins a
	  <emphasis>section</emphasis> of the config file, so you can
	  read the <quote><literal>username = ...</literal></quote>
	  line as meaning <quote>set the value of the
	    <literal>username</literal> item in the
	    <literal>ui</literal> section</quote>. A section continues
	  until a new section begins, or the end of the file.
	  Mercurial ignores empty lines and treats any text from
	  <quote><literal>#</literal></quote> to the end of a line as
	  a comment.</para>

	<tip>
	  <title><quote>Home directory</quote> on Windows</title>

	  <para id="x_716">When we refer to your home directory, on an English
	    language installation of Windows this will usually be a
	    folder named after your user name in
	    <filename>C:\Documents and Settings</filename>.  You can
	    find out the exact name of your home directory by opening
	    a command prompt window and running the following
	    command.</para>

	  <screen><prompt>C:\></prompt> <userinput>echo %UserProfile%</userinput></screen>
	</tip>
    </sect2>

    <sect2>
      <title>Choosing a user name</title>

      <para id="x_4c">You can use any text you like as the value of
      the <literal>username</literal> config item, since this
      information is for reading by other people, but will not be
      interpreted by Mercurial.  The convention that most people
      follow is to use their name and email address, as in the
      example above.</para>

      <note>
        <para id="x_4d">Mercurial's built-in web server obfuscates
        email addresses, to make it more difficult for the email
        harvesting tools that spammers use. This reduces the
        likelihood that you'll start receiving more junk email if
        you publish a Mercurial repository on the
        web.</para>
      </note>
    </sect2>
  </sect1>

  <sect1>
    <title>Getting started</title>

    <para>The Mercurial command-line interface can be used by calling
    the command <command role="hg-cmd">hg</command>.
    The symbol for the chemical element Mercury is Hg, so this only seems
    fitting.</para>

    <para id="x_e">To begin, we'll use the <command role="hg-cmd">hg
	version</command> command to find out whether Mercurial is
      installed properly. This allows us to view what Mercurial version
      we are using, but also whether we've actually properly installed
      Mercurial and can use its command-line interface.</para>

    &interaction.tour.version;

    <sect2>
      <title>Built-in help</title>

      <para id="x_f">Mercurial provides a built-in help system.  This is
	  invaluable for those times when you find yourself stuck
	  trying to remember how to run a command.  If you are
	  completely stuck, simply run <command role="hg-cmd">hg
	    help</command>; it will print a brief list of commands,
	  along with a description of what each does.  If you ask for
	  help on a specific command (as below), it prints more
	  detailed information.</para>

	&interaction.tour.help;

	<para id="x_10">For a more impressive level of detail (which you won't
	  usually need) run <command role="hg-cmd">hg help <option
	      role="hg-opt-global">-v</option></command>.  The <option
	    role="hg-opt-global">-v</option> option is short for
	  <option role="hg-opt-global">--verbose</option>, and tells
	  Mercurial to print more information than it usually
	  would.</para>

    <para>There are a few more options in the help system. For example,
      using the <option role="hg-opt-global">-k</option> or
      <option role="hg-opt-global">--keyword</option> option, you can
      search through the help system for a specific word.</para>

      &interaction.tour.help-keyword;

    </sect2>
  </sect1>
  <sect1>
    <title>Working with a repository</title>

    <para id="x_11">In Mercurial, everything happens inside a
      <emphasis>repository</emphasis>.  The repository for a project
      contains all of the files that <quote>belong to</quote> that
      project, along with a historical record of the project's
      files.</para>

    <para id="x_12">There's nothing particularly magical about a repository; it
      is simply a directory tree in your filesystem that Mercurial
      treats as special. You can rename or delete a repository any
      time you like, using either the command line or your file
      browser.</para>

    <para>There are two major types of Mercurial commands:</para>

    <itemizedlist>
      <listitem><para>The first type allows you to work on a local repository,
        doing a number of actions on your own. These commands are purely
        local commands.</para></listitem>
      <listitem><para>The second type are network operations. These
        allow you to send changes to your code to another repository,
        or retrieve new changes from somebody else.</para></listitem>
    </itemizedlist>

    <para>We will start our overview of Mercurial by looking
      at how you can use Mercurial on your own repository and expand into the network
      later on.</para>

    <sect2>
      <title>Creating your own repository</title>

      <para>Creating a repository is quite simple.
        We can use the <command>hg init</command> command to create a new
        directory, which will be our repository.</para>

      &interaction.ch01-new.init;

      <para>This simply creates a repository named
        <filename>myproject</filename> in the current directory.</para>

      &interaction.ch01-new.ls;

    </sect2>

    <sect2>
      <title>What's in a repository?</title>

      <para id="x_18">When we take a more detailed look inside a repository, we
	can see that it contains a directory named <filename
	  class="directory">.hg</filename>.  This is where Mercurial
	keeps all of its metadata for the repository.</para>

      &interaction.ch01-new.ls2;

      <para id="x_19">The contents of the <filename
	  class="directory">.hg</filename> directory and its
	subdirectories are private to Mercurial.  Every other file and
	directory in the repository is yours to do with as you
	please.</para>

      <para id="x_1a">To introduce a little terminology, the <filename
	  class="directory">.hg</filename> directory is the
	<quote>real</quote> repository, and all of the files and
	directories that coexist with it are said to live in the
	<emphasis>working directory</emphasis>.  An easy way to
	remember the distinction is that the
	<emphasis>repository</emphasis> contains the
	<emphasis>history</emphasis> of your project, while the
	<emphasis>working directory</emphasis> contains a
	<emphasis>snapshot</emphasis> of your project at a particular
	point in history.</para>

    </sect2>
    <sect2>
      <title>Adding content to the repository</title>

      <para>We currently have a repository that contains no files in its
        working directory. Suppose we add a basic file to our working directory.</para>

      &interaction.ch01-new.cat;

      <para>Mercurial's <command role="hg-cmd">hg status</command>
        command gives us a simple overview of the changed and unknown
        files in the working directory.</para>

      &interaction.ch01-new.status;

      <para>In our case, we've created a new file, but we haven't informed
        Mercurial about it yet. Since Mercurial doesn't know anything
        about this file, it's displayed with a question mark beside it.
        The file is currently an 'untracked file'.</para>

      <para>We can inform Mercurial that we wish to start tracking our
        newly created file, by using <command role="hg-cmd">hg add</command>.</para>

      &interaction.ch01-new.add-single;

      <para>Now that our file has been added, we can see that Mercurial treats
        it differently.</para>

      &interaction.ch01-new.status-added;

      <para>It's somewhat helpful to know that we've modified
        <filename>hello.c</filename>, but we might prefer to know
        exactly <emphasis>what</emphasis> changes we've made to it.  To
        do this, we use the <command role="hg-cmd">hg diff</command>
        command.</para>

      &interaction.ch01-new.diff;

      <para>Once we have a file (or multiple) that's being tracked by Mercurial,
        we can add it to our history. In Mercurial terminology,
        we call each stored 'snapshot' of history a <emphasis>changeset</emphasis>,
        because it can contain a record of changes to several files.</para>

      <para>We can create a changeset ourselves, adding our new file
        permanently to the history of our repository. We can use the
        <command role="hg-cmd">hg commit</command> command for this purpose.
        The process of creating a changeset is usually called "making a commit" or "committing".</para>

      <para>The <command role="hg-cmd">hg status</command> command already
        showed us earlier what will happen when we make a commit.
        The 'A' next to our new file specifies that our file will
        be added to the history.</para>

      &interaction.ch01-new.commit-added;

      <para>Now that we've committed our changes, we will no longer see them
        in the output of <command role="hg-cmd">hg status</command>.
        That makes sense: we usually only want to see the files
        we're currently changing. It's possible to view other things as well, though,
        and we'll go into more detail about that later.</para>

      <para>Let's change one more thing in our repository: the contents of our
        file aren't quite right. What happens if we change our file?</para>

      &interaction.ch01-new.cat-change;

      <para>Again, we can use the status and diff commands to investigate
        what has changed in the repository.</para>

      &interaction.ch01-new.changed-statusdiff;

      <para>The <quote><literal>M</literal></quote> indicates that
        Mercurial has noticed that we modified
        <filename>hello.c</filename>.  We didn't need to
        <emphasis>inform</emphasis> Mercurial that we were going to
        modify the file before we started, or that we had modified the
        file after we were done; it was able to figure this out
        itself.</para>

      <para>Once a file has been added to a repository, Mercurial will
        see any changes we make to it. There's no need to take any
        special action before committing: <command role="hg-cmd">hg commit</command>
        will save the modifications into a changeset.</para>

      <para>Besides <emphasis>status</emphasis> and <emphasis>diff</emphasis>,
        the <command role="hg-cmd">hg summary</command> command also allows
        us to quickly see what is going on in our working directory.</para>

      &interaction.ch01-new.summary;

      <para>We can see from the summary what changeset our working directory
        is based on and that a file has been modified.
        The summary contains some other information we haven't encountered
        yet, we'll go into those items later on.</para>

    </sect2>

    <sect2>
      <title>Making a local copy of a repository</title>

      <para id="x_13"><emphasis>Copying</emphasis> a repository is just a little
	bit special.  While you could use a normal file copying
	command to make a copy of a repository, it's best to use a
	built-in command that Mercurial provides.  This command is
	called <command role="hg-cmd">hg clone</command>, because it
	makes an identical copy of an existing repository.</para>

      &interaction.tour.clone;

      <para id="x_67c">One advantage of using <command role="hg-cmd">hg
	  clone</command> is that, as we can see above, it lets us clone
	repositories over the network.  Another is that it remembers
	where we cloned from, which we'll find useful soon when we
	want to fetch new changes from another repository.</para>

      <para id="x_14">If our clone succeeded, we should now have a local
	directory called <filename class="directory">hello</filename>.
	This directory will contain some files.</para>

      &interaction.tour.ls;

      <para id="x_15">These files have the same contents and history in our
	repository as they do in the repository we cloned.</para>

      <para id="x_16">Every Mercurial repository is complete,
	self-contained, and independent.  It contains its own private
	copy of a project's files and history.  As we just mentioned,
	a cloned repository remembers the location of the repository
	it was cloned from, but Mercurial will not communicate with
	that repository, or any other, unless you tell it to.</para>

      <para id="x_17">What this means for now is that we're free to experiment
	with our repository, safe in the knowledge that it's a private
	<quote>sandbox</quote> that won't affect anyone else.</para>

    <para id="x_39">The first thing we'll do is isolate our experiment in a
      repository of its own.  We use the <command role="hg-cmd">hg
	clone</command> command, but we don't need to clone a copy of
      the remote repository.  Since we already have a copy of it
      locally, we can just clone that instead.  This is much faster
      than cloning over the network, and cloning a local repository
      uses less disk space in most cases, too<footnote>
	<para id="x_681">The saving of space arises when source and destination
	  repositories are on the same filesystem, in which case
	  Mercurial will use hardlinks to do copy-on-write sharing of
	  its internal metadata.  If that explanation meant nothing to
	  you, don't worry: everything happens transparently and
	  automatically, and you don't need to understand it.</para>
	</footnote>.</para>

    &interaction.tour.reclone;

    <para id="x_3a">As an aside, it's often good practice to keep a
      <quote>pristine</quote> copy of a remote repository around,
      which you can then make temporary clones of to create sandboxes
      for each task you want to work on.  This lets you work on
      multiple tasks in parallel, each isolated from the others until
      it's complete and you're ready to integrate it back.  Because
      local clones are so cheap, there's almost no overhead to cloning
      and destroying repositories whenever you want.</para>

      <para>When we make changes, we don't have any impact on the repository
        we cloned. We can safely add a line to the local file
        <filename>hello.c</filename>:</para>

      &interaction.tour.diff;

    </sect2>
  </sect1>
  <sect1>
    <title>A tour through history</title>

    <para id="x_1b">One of the first things we might want to do with a new,
      unfamiliar repository is understand its history.  The <command
	role="hg-cmd">hg log</command> command gives us a view of
      the history of changes in the repository.</para>

    &interaction.tour.log;

    <para id="x_1c">By default, this command prints a brief paragraph of output
      for each change to the project that was recorded.  In Mercurial
      terminology, we call each of these recorded events a
      <emphasis>changeset</emphasis>, because it can contain a record
      of changes to several files.</para>

    <para id="x_1d">The fields in a record of output from <command
	role="hg-cmd">hg log</command> are as follows.</para>

    <itemizedlist>
      <listitem><para id="x_1e"><literal>changeset</literal>: This
	  field has the format of a number, followed by a colon,
	  followed by a hexadecimal (or <emphasis>hex</emphasis>)
	  string.  These are <emphasis>identifiers</emphasis> for the
	  changeset.  The hex string is a unique identifier: the same
	  hex string will always refer to the same changeset in every
	  copy of this repository. The
	  number is shorter and easier to type than the hex string,
	  but it isn't unique: the same number in two different clones
	  of a repository may identify different changesets.</para>
      </listitem>
      <listitem><para id="x_1f"><literal>user</literal>: The identity of the
	  person who created the changeset.  This is a free-form
	  field, but it most often contains a person's name and email
	  address.</para></listitem>
      <listitem><para id="x_20"><literal>date</literal>: The date and time on
	  which the changeset was created, and the timezone in which
	  it was created.  (The date and time are local to that
	  timezone; they display what time and date it was for the
	  person who created the changeset.)</para></listitem>
      <listitem><para id="x_21"><literal>summary</literal>: The first line of
	  the text message that the creator of the changeset entered
	  to describe the changeset.</para></listitem>
      <listitem>
	<para id="x_67d">Some changesets, such as the first in the list above,
	  have a <literal>tag</literal> field.  A tag is another way
	  to identify a changeset, by giving it an easy-to-remember
	  name. (The tag named <literal>tip</literal> is special: it
	  always refers to the newest change in a repository.)</para>
      </listitem>
    </itemizedlist>

    <para id="x_22">The default output printed by <command
	role="hg-cmd">hg log</command> is purely a summary; it is
      missing a lot of detail.</para>

    <para id="x_23"><xref linkend="fig:tour-basic:history"/> provides
      a graphical representation of the history of the <filename
	class="directory">hello</filename> repository, to make it a
      little easier to see which direction history is
      <quote>flowing</quote> in.  We'll be returning to this figure
      several times in this chapter and the chapter that
      follows.</para>

    <figure id="fig:tour-basic:history">
      <title>Graphical history of the <filename
	  class="directory">hello</filename> repository</title>
      <mediaobject>
	<imageobject><imagedata fileref="figs/tour-history.png"/></imageobject>
	<textobject><phrase>XXX add text</phrase></textobject>
      </mediaobject>
    </figure>

    <sect2>
      <title>Changesets, revisions, and talking to other
	people</title>

      <para id="x_25">As English is a notoriously sloppy language, and computer
	science has a hallowed history of terminological confusion
	(why use one term when four will do?), revision control has a
	variety of words and phrases that mean the same thing.  If you
	are talking about Mercurial history with other people, you
	will find that the word <quote>changeset</quote> is often
	compressed to <quote>change</quote> or (when written)
	<quote>cset</quote>, and sometimes a changeset is referred to
	as a <quote>revision</quote> or a <quote>rev</quote>.</para>

      <para id="x_26">While it doesn't matter what <emphasis>word</emphasis> you
	use to refer to the concept of <quote>a changeset</quote>, the
	<emphasis>identifier</emphasis> that you use to refer to
	<quote>a <emphasis>specific</emphasis> changeset</quote> is of
	great importance. Recall that the <literal>changeset</literal>
	field in the output from <command role="hg-cmd">hg
	  log</command> identifies a changeset using both a number and
	a hexadecimal string.</para>
      <itemizedlist>
	<listitem><para id="x_27">The revision number is a handy
	    notation that is <emphasis>only valid in that
	      repository</emphasis>.</para></listitem>
	<listitem><para id="x_28">The hexadecimal string is the
	    <emphasis>permanent, unchanging identifier</emphasis> that
	    will always identify that exact changeset in
	    <emphasis>every</emphasis> copy of the
	    repository.</para></listitem></itemizedlist>

      <para id="x_29">This distinction is important.  If you send
	someone an email talking about <quote>revision 33</quote>,
	there's a high likelihood that their revision 33 will
	<emphasis>not be the same</emphasis> as yours.  The reason for
	this is that a revision number depends on the order in which
	changes arrived in a repository, and there is no guarantee
	that the same changes will happen in the same order in
	different repositories. Three changes <literal>a,b,c</literal>
	can easily appear in one repository as
	<literal>0,1,2</literal>, while in another as
	<literal>0,2,1</literal>.</para>

      <para id="x_2a">Mercurial uses revision numbers purely as a convenient
	shorthand.  If you need to discuss a changeset with someone,
	or make a record of a changeset for some other reason (for
	example, in a bug report), use the hexadecimal
	identifier.</para>

    </sect2>
    <sect2>
      <title>Viewing specific revisions</title>

      <para id="x_2b">To narrow the output of <command role="hg-cmd">hg
	  log</command> down to a single revision, use the <option
	  role="hg-opt-log">-r</option> (or <option
	  role="hg-opt-log">--rev</option>) option.  You can use
	either a revision number or a hexadecimal identifier,
	and you can provide as many revisions as you want.</para>

      &interaction.tour.log-r;

      <para id="x_2c">If you want to see the history of several revisions
	without having to list each one, you can use <emphasis>range
	  notation</emphasis>; this lets you express the idea <quote>I
	  want all revisions between <literal>abc</literal> and
	  <literal>def</literal>, inclusive</quote>.</para>
      
	&interaction.tour.log.range;

      <para id="x_2d">Mercurial also honours the order in which you specify
	revisions, so <command role="hg-cmd">hg log -r 2:4</command>
	prints 2, 3, and 4. while <command role="hg-cmd">hg log -r
	  4:2</command> prints 4, 3, and 2.</para>

    </sect2>
    <sect2>
      <title>More detailed information</title>

      <para id="x_2e">While the summary information printed by <command
	  role="hg-cmd">hg log</command> is useful if you already know
	what you're looking for, you may need to see a complete
	description of the change, or a list of the files changed, if
	you're trying to decide whether a changeset is the one you're
	looking for. The <command role="hg-cmd">hg log</command>
	command's <option role="hg-opt-global">-v</option> (or <option
	  role="hg-opt-global">--verbose</option>) option gives you
	this extra detail.</para>

      &interaction.tour.log-v;

      <para id="x_2f">If you want to see both the description and
	content of a change, add the <option
	  role="hg-opt-log">-p</option> (or <option
	  role="hg-opt-log">--patch</option>) option.  This displays
	the content of a change as a <emphasis>unified diff</emphasis>
	(if you've never seen a unified diff before, see <xref
	  linkend="sec:mq:patch"/> for an overview).</para>

      &interaction.tour.log-vp;

      <para id="x_67e">The <option role="hg-opt-log">-p</option> option is
	tremendously useful, so it's well worth remembering.</para>

    </sect2>
  </sect1>

  <sect1>
    <title>All about command options</title>

    <para id="x_30">Let's take a brief break from exploring Mercurial commands
      to discuss a pattern in the way that they work; you may find
      this useful to keep in mind as we continue our tour.</para>

    <para id="x_31">Mercurial has a consistent and straightforward approach to
      dealing with the options that you can pass to commands.  It
      follows the conventions for options that are common to modern
      Linux and Unix systems.</para>

    <itemizedlist>
      <listitem>
	<para id="x_32">Every option has a long name.  For example, as
	  we've already seen, the <command role="hg-cmd">hg
	    log</command> command accepts a <option
	    role="hg-opt-log">--rev</option> option.</para>
      </listitem>
      <listitem>
	<para id="x_33">Most options have short names, too.  Instead
	  of <option role="hg-opt-log">--rev</option>, we can use
	  <option role="hg-opt-log">-r</option>.  (The reason that
	  some options don't have short names is that the options in
	  question are rarely used.)</para>
      </listitem>
      <listitem>
	<para id="x_34">Long options start with two dashes (e.g.
	  <option role="hg-opt-log">--rev</option>), while short
	  options start with one (e.g. <option
	    role="hg-opt-log">-r</option>).</para>
      </listitem>
      <listitem>
	<para id="x_35">Option naming and usage is consistent across
	  commands.  For example, every command that lets you specify
	  a changeset ID or revision number accepts both <option
	    role="hg-opt-log">-r</option> and <option
	    role="hg-opt-log">--rev</option> arguments.</para>
      </listitem>
      <listitem>
	<para id="x_67f">If you are using short options, you can save typing by
	  running them together. For example, the command <command
	    role="hg-cmd">hg log -v -p -r 2</command> can be written
	  as <command role="hg-cmd">hg log -vpr2</command>.</para>
      </listitem>
    </itemizedlist>

    <para id="x_36">In the examples throughout this book, I usually
      use short options instead of long.  This simply reflects my own
      preference, so don't read anything significant into it.</para>

    <para id="x_37">Most commands that print output of some kind will print more
      output when passed a <option role="hg-opt-global">-v</option>
      (or <option role="hg-opt-global">--verbose</option>) option, and
      less when passed <option role="hg-opt-global">-q</option> (or
      <option role="hg-opt-global">--quiet</option>).</para>

    <note>
      <title>Option naming consistency</title>

      <para id="x_680">Almost always, Mercurial commands use consistent option
	names to refer to the same concepts.  For instance, if a
	command deals with changesets, you'll always identify them
	with <option role="hg-opt-log">--rev</option> or <option
	  role="hg-opt-log">-r</option>.  This consistent use of
	option names makes it easier to remember what options a
	particular command takes.</para>
    </note>

  </sect1>
  <sect1>
    <title>Good commit practices</title>

    <sect2>
      <title>Writing a commit message</title>

      <para id="x_4e">When we commit a change, Mercurial drops us into
	a text editor, to enter a message that will describe the
	modifications we've made in this changeset.  This is called
	the <emphasis>commit message</emphasis>.  It will be a record
	for readers of what we did and why, and it will be printed by
	<command role="hg-cmd">hg log</command> after we've finished
	committing.</para>

       &interaction.tour.commit;

      <para id="x_4f">The editor that the <command role="hg-cmd">hg
	  commit</command> command drops us into will contain an empty
	line or two, followed by a number of lines starting with
	<quote><literal>HG:</literal></quote>.</para>

    <programlisting>
This is where I type my commit comment.

HG: Enter commit message.  Lines beginning with 'HG:' are removed.
HG: --
HG: user: Bryan O'Sullivan &lt;bos@serpentine.com&gt;
HG: branch 'default'
HG: changed hello.c</programlisting>

      <para id="x_50">Mercurial ignores the lines that start with
	<quote><literal>HG:</literal></quote>; it uses them only to
	tell us which files it's recording changes to.  Modifying or
	deleting these lines has no effect.</para>
    </sect2>
    <sect2>
      <title>Writing a good commit message</title>

      <para id="x_51">Since <command role="hg-cmd">hg log</command>
	only prints the first line of a commit message by default,
	it's best to write a commit message whose first line stands
	alone.  Here's a real example of a commit message that
	<emphasis>doesn't</emphasis> follow this guideline, and hence
	has a summary that is not readable.</para>

      <programlisting>
changeset:   73:584af0e231be
user:        Censored Person &lt;censored.person@example.org&gt;
date:        Tue Sep 26 21:37:07 2006 -0700
summary:     include buildmeister/commondefs. Add exports.</programlisting>

      <para id="x_52">As far as the remainder of the contents of the
	commit message are concerned, there are no hard-and-fast
	rules.  Mercurial itself doesn't interpret or care about the
	contents of the commit message, though your project may have
	policies that dictate a certain kind of formatting.</para>
      <para id="x_53">My personal preference is for short, but
	informative, commit messages that tell me something that I
	can't figure out with a quick glance at the output of <command
	  role="hg-cmd">hg log --patch</command>.</para>
      <para id="x_55">If we run the <command role="hg-cmd">hg
	  commit</command> command without any arguments, it records
	all of the changes we've made, as reported by <command
	  role="hg-cmd">hg status</command> and <command
	  role="hg-cmd">hg diff</command>.</para>

      <note>
	<title>A surprise for Subversion users</title>

	<para id="x_717">Like other Mercurial commands, if we don't supply
	  explicit names to commit to the <command role="hg-cmd">hg
	    commit</command>, it will operate across a repository's
	  entire working directory.  Be wary of this if you're coming
	  from the Subversion or CVS world, since you might expect it
	  to operate only on the current directory that you happen to
	  be visiting and its subdirectories.</para>
      </note>
    </sect2>

    <sect2>
      <title>Aborting a commit</title>

      <para id="x_54">If you decide that you don't want to commit
	while in the middle of editing a commit message, simply exit
	from your editor without saving the file that it's editing.
	This will cause nothing to happen to either the repository or
	the working directory.</para>
    </sect2>

    <sect2>
      <title>Admiring our new handiwork</title>

      <para id="x_56">Once we've finished the commit, we can use the
	<command role="hg-cmd">hg log --rev .</command> command to display the
	changeset we just created.  In this command, the '.' specifies
    that we want to view the current changeset. In other words,
    it will show us what we just committed.</para>

      &interaction.tour.tip-log;

    </sect2>
  </sect1>

  <sect1>
    <title>Sharing changes</title>

    <para id="x_58">We mentioned earlier that repositories in
      Mercurial are self-contained.  This means that the changeset we
      just created exists only in our <filename
	class="directory">my-hello</filename> repository.  Let's look
      at a few ways that we can propagate this change into other
      repositories.</para>

    <sect2 id="sec:tour:pull">
      <title>Pulling changes from another repository</title>

      <para id="x_59">To get started, let's clone our original
	<filename class="directory">hello</filename> repository, which
	does not contain the change we just committed.  We'll call our
	temporary repository <filename
	  class="directory">hello-pull</filename>.</para>

      &interaction.tour.clone-pull;

      <para id="x_5a">We'll use the <command role="hg-cmd">hg
	  pull</command> command to bring changes from <filename
	  class="directory">my-hello</filename> into <filename
	  class="directory">hello-pull</filename>.  However, blindly
	pulling unknown changes into a repository is a somewhat scary
	prospect.  Mercurial provides the <command role="hg-cmd">hg
	  incoming</command> command to tell us what changes the
	<command role="hg-cmd">hg pull</command> command
	<emphasis>would</emphasis> pull into the repository, without
	actually pulling the changes in.</para>

      &interaction.tour.incoming;

      <para id="x_5c">Bringing changes into a repository is a simple
	matter of running the <command role="hg-cmd">hg pull</command>
	command, and optionally telling it which repository to pull from.</para>

      &interaction.tour.pull;

      <para id="x_5d">As you can see from the before-and-after output, we have
	successfully pulled changes into our repository.  However,
	Mercurial separates pulling changes in from updating the
	working directory. There remains one step before we will see
	the changes that we just pulled appear in the working
	directory.</para>

      <tip>
	<title>Pulling specific changes</title>

	<para id="x_5b">It is possible that due to the delay between
	  running <command role="hg-cmd">hg incoming</command> and
	  <command role="hg-cmd">hg pull</command>, you may not see
	  all changesets that will be brought from the other
	  repository. Suppose you're pulling changes from a repository
	  on the network somewhere. While you are looking at the
	  <command role="hg-cmd">hg incoming</command> output, and
	  before you pull those changes, someone might have committed
	  something in the remote repository. This means that it's
	  possible to pull more changes than you saw when using
	  <command role="hg-cmd">hg incoming</command>.</para>

	<para id="x_718">If you only want to pull precisely the changes that were
	  listed by <command role="hg-cmd">hg incoming</command>, or
	  you have some other reason to pull a subset of changes,
	  simply identify the change that you want to pull by its
	  changeset ID, e.g. <command>hg pull
	    -r7e95bb</command>.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Updating the working directory</title>

      <para id="x_5e">We have so far glossed over the relationship
	between a repository and its working directory.  The <command
	  role="hg-cmd">hg pull</command> command that we ran in
	<xref linkend="sec:tour:pull"/> brought changes into the
	repository, but if we check, there's no sign of those changes
	in the working directory.  This is because <command
	  role="hg-cmd">hg pull</command> does not (by default) touch
	the working directory.  Instead, we use the <command
	  role="hg-cmd">hg update</command> command to do this.</para>

      &interaction.tour.update;

      <para id="x_5f">It might seem a bit strange that <command
	  role="hg-cmd">hg pull</command> doesn't update the working
	directory automatically.  There's actually a good reason for
	this: you can use <command role="hg-cmd">hg update</command>
	to update the working directory to the state it was in at
	<emphasis>any revision</emphasis> in the history of the
	repository.  If you had the working directory updated to an
	old revision&emdash;to hunt down the origin of a bug,
	say&emdash;and ran a <command role="hg-cmd">hg pull</command>
	which automatically updated the working directory to a new
	revision, you might not be terribly happy.</para>

      <para id="x_60">Since pull-then-update is such a common sequence
	of operations, Mercurial lets you combine the two by passing
	the <option role="hg-opt-pull">-u</option> option to <command
	  role="hg-cmd">hg pull</command>.</para>

      <para id="x_61">If you look back at the output of <command
	  role="hg-cmd">hg pull</command> in <xref
	    linkend="sec:tour:pull"/> when we ran it without <option
	  role="hg-opt-pull">-u</option>, you can see that it printed
	a helpful reminder that we'd have to take an explicit step to
	update the working directory.</para>

      <para id="x_62">To find out what revision the working directory
	is at, use the <command role="hg-cmd">hg parents</command>
	command.</para>

      &interaction.tour.parents;

      <para id="x_63">If you look back at <xref
	  linkend="fig:tour-basic:history"/>, you'll see arrows
	connecting each changeset.  The node that the arrow leads
	<emphasis>from</emphasis> in each case is a parent, and the
	node that the arrow leads <emphasis>to</emphasis> is its
	child.  The working directory has a parent in just the same
	way; this is the changeset that the working directory
	currently contains.</para>

      <para id="x_64">To update the working directory to a particular
	revision, give a revision number or changeset ID to the
	<command role="hg-cmd">hg update</command> command.</para>

      &interaction.tour.older;

      <para id="x_65">If you omit an explicit revision, <command
	  role="hg-cmd">hg update</command> will update to the tip
	revision, as shown by the second call to <command
	  role="hg-cmd">hg update</command> in the example
	above.</para>
    </sect2>

    <sect2>
      <title>Pushing changes to another repository</title>

      <para id="x_66">Mercurial lets us push changes to another
	repository, from the repository we're currently visiting. As
	with the example of <command role="hg-cmd">hg pull</command>
	above, we'll create a temporary repository to push our changes
	into.</para>

      &interaction.tour.clone-push;

      <para id="x_67">The <command role="hg-cmd">hg outgoing</command>
	command tells us what changes would be pushed into another
	repository.</para>

      &interaction.tour.outgoing;

      <para id="x_68">And the <command role="hg-cmd">hg push</command>
	command does the actual push.</para>

      &interaction.tour.push;

      <para id="x_69">As with <command role="hg-cmd">hg
	  pull</command>, the <command role="hg-cmd">hg push</command>
	command does not update the working directory in the
	repository that it's pushing changes into. Unlike <command
	  role="hg-cmd">hg pull</command>, <command role="hg-cmd">hg
	  push</command> does not provide a <literal>-u</literal>
	option that updates the other repository's working directory.
	This asymmetry is deliberate: the repository we're pushing to
	might be on a remote server and shared between several people.
	If we were to update its working directory while someone was
	working in it, their work would be disrupted.</para>

      <para id="x_6a">What happens if we try to pull or push changes
	  and the receiving repository already has those changes?
	  Nothing too exciting.</para>

      &interaction.tour.push.nothing;
    </sect2>

    <sect2>
      <title>Default locations</title>

      <para id="x_719">When we clone a repository, Mercurial records the location
	of the repository we cloned in the
	<filename>.hg/hgrc</filename> file of the new repository.  If
	we don't supply a location to <command>hg pull</command> from
	or <command>hg push</command> to, those commands will use this
	location as a default.  The <command>hg incoming</command>
	and <command>hg outgoing</command> commands do so too.</para>

      <para id="x_71a">If you open a repository's <filename>.hg/hgrc</filename>
	file in a text editor, you will see contents like the
	following.</para>

      <programlisting>[paths]
default = http://www.selenic.com/repo/hg</programlisting>

      <para id="x_71b">It is possible&emdash;and often useful&emdash;to have the
	default location for <command>hg push</command> and
	<command>hg outgoing</command> be different from those for
	<command>hg pull</command> and <command>hg incoming</command>.
	We can do this by adding a <literal>default-push</literal>
	entry to the <literal>[paths]</literal> section of the
	<filename>.hg/hgrc</filename> file, as follows.</para>

      <programlisting>[paths]
default = http://www.selenic.com/repo/hg
default-push = http://hg.example.com/hg</programlisting>
    </sect2>

    <sect2>
      <title>Sharing changes over a network</title>

      <para id="x_6b">The commands we have covered in the previous few
	  sections are not limited to working with local repositories.
	  Each works in exactly the same fashion over a network
	  connection; simply pass in a URL instead of a local
	  path.</para>
	
      &interaction.tour.outgoing.net;

      <para id="x_6c">In this example, we can see what changes we
	could push to the remote repository, but the repository is
	understandably not set up to let anonymous users push to
	it.</para>

    </sect2>
  </sect1>
  <sect1>
    <title>Conclusion</title>

    <para id="x_721">It takes just a few moments to start using Mercurial on a
      new project, which is part of its appeal. Revision control is
      now so easy to work with, we can use it on the smallest of
      projects that we might not have considered with a more
      complicated tool.</para>
  </sect1>
</chapter>

<!--
local variables: 
sgml-parent-document: ("00book.xml" "book" "chapter")
end:
-->
