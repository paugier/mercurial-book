\chapter{Finding and fixing your mistakes}
\label{chap:undo}

To err might be human, but to really handle the consequences well
takes a top-notch revision control system.  In this chapter, we'll
discuss some of the techniques you can use when you find that a
problem has crept into your project.  Mercurial has some highly
capable features that will help you to isolate the sources of
problems, and to handle them appropriately.

\section{Erasing local history}

\subsection{The accidental commit}

I have the occasional but persistent problem of typing rather more
quickly than I can think, which sometimes results in me committing a
changeset that is either incomplete or plain wrong.  In my case, the
usual kind of incomplete changeset is one in which I've created a new
source file, but forgotten to \hgcmd{add} it.  A ``plain wrong''
changeset is not as common, but no less annoying.

\subsection{Rolling back a transaction}

In section~\ref{sec:concepts:txn}, I mentioned that Mercurial treats
each modification of a repository as a \emph{transaction}.  Every time
you commit a changeset or pull changes from another repository,
Mercurial remembers what you did.  You can undo, or \emph{roll back},
exactly one of these actions using the \hgcmd{rollback} command.

Here's a mistake that I often find myself making: committing a change
in which I've created a new file, but forgotten to \hgcmd{add} it.
\interaction{rollback.commit}
Looking at the output of \hgcmd{status} after the commit immediately
confirms the error.
\interaction{rollback.status}
The commit captured the changes to the file \filename{a}, but not the
new file \filename{b}.  If I were to push this changeset to a
repository that I shared with a colleague, the chances are high that
something in \filename{a} would refer to \filename{b}, which would not
be present in their repository when they pulled my changes.  I would
thus become the object of some indignation.

However, luck is with me---I've caught my error before I pushed the
changeset.  I use the \hgcmd{rollback} command, and Mercurial makes
that last changeset vanish.
\interaction{rollback.rollback}
Notice that the changeset is no longer present in the repository's
history, and the working directory once again thinks that the file
\filename{a} is modified.  The commit and rollback have left the
working directory exactly as it was prior to the commit; the changeset
has been completely erased.  I can now safely \hgcmd{add} the file
\filename{b}, and rerun my commit.
\interaction{rollback.add}

\subsection{The erroneous pull}

It's common practice with Mercurial to maintain separate development
branches of a project in different repositories.  Your development
team might have one shared repository for your project's ``0.9''
release, and another, containing different changes, for the ``1.0''
release.

Given this, you can imagine that the consequences could be messy if
you had a local ``0.9'' repository, and accidentally pulled changes
from the shared ``1.0'' repository into it.  At worst, you could be
paying insufficient attention, and push those changes into the shared
``0.9'' tree, confusing your entire team (but don't worry, we'll
return to this horror scenario later).  However, it's more likely that
you'll notice immediately, because Mercurial will display the URL it's
pulling from, or you will see it pull a suspiciously large number of
changes into the repository.

The \hgcmd{rollback} command will work nicely to expunge all of the
changesets that you just pulled.  Mercurial groups all changes from
one \hgcmd{pull} into a single transaction, so one \hgcmd{rollback} is
all you need to undo this mistake.

\subsection{Rolling back is useless once you've pushed}

The value of the \hgcmd{rollback} command drops to zero once you've
pushed your changes to another repository.  Rolling back a change
makes it disappear entirely, but \emph{only} in the repository in
which you perform the \hgcmd{rollback}.  Because a rollback eliminates
history, there's no way for the disappearance of a change to propagate
between repositories.

If you've pushed a change to another repository---particularly if it's
a shared repository---it has essentially ``escaped into the wild,''
and you'll have to recover from your mistake in a different way.  What
will happen if you push a changeset somewhere, then roll it back, then
pull from the repository you pushed to, is that the changeset will
reappear in your repository.

(If you absolutely know for sure that the change you want to roll back
is the most recent change in the repository that you pushed to,
\emph{and} you know that nobody else could have pulled it from that
repository, you can roll back the changeset there, too, but you really
should really not rely on this working reliably.  If you do this,
sooner or later a change really will make it into a repository that
you don't directly control (or have forgotten about), and come back to
bite you.)

\subsection{You can only roll back once}

Mercurial stores exactly one transaction in its transaction log; that
transaction is the most recent one that occurred in the repository.
This means that you can only roll back one transaction.  If you expect
to be able to roll back one transaction, then its predecessor, this is
not the behaviour you will get.
\interaction{rollback.twice}
Once you've rolled back one transaction in a repository, you can't
roll back again in that repository until you perform another commit or
pull.

\section{Reverting the mistaken change}

If you make a modification to a file, and decide that you really
didn't want to change the file at all, the \hgcmd{revert} command is
the one you'll need.  It looks at the changeset that's the parent of
the working directory, and restores the contents of the file to their
state as of that changeset.  (That's a long-winded way of saying that,
in the normal case, it undoes your modifications.)

Let's illustrate how the \hgcmd{revert} command works with yet another
small example.  We'll begin by modifying a file that Mercurial is
already tracking.
\interaction{daily.revert.modify}
If we don't want that change, we can simply \hgcmd{revert} the file.
\interaction{daily.revert.unmodify}
The \hgcmd{revert} command provides us with an extra degree of safety
by saving our modified file with a \filename{.orig} extension.
\interaction{daily.revert.status}

\subsection{File management errors}
\label{sec:undo:mgmt}

The \hgcmd{revert} command is useful for more than just modified
files.  It lets you reverse the results of all of Mercurial's file
management commands---\hgcmd{add}, \hgcmd{remove}, and so on.

If you \hgcmd{add} a file, then decide that in fact you don't want
Mercurial to track it, use \hgcmd{revert} to undo the add.  Don't
worry; Mercurial will not modify the file in any way.  It will just
``unmark'' the file.
\interaction{daily.revert.add}

Similarly, if you ask Mercurial to \hgcmd{remove} a file, you can use
\hgcmd{revert} to restore it to the contents it had as of the parent
of the working directory.
\interaction{daily.revert.remove}
This works just as well for a file that you deleted by hand, without
telling Mercurial (recall that in Mercurial terminology, this kind of
file is called ``missing'').
\interaction{daily.revert.missing}

If you revert a \hgcmd{copy}, the copied-to file remains in your
working directory afterwards, untracked.  Since a copy doesn't affect
the copied-from file in any way, Mercurial doesn't do anything with
the copied-from file.
\interaction{daily.revert.copy}

\subsubsection{A slightly special case: reverting a rename}

If you \hgcmd{rename} a file, there is one small detail that
you should remember.  When you \hgcmd{revert} a rename, it's not
enough to provide the name of the renamed-to file, as you can see
here.
\interaction{daily.revert.rename}
As you can see from the output of \hgcmd{status}, the renamed-to file
is no longer identified as added, but the renamed-\emph{from} file is
still removed!  This is counter-intuitive (at least to me), but at
least it's easy to deal with.
\interaction{daily.revert.rename-orig}
So remember, to revert a \hgcmd{rename}, you must provide \emph{both}
the source and destination names.  

(By the way, if you rename a file, then modify the renamed-to file,
then revert both components of the rename, when Mercurial restores the
file that was removed as part of the rename, it will be unmodified.
If you need the modifications in the renamed-to file to show up in the
renamed-from file, don't forget to copy them over.)

These fiddly aspects of reverting a rename arguably constitute a small
bug in Mercurial.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
