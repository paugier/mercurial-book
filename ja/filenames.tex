\chapter{File names and pattern matching}
\label{chap:names}

Mercurial は、
一貫性と表現力を兼ね備えた方法でファイル名を扱う仕組みを提供しています。

\section{Simple file naming}

Mercurial は
``under the hood''において、
ファイル名を取り扱う統一された仕組みを用いています。
ファイル名に関する全てのコマンドの挙動は統一されています。
ファイル名に対するコマンドの挙動は、以下のようになっています。

コマンド行で実ファイル名を明示的に指定した場合、
Mercurial は指定されたファイル名に厳密に作用します。

\interaction{filenames.files}

ディレクトリ名を指定した場合、
Mercurial はその指定を、
``当該ディレクトリならびにサブディレクトリ中の全てのファイル''
とみなします。
Mercurial は当該ディレクトリ配下のファイル・サブディレクトリを、
アルファベット順に走査します。
あるディレクトリの走査中にサブディレクトリに遭遇した場合、
当該ディレクトリの走査よりも先に、
サブディレクトリの走査を実施します\footnote{訳注: 深さ優先（depth first）}。

\interaction{filenames.dirs}

\section{Running commands without any file names}

ファイル名を引数に取る Mercurial コマンドは、
引数ないしパターン指定無しで起動された場合も、
有用な基底時動作が定められています。
コマンドに期待される振る舞いは、
コマンドの用途に依存します。
ファイル名指定無しの起動において、
コマンドがどのように振舞うのかを推測するための、
一般的な目安となる幾つかのルールを以下に示します。

\begin{itemize}
\item 殆どのコマンドは作業領域ディレクトリ全体に作用します。
  例えば、\hgcmd{add} コマンドなどがそうです。

\item 復旧が困難あるいは不可能な作用を及ぼすコマンドの場合、
  少なくとも１つ以上の名前ないしパターン（後述します）
  の明示的な指定を求める筈です。
  この挙動により、
  例えば引数無しの \hgcmd{remove} 起動のような、
  不慮の事態によるファイルの削除等を防ぐことができます。

\end{itemize}

この振る舞いがそぐわない状況であれば、
簡単に振る舞いを変えることができます。
作業領域ディレクトリ全体に作用するコマンドであれば、
``\dirname{.}'' を指定することで、
コマンドの作用を現在のディレクトリおよびその配下に限定することができます。

\interaction{filenames.wdir-subdir}

ルート以外のディレクトリでコマンドを実行した場合でも、
リポジトリのルートに対する相対的なファイル名を表示するコマンドもあります。
このようなコマンドは、
明示的な名前を指定することで、
現在のディレクトリ位置に対する相対的なファイル名を表示するようになります。
非ルートディレクトリでの \hgcmd{status} 起動の際に
\hgcmd{root} コマンドの出力を指定することで、
対象を作業領域ディレクトリ全体に維持したまま、
現在のディレクトリ位置に対する相対的なファイル名を表示させることができます。

\interaction{filenames.wdir-relname}

\section{Telling you what's going on}

先の節における \hgcmd{add} コマンド実行例は、
Mercurial コマンドに関するもう一つの有益な事柄を示しています。
コマンド行で明示的な指定をしていないファイルに対してコマンドが作用する場合、
通常は対象ファイル名を表示しますので、
思わぬコマンドの実行結果に後から驚かされることはありません。

これは\emph{驚きを最小}にする原則に則ったものです。
コマンド行で厳密なファイル名を指定した場合には、
それを復唱する必要は無いでしょう。
ファイル名・ディレクトリ名ないしパターン（後述します）
を指定しないことで\emph{暗に指定された}対象ファイルに
Mercurial が作用する場合、
どのファイルを対象とするのかを通知するのは安全性の上で有用です。

上記方針に沿って振舞うコマンド群は、
\hggopt{-q} オプションを指定することで、
その出力を抑止することができます。
明示的にファイル名等を指定した場合でも、
\hggopt{-v} オプションを指定することで、
全ての対象ファイル名を表示させることができます。

\section{Using patterns to identify files}

ファイル名・ディレクトリ名による指定に加えて、
Mercurial では\emph{パターン}によるファイル指定機能が使用できます。
Mercurial のパターン操作は表現力に富んだものです。

Linux や MacOS のような Unix 的システムでは、
ファイル名とパターンとの間の突合せは通常シェルがその役目を負います。
これらのシステムでは、
パターンを指定している旨を 
Mercurial に対して明示的に指示する必要があります\footnote{訳注:
シェルによる特殊文字展開の抑止の話であれば、
``Mercurial に対して''ではなく、
``シェルに対して''なのでは？
それとも Windows バイナリ版では振る舞いが異なる？}。
Windows においては、
シェルによるパターンの展開が行われませんので、
Mercurial は自動的に指定されたものがパターンであると認識し、
ファイル名へと展開します。

コマンド行において、
ファイル名を指定する場所でパターンを使用するには、
以下のように記述します。

\begin{codesample2}
  syntax:patternbody
\end{codesample2}

パターンの記述は、
パターンの種類を識別するための短い文字列、コロン、
そして実際のパターンを連結したものです。

Mercurial は２種類のパターン形式に対応しています。
最も利用頻度が高いものは \texttt{glob} と呼ばれ、
Unix のシェルによるパターンマッチングと同様の機能を持つもので、
その振る舞いは Windows のコマンドプロンプトユーザにも馴染みがあることでしょう。

Windows において
Mercurial が自動的にパターンマッチングを行う場合、
\texttt{glob} 形式とみなされます。
そのため、
Windows においては ``\texttt{glob:}'' 接頭辞を省略可能ですが、
明示的に指定することも可能です。

\texttt{re} 形式は、
\texttt{glob} 形式よりも強力で、
regexps としても知られる正規表現を使用したパターンの記述が可能です。

ちなみに、以降の例では、
全てのパターン指定を注意深く引用符で囲むことで、
Mercurial の処理の前にシェルによって展開されてしまうことを防いでいる、
という点に注意してください。

\subsection{Shell-style \texttt{glob} patterns}

\texttt{glob} 形式によるマッチングの際に、
使用可能なパターンについての概要を以下に示します。

パターン ``\texttt{*}'' は、
同一ディレクトリ内で任意の文字列に合致します。

\interaction{filenames.glob.star}

パターン ``\texttt{**}'' は、
ディレクトリ境界を超えて任意の文字列に合致します。
このパターンは Unix における標準的なものではありませんが、
幾つかの著名なシェル実装で採用されており、
非常に便利です。

\interaction{filenames.glob.starstar}

パターン ``\texttt{?}'' は、
単一の文字に合致します。

\interaction{filenames.glob.question}

パターン ``\texttt{[}'' は、
\emph{文字集合}（character class）の開始を意味します。
このパターンは当該集合に属する任意の一文字に合致します。
集合指定は ``\texttt{]}'' によって終了します。
集合指定には、
``\texttt{abcdef}'' の省略指定である
``\texttt{a-f}'' 形式の\emph{範囲}指定を、
複数含めることが可能です。

\interaction{filenames.glob.range}

文字集合指定において
``\texttt{[}'' の直後の文字が ``\texttt{!}'' \footnote{訳注:
正規表現における ``\texttt{\^}'' による反転と異なる点に注意}の場合、
集合指定は\emph{反転}され、
集合に属さない任意の一文字に合致します。

パターン ``\texttt{\{}'' はサブパターンのグループ化の開始を意味し、
グループ中の何れかのサブパターンが合致した場合は、
グループ全体が合致したものとみなされます。
グループ指定におけるサブパターンの区切りには
``\texttt{,}'' が使用され、
``\texttt{\}}'' がグループの終了を意味します。

\interaction{filenames.glob.group}

\subsubsection{Watch out!}

任意のディレクトリにおけるパターン合致が必要な場合は、
単一ディレクトリ内でのマッチングしか行わない
``\texttt{*}'' を使用すべきでは無い、
という点は忘れないようにしてください。
``\texttt{*}'' の代わりに ``\texttt{**}'' を使用しましょう。
両者の違いを以下で説明します。

\interaction{filenames.glob.star-starstar}

\subsection{Regular expression matching with \texttt{re} patterns}

Mercurial は（Python の内部的な正規表現エンジンを利用しているので）
Python が受け付けるのと同じ正規表現を受け付けます。
この正規表現は Perl の正規表現文法を基にしており、
最も多用されている（例えば Java でも使用されています）方言です。

正規表現パターンはそれほど多用されるものではないので、
Mercurial の正規表現の詳細に関してここでは説明しません。
Perl 形式の正規表現は様々な形式で、
多くのウェブサイトや出版物において余す所無く説明されています。
その代わりここでは、
Mercurial で正規表現を使用する必要に迫られた際に、
知っておくべき幾つかの事柄について説明しようとおもいます。

正規表現は、
リポジトリルートからの相対的なファイル名全体に対して適用されます。
言い換えるなら、
\dirname{foo} サブディレクトリで作業している場合でも、
このディレクトリ配下のファイルに対してマッチングを行うなら、
指定するパターンは
``\texttt{foo/}'' で始まっていなければなりません。

Perl 形式の正規表現に馴染んでいる場合、
Mercurial の正規表現は \emph{rooted} である点に注意してください\footnote{訳注: 
暗黙のうちに ``\texttt{\^}'' が付与される、と理解すれば良いでしょう。}。
正規表現は文字列先頭からマッチングを実施しますので、
文字列途中に対するマッチングは行われません。
任意の位置に対してマッチングを実施させたい場合、
パターンの記述を ``\texttt{.*}'' で始める必要があります。

\section{Filtering files}

Mercurial が多様な方法を提供しているものは、
ファイルの指定方法だけではありません。
Mercurial は\emph{フィルタ}によるファイル選別の機能も提供しています。
ファイル名指定を受け付けるコマンドは、
以下の２つのフィルタリングオプションも受け付けます。

\begin{itemize}
\item \hggopt{-I} ないし \hggopt{--include} により、
  合致したファイルのみを処理対象とみなすパターンを指定できます。

\item \hggopt{-X} ないし \hggopt{--exclude} により、
  合致したファイルを処理対象から\emph{除外}するパターンを指定できます。

\end{itemize}

複数の \hggopt{-I} および \hggopt{-X} オプションを、
コマンド行で好きなように混在させることができます。
Mercurial の基底動は、
指定されたパターンを ``\texttt{glob}'' 形式とみなして解釈します
（必要であれば明示的に ``\texttt{glob}'' を指定することも可能です）。

\hggopt{-I} フィルタは、
``合致したファイルのみを処理対象とする''
ものと解釈すれば良いでしょう。

\interaction{filenames.filter.include}

\hggopt{-X} フィルタは、
``合致しないものを処理対象とする''
ものと解釈することができます。

\interaction{filenames.filter.exclude}

\section{Ignoring unwanted files and directories}

※ 原文未稿

\section{Case sensitivity}
\label{sec:names:case}

Linux（ないし他の Unix 系 OS）と、
MacOS ないし Windows が混在する開発環境で作業する場合、
ファイル名における文字の大小（``N'' と ``n''）の扱い方針が全く異なる、
という知識を心に留めておく必要があります。
良くある事では無いかもしれませんし、
容易に解決できる可能性もありますが、
知らない状況で遭遇した場合、
非常に驚かされる問題でもあります。

OS およびファイルシステムに応じて、
ファイルおよびディレクトリ名の\emph{文字の大小}の扱いは異なります。
名前における文字の大小の一般的な扱い方を、
以下に３つ示します。

\begin{itemize}
\item 完全に文字の大小を無視:
  ファイルの生成およびその後の扱いにおいて、
  文字の大文字・小文字は同じものとして扱われます。
  古い DOS 風のシステムで一般的な扱い方です。

\item 文字の大小は保持されるが無視:
  ファイルないしディレクトリ生成の際には、
  名前における文字の大小は保存され、
  OS による検索や表示が可能です。
  存在するファイルが検索される場合、文字の大小は無視されます。
  Windows や MacOS では標準的な仕様です。
  \filename{foo} と \filename{FoO} は同じファイルとみなされます。
  大文字と小文字の互換性ある扱いは、
  \emph{ケースフォールディング}（case folding）とも呼ばれます。

\item 文字の大小を区別:
  名前における文字の大小は常に意味を持ちます。
  \filename{foo} と \filename{FoO} は異なるファイルとして区別されます。
  これは Linux や Unix における通常の振る舞いです。

\end{itemize}

Unix 的なシステムの上では、
上記の大文字・小文字の取り扱い形式のうちの``任意''のものが
（あるいは全てが同時に）要求される可能性があります。
例えば、
FAT32 ファイルシステムでフォーマットされた
USB 小型メモリモジュールを Linux で使用する場合、
そのファイルシステム上での Linux の振る舞いは、
文字の大小は保持しつつ無視するものとなります。

\subsection{Safe, portable repository storage}

Mercurial のリポジトリ格納機能は、
文字大小の区別の可否に\emph{影響を受けません}。
リポジトリの保存先ファイル名は元ファイル名を変換したものなので、
ファイルシステムにおける大文字小文字の区別の可否に関わり無く、
構成管理情報を格納できます。
つまり、OS の標準的な複製ツールを使用して、
Mercurial のリポジトリを例えば USB 小型メモリモジュールに複製し、
Mac、Windows PC および Linux の間で持ち運ぶことができます。

\subsection{Detecting case conflicts}

作業領域ディレクトリにおける操作の際には、
Mercurial は作業領域を載せているファイルシステムの命名方針に従います。
ファイルシステムが文字の大小は保持しつつ無視するものであった場合、
文字の大小のみが異なる名前を Mercurial は同じものとみなします。

この方針の重要な点は、
文字大小を区別する（一般的な Linux や Unix における）
ファイルシステムにおいて、
文字大小を区別できない（Windows や MacOS の）
ユーザが取り扱えないようなチェンジセットをコミットすることが可能である点です。
Linux の利用者が
\filename{myfile.c} と
\filename{MyFile.C} 
という名前の２つのファイルに対する変更をコミットした場合、
変更内容はリポジトリに正しく保存されます。
他の Linux 利用者の作業領域ディレクトリにおいても、
これらのファイルは異なるファイルとして正しく存在します。

Mercurial のリポジトリ格納機構が文字大小の扱いの可否に影響を受けないため、
Windows ないし MacOS 利用者がこの変更を取り込んでも、
最初は問題が発生しません。
しかし、
作業領域ディレクトリを当該チェンジセットで \hgcmd{update}
しようとした場合、
あるいは当該チェンジセットと
\hgcmd{merge} しようとした場合、
ファイルシステムが同じファイルとして扱う２つのファイルの衝突を見つけた
Mercurial によって、
\hgcmd{update} ないし \hgcmd{merge} は禁止されます。

\subsection{Fixing a case conflict}

他のメンバーが Linux や Unix を使用している混在環境で
Windows ないし MacOS を使用していて、
\hgcmd{update} あるいは \hgcmd{merge} の際に
Mercurial が文字大小の衝突を報告する場合、
問題の解決手順は簡単です。

手近な Linux ないし Unix 利用者を探し、
問題のリポジトリを \hgcmd{clone} してから、
問題のファイルないしディレクトリを大文字小文字の衝突が発生しないように、
Mercurial の \hgcmd{rename} コマンドで改名をすれば良いのです。
その後、
変更をコミットし、
\hgcmd{pull} ないし \hgcmd{push} で
Windows や MacOS に変更を取り込み、
\hgcmd{update} によって衝突しない名前で変更内容を取り出します。

大文字小文字の衝突を生じさせるチェンジセットそのものは、
プロジェクトの履歴に残っており、
当該チェンジセットを Windows や
MacOS 上で作業領域ディレクトリに取り出すことはできませんが、
開発を継続することは可能です\footnote{訳注:
文字の大小とは関係ありませんが、
Windows は ``\texttt{con}'' や
``\texttt{aux}'' が特別扱いされるため、
例えばこれらの名前を利用したディレクトリがある場合などは、
リポジトリの \hgcmd{pull} そのものができません。}。

\begin{note}
  0.9.3 版以前の Mercurial は、
  大文字小文字に影響を受けないリポジトリ格納機構も、
  大文字小文字の名前衝突検知機能もありませんでした。
  Mercurial の旧版を Windows や MacOS で使用している場合、
  Mercurial の更新をお薦めします。
\end{note}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
