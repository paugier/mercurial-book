\chapter{Collaborating with other people}
\label{cha:collab}

Mercurial は完全に非中央集約的なツールであるため、
利用者相互の連携に関しては何ら制約を課すことをしません。
ですが、
分散構成管理に馴染みが無いのであれば、
いくつかのツールや使用例を知っておくことは、
妥当な作業手順のモデルを考える際に役に立ちます。

\section{Mercurial's web interface}

Mercurial は、
いくつかの有用な機能を提供する、
強力なウェブインタフェースを持っています。

対話的な利用の場合、
ウェブインタフェース経由で１つないし複数のリポジトリの閲覧ができます。
リポジトリ履歴の参照や、
個々の変更（コミットメッセージや差分）の検証、
および各ディレクトリやファイルの内容の参照、
といったことができます。

通知に関しても、
ウェブインタフェースは、
リポジトリにおける変更に関する RSS 配信機能を提供します。
お気に入りのツールを使ってリポジトリを``購読''することもできますし、
リポジトリにおける活動状況の自動通知を即座に行うこともできます。
リポジトリ提供者側における追加設定が不要であることから、
筆者自身は、
変更通知のメーリングリストよりも、
「RSS 配信を購読」するモデルの方が非常に便利だと思います。

ウェブインタフェースにより、
遠隔ユーザによるリポジトリの複製や変更の取り込み、
および（サーバ側でそれを許可しているならば）
変更の受理が可能になります。
Mercurial の HTTP トンネリングプロトコルでは、
積極的にデータの圧縮を行いますので、
狭い帯域のネットワーク接続経由でも効率よく機能します。

ウェブインタフェースを触ってみる最も簡単な方法は、
Mercurial のマスタリポジトリである
\url{http://www.selenic.com/repo/hg?style=gitweb} のような、
既存のリポジトリにウェブブラウザで接続してみることです。

自身でリポジトリのウェブインタフェースを提供することに興味がある場合、
Mercurial には２つの選択肢があります。
１つは \hgcmd{serve} コマンドを使用するもので、
短期間の``軽量な''稼動の場合に最適です。
このコマンドの利用に関する詳細は、
\ref{sec:collab:serve}~節を参照してください。
長期的且つ常時利用可能な稼動を望む場合は、
Mercurial に組み込まれている
CGI （Common Gateway Interface）機能が、
一般的な全てのウェブサーバで利用可能です。
CGI 設定の詳細は、
\ref{sec:collab:cgi}~節を参照してください。

\section{Collaboration models}

適切な柔軟性を持つツールを使うことで、
作業手順の決定は、
技術的な問題から組織工学的（social engineering）な問題へと変わります。
Mercurial は、
プロジェクトにおける作業手順の構成に関して殆ど制限を課さないため、
個別の要望に沿ったモデルの設定と運用は利用者次第となります。

\subsection{Factors to keep in mind}

いずれのモデルにおいても心得ておくべき最も重要な点は、
それを利用する人々の要望と能力にどれだけ適合するか、
ということです。
これは自明に見えるかもしれませんが、
ほんの少しの間でもこのことを忘れてはいけません。

筆者は以前、完璧と思える作業手順モデルを構築したのですが、
開発チームに少なからぬ量の驚きと不和をもたらしました。
複雑なブランチ群が必要な理由と、
それらの間における変更の取り扱いについて説明しようと試みましたが、
チームのメンバーの何人かが異を唱えてきたのです。
彼らは聡明な人達でしたが、
作業における制約に注意を払う\footnote{訳注: 「ルールを守る」の意か？}ことも、
筆者が唱えるモデルの細部における制約の重要性に向き合おうともしませんでした。

近い将来の社会的・技術的な問題から目を背けないでください。
どんな計画を実施しようとも、
間違いや問題が発生した場合に備えるべきです。
予想可能な問題に対して、
自動的な防御や即時復旧のための仕組みの追加を考慮しましょう。
例えば、
リリース向けではない変更のためのブランチを作成しようとした場合、
他の作業者がリリース用ブランチにうっかりマージしてしまう可能性について、
早い時点で考慮したほうが良いでしょう。
不適切なブランチからチェンジセットをマージさせないフックを記述することで、
この問題に関しては回避可能です。

\subsection{Informal anarchy}

持続可能性の点から
``何でもアリ''なやり方はお薦めしませんが、
簡単に把握することができるモデルであり、
いくつかの特異な状況では非常に良く機能します。

一つの例として、
多くのプロジェクトが、
直接会うことの稀な弱くまとまった協力者グループを持ている
As one example, many projects have a loose-knit group of collaborators
who rarely physically meet each other.  
時折の``全力疾走''（sprints）\footnote{訳注:
オフ会とかですね。}を設けることで、
距離によって隔てられた作業に打ち勝つグループもあります。
全力疾走の機会では、
多くの人が共に同じ場所（会社の会議室やホテルの会議室の類）
に集まり、
数日程度を閉じこもって過ごし、
少量のプロジェクトに集中してハッキングを行います。

全力疾走は、
大掛かりなサーバインフラを必要としない
\hgcmd{serve} コマンドを利用するのにちょうど良い機会です。
以下の\ref{sec:collab:serve}~節を読むことで、
すぐにでも \hgcmd{serve} を使い始めることができます。
そうしたなら、
周囲の人達にサーバを実行中であることを伝え、
インスタントメッセンジャー等を使用して URL を送れば、
共同作業する上での折り返し地点まで辿り着きました。
ブラウザに教えられた URL を入力すれば、
彼らはすぐにでもあなたの変更をレビューすることができますし、
あなたからバグフィックスを入手してそれを検証したり、
新機能が含まれるブランチを複製してそれを試してみたりすることができます。

その場限りのこのような形式で事を進めることの利点と欠点は、
あなたによる変更の存在と、どこでアクセス可能かを知る人だけが、
それを参照することができる、という点にあります。
このような非公式な手法は、
複数の異なるリポジトリからの取り込みが各自に要求されるため、
数人以上に対しては単純に規模の拡大ができません。

\subsection{A single central repository}

小規模なプロジェクトにおいて、
中央集約的な構成管理ツールからの移行する最も簡単な方法は、
単一の共有リポジトリを経由して変更のやり取りをする、
というものです。
この体制は、
より野心的な作業手順体系のための最も基本的な``構成要素''でもあります。

開発者（contributor）は、
共有リポジトリの複製を行うことで作業を開始します。
必要な時にいつでも変更の取り込みを行えますし、
開発者の何人かは（全員でも可）、
外部に公開可能になった際に変更を共有リポジトリに反映させる権限を持ちます。

このモデルであっても、
共有リポジトリを経由せずにお互いの変更を直接 \hgcmd{pull} することは、
開発者にとっては意義のあることです。
例えば、
暫定的なバグ修正を行ったものの、
共有リポジトリにその修正を公開した場合に、
その修正を取り込んだ他の開発者の作業に支障をきたす恐れがある、
という場合を考えてみましょう。
バグ修正を含む自分のリポジトリから一時的なリポジトリを複製し、
複製先で修正内容を検証してもらえるように他の開発者にお願いすることで、
潜在的な損害を低減することができます。
このようにすることで、
潜在的な危険性を持つ変更であっても、
簡単な検証が済むまでは公開されないようにすることができます。

この種のやり取りの場合は、
共有リポジトリへの安全な変更反映のために
\command{ssh} プロトコルを使用するのが一般的です
（\ref{sec:collab:ssh}~節参照）。
読み出し専用リポジトリを、
CGI を使用して HTTP 経由で公開することも可能です
（\ref{sec:collab:cgi}~節参照）。
リポジトリへの変更反映が必要ない場合や、
リポジトリの履歴をウェブブラウザ経由で参照したい場合には、
HTTP 経由での公開で十分ニーズが満たされます。

\subsection{Working with multiple branches}

一定以上の規模を持つプロジェクトにおいては、
作業の進展が同時に複数の「前線」で行われることは自然な成り行きです。
ソフトウェア開発の場合、
どのプロジェクトでも、
一定期間ごとに公式リリースを行うのが一般的です。
各リリースは最初の公開の後に、
一定期間の``保守状態''（maintenance mode）となることがあります。
保守リリースではバグ修正のみを扱い、
新規機能については取り扱わないのが通例です。
これら保守リリースと平行して、
（場合によっては複数の）将来のリリースに向けた開発が進行します。
方向性の少し異なる、これら進行中の個々の開発を指すのに、
一般的に``ブランチ''という表現を使います。

Mercurial は特に、
複数の異なるブランチを同時に管理することに適しています。
それぞれの``開発指向''ごとに、
別々の共有用リポジトリを用意することで、
必要になる都度、
あるリポジトリから別のリポジトリへのマージを行えば良いのです。
各リポジトリは互いに独立していますから、
誰かが明示的にマージしない限りは
開発ブランチにおける不安定な変更が、
安定版のためのブランチに影響を与えることはありません。

ブランチごとにリポジトリを用意する遣り方の実際の例を以下に示します。
中央のサーバに``メインブランチ''があるものとします。

\interaction{branching.init}

開発者はメインブランチから複製し、
変更、変更のテスト、コミットの後に、
変更をメインブランチのリポジトリに反映します。

メインブランチがリリースのマイルストーンに達したならば、
マイルストーンとなるリビジョンに
\hgcmd{tag} コマンドで永続的な名前を付与します。

\interaction{branching.tag}

メインブランチでは開発が継続しているとします。

\interaction{branching.main}

リリースマイルストーン後の任意の時点でリポジトリを複製した開発者は、
リリースマイルストーンで記録されたタグを使うことで、
タグが付与されたリビジョンがコミットされた時点と
厳密に一致する作業領域ディレクトリを
\hgcmd{update} コマンドにより複製することができます。

\interaction{branching.update}

それに加えて、
メインブランチでのタグ付けの後で、
サーバ上のメインブランチを、
新たな``安定版''ブランチ（のリポジトリ）へと複製することもできます\footnote{
訳注: メインブランチと安定版ブランチの各リポジトリは、
必ずしも同一サーバで運用される必要はありません。}。

\interaction{branching.clone}

安定版ブランチに対して変更する必要がある場合、
開発者は\emph{安定版ブランチ}のリポジトリから複製し、
変更、変更のテスト、コミットの後に、
変更を安定版ブランチのリポジトリに反映します。

\interaction{branching.stable}

Mercurial のリポジトリはお互いに（物理的に）独立しており、
リポジトリ間での変更の自動的なやり取りは行われないため、
安定版ブランチととメインブランはお互いに\emph{隔離}されています。
メインブランチに加えた変更が安定版ブランチに``漏れ出す''ことはありませんし、
その逆に関しても同様です。

安定版ブランチにおける全てのバグ修正を、
メインブランチに反映したい場合もあるでしょう。
メインブランチでバグ修正を再度（手動で）行う代わりに、
安定版ブランチから取り込んだ変更をメインブランに対してマージすることで、
安定版ブランチにおける変更をメインブランチに持ち込むことができます。

\interaction{branching.merge}

この時点でのメインブランチは、
安定版ブランチには無い変更を保持していますが、
安定版ブランチにおける全てのバグ修正を保持しています。
安定版ブランチは、
メインブランチにのみ含まれる変更には影響を受けないままです。

\subsection{Feature branches}

大規模プロジェクトで有効な変更管理方法は、
開発チームを小さなグループに分割することです。
プロジェクト全体が参照する単一の``マスター''ブランチから複製した共有ブランチ
（＝ リポジトリ）を、
各グループごとにそれぞれ持ちます。
個々のブランチ上で作業する開発メンバーは、
他のブランチにおける開発作業とは隔離されています。

\begin{figure}[ht]
  \centering
  \grafix[width=\textwidth]{feature-branches}
  \caption{Feature branches}
  \label{fig:collab:feature-branches}
\end{figure}

とある機能が適切な状況\footnote{訳注:
``コンパイルエラーが無くなった''状況なのか、
``単体テストが完了した''状況なのかは、
各プロジェクトの構成管理方針次第となります。}に到達したと判断されたなら、
当該機能の担当チームでは、
マスターブランチ（のリポジトリ）
から反映した変更を自チームのブランチ（のリポジトリ）へとマージしてから、
マスターブランチへとマージ結果を反映すれば良いのです。

\subsection{The release train}

プロジェクトによっては、
``train''モデルで運用されている場合もあります。
``train'' モデルで運用されているプロジェクトでは、
リリースは数ヶ月ごとに設定されており、
``train''が出発準備完了した段階\footnote{訳注: 
「数ヶ月ごとに設定されたリリーススケジュール」を
「時刻表通りの発車時刻」に例えている模様。
}で提供可能な機能だけがリリースに含まれます。

このモデルは、先に説明した機能別ブランチによる作業と似ています。
``train''モデルの場合、
機能別ブランチが列車に乗りそこなった場合、
当該機能の担当チームでは、
自チームの機能ブランチ（リポジトリ）に対して、
リリース列車に含まれる変更の取り込みおよびマージを行い、
マージ結果に対して作業を継続する必要がある点が異なります。
このマージ作業を行うことで、
次回リリースの際に、
当該機能が整合性を保つことができます。

\subsection{The Linux kernel model}

Linux カーネルの開発体制は、
浅い階層構造と、それを取り囲む一見混沌とした群集から成り立っています。
殆どの Linux 開発者が、
Mercurial と同等の機能を持った分散構成管理ツールである
\command{git} コマンドを使用しているので、
Linux カーネル開発における作業手順の説明は
Mercurial 利用にとっても有用性を持っています。
気に入ったアイデアがあれば、
ツールを超えて手法を利用することは可能なのですから。

コミュニティの中心には、
Linux を創り出した Linus Torvalds 氏がいます。
彼は単一のソースリポジトリを公開しており、
開発コミュニティ全体にとっては、
このリポジトリが``権威ある''現行ソースツリーとみなされます。
誰もが Torvalds 氏のソースツリーを複製できますが、
誰のツリーから変更を取り込むかという点に関して、
Torvalds 氏は非常に慎重な選択をしています。

Torvalds 氏には``信頼できる補佐役''が何人かいます。
彼ら補佐役が公開している変更は、
レビューが行われていなくても、
大概は Torvalds 氏により取り込まれます。
補佐役のうちの何人かは、
``保守担当者''として承認されており、
カーネルの特定のサブシステムに関する責任を負っています
とあるカーネルハッカーがサブシステムへの変更を行い、
その変更を最終的に Torvalds 氏のツリーに取り込んで欲しいと考えた場合、
当該サブシステムの保守担当者が誰であるかを調べて、
その担当者に変更の採用をお願いする必要があります。
保守担当者が変更のレビューの後に採用に同意した場合、
その変更は手順に従い Torvalds 氏へと渡されます。

個々の補佐役は、
変更のレビュー・承認および公開に関するそれぞれの手法を持っており、
Torvalds 氏への変更送付時期の判断に関しても、それは当てはまります。
それに加えて、
異なる目的向けの良く知られたブランチがいくつか存在します。
例えば、
古い版のカーネルの``安定版''リポジトリが、
必要に応じて深刻な障害の修正を適用するために、
少数の人々により保守されています。
何人かの保守担当者は、
複数のソースツリーを公開しています。
１つは実験的な変更のためのもの、
１つは上流リポジトリから配布しようとしている変更のためのもの、
といった按配です。
他の保守担当者は、ソースツリーを１つだけ公開しています。

Linux におけるこのモデルは、
２つの注目に値する特徴を持っています。
１つ目は``取り込み限定''（pull only）である点です。
保守担当者以外が変更を反映できるソースツリーが殆ど無く、
他の人が管理しているソースツリーに変更を反映する方法が無いことから、
変更を反映させたいソースツリーの保守担当者に対して、
変更の採用を\emph{お願い}する必要があります。

２つ目の特徴は、
知名度と評判に基づいている点です。
名の知られていない開発者からの変更依頼の場合、
Torvalds 氏が依頼メールを受け取ったのなら、
返信もせずに無視してしまうでしょう。
しかし、
サブシステムの保守担当者が依頼メールを受け取った場合、
内容がレビューされた上で、
それが保守担当者の基準を満たしていれば、
おそらくその変更は採用されるでしょう。
より``良い''変更で貢献する程、
保守担当者はあなたの判断を信頼するでしょうし、
あなたの変更依頼が受理度される度合いも増すでしょう。
あなたが有名になり、
Torvalds 氏がまだ受理していない息の長いブランチの保守を行うようになれば、
あなたの作業内容に追従するために、
似たような興味を持つ人々があなたの変更を定期的に取り込むようになるでしょう。

知名度や評判は、
必ずしもサブシステムや``人的''境界を越えるわけではありません。
専らストレージ系で著名なハッカーが、
ネットワークのバグ修正を試みた場合、
ネットワークサブシステムの保守担当者による監査は、
全くの部外者による変更と同程度となるでしょう。

より整然としたプロジェクト従事の経験を持つ人にとって、
相当に無秩序な Linux カーネルの開発手順は、
全く非常識なものに見えることでしょう。
この開発形態は、個人の気まぐれの影響を受けやすいのです。
作業は各自の都合の良い時に、驚くべきペース行われます。
それでもなお  Linux は、
成功を収めた重要なソフトウェアの１つとなっています。

\subsection{Pull-only versus shared-push collaboration}

他の人のリポジトリからは変更の反映のみしかしないモデルと、
複数の人々が共有リポジトリへの変更反映を行うことができる開発モデルの、
どちらが``より良い''モデルであるかは、
オープンソースコミュニティにおいて継続的な議論の的になっています。
です。

共有リポジトリ＋反映モデルの支持者は、
その手法を積極的に使用するツールを使用する傾向にあります。
Subversion のような中央集約的な構成管理ツールを使用している場合、
採用するモデルの選択肢はありません。
共有リポジトリ＋反映モデルがツールによって強制されるため、
他のモデルを使用するには、
そのツール上で独自の手法（例えば、手動で \command{patch}
を宛てる、など）を駆使する必要があります。

Mercurial のような適切な分散構成管理ツールであれば、
両方のモデルを選択可能です。
利用者間の連携形態は、
ツールにより強制される歪んだものではなく、
固有の要望や好みに基づいて構築することができます。

\subsection{Where collaboration meets branch management}

共有リポジトリを構築し、
各作業者が手元のリポジトリと共有リポジトリとの間で、
変更の伝播を開始し始めたなら、
チーム内の開発の方向性を同時に複数管理するという、
連携に関することではありつつも、
微妙に異なる難問に直面することでしょう。
この問題は開発チームの連携方式と密接に関連してはいるものの、
改めて取り上げる価値があるほど非常に込み入った話であることから、
\ref{chap:branch}~章で改めて説明します。

\section{The technical side of sharing}

本章の残りは、
共同作業者に対してデータの提供を行う上での問題点に割きたいと思います。

\section{Informal sharing with \hgcmd{serve}}
\label{sec:collab:serve}

Mercurial の \hgcmd{serve} コマンドは、
小さく緊密で足並みの早い集団での利用に大変適しています。
\hgcmd{serve} コマンドはまた、
ネットワーク越しでの Mercurial コマンドの利用感を掴むための、
素晴らしい手段を提供しています。

リポジトリ配下において \hgcmd{serve} を実行することで、
１秒も経たずに特製の HTTP サーバが起動します。
実行が停止されるまでの間にこの HTTP サーバは、
任意のクライアントからの接続を受理し、
当該リポジトリ中のデータの提供を行います。
たった今起動したばかりのサーバの URL を知っていて、
ネットワーク越しにサーバが稼動しているコンピュータと通信できるなら、
ウェブブラウザや Mercurial を利用して、
誰もがリポジトリからデータを読み出すことができます。
ノート PC 上で稼動する \hgcmd{serve} プロセスの URL は、
\Verb|http://my-notepc.local:8000/| のような形式になります。

\hgcmd{serve} コマンドは汎用ウェブサーバでは\emph{ありません}。
このコマンドを使用することで２つの事が可能になります。

\begin{itemize}
\item 一般的なウェブブラウザ経由でのサービス対象リポジトリの履歴の閲覧

\item Mercurial プロトコルによる通信を行うことで、
  リポジトリ内チェンジセットの \hgcmd{clone} ないし \hgcmd{pull}

\end{itemize}

とりわけ遠隔ユーザによる対象リポジトリの\emph{変更}を許可しないことから、
\hgcmd{serve} は読み出し専用としての利用が想定されています。

Mercurial を既に利用し始めているのであれば、
自身のコンピュータ上のリポジトリを対象として
\hgcmd{serve} を利用することができますから、
ネットワーク越しに公開されているリポジトリの場合と同様に、
\hgcmd{clone} や \hgcmd{incoming} 
のようなコマンドを使用して、
\hgcmd{serve} によって起動されたサーバと通信してみましょう。
ネットワーク経由で公開されているリポジトリに対するコマンドの使用方法を、
手早く習得する一助に \hgcmd{serve} を使用するのも良いでしょう。

\subsection{A few things to keep in mind}

\hgcmd{serve} は、
ネットワーク越しの読み出し操作を認証無しで全て許可しているため、
対象リポジトリからデータを読み出すために誰が接続して来るのかを、
気にしなくて良い（あるいは完全に制御できる）環境でのみ
\hgcmd{serve}  を使うようにすべきです。

コンピュータやネットワークへのファイヤウォールの導入状況について、
\hgcmd{serve} コマンドは一切関知しません。
ファイヤウォールの検出も制御もできません。
実行中の \hgcmd{serve} プロセスとの通信ができない場合は、
（理商社が正しい URL を使用していることを確認した\emph{後}で）
ファイアウォールの設定を確認すべきです。

\hgcmd{serve} によるネットワーク接続の受け付けは、
通常は 8000 番ポートで行われます。
当該ポートが既に他のプロセスにより使用されていた場合は、
\hgopt{serve}{-p} オプションを使用することで、
接続受け付けポート番号を指定することができます。

\hgcmd{serve} 起動の際には通常何も出力されませんので、
少々不安になるかもしれません。
\hgcmd{serve} が適切に稼動していることを確認したり、
共同作業者に送付する URL を知りたいのであれば、
\hggopt{-v} オプション付きで \hgcmd{serve} を起動してください。

\section{Using the Secure Shell (ssh) protocol}
\label{sec:collab:ssh}

Secure Shell （\texttt{ssh}）プロトコルを使用することで、
ネットワーク接続越しに安全に変更内容の取り込み・反映を行うことができます。
この接続方法を正しく機能させるには、
クライアントあるいはサーバ側で少々設定が必要かもしれません。

ssh に馴染みがないのであれば、
他のコンピュータと安全に通信するためのネットワークプロトコルである、
と理解しておいてください。
Mercurial で ssh を利用するには、
サーバへのログインおよびコマンド実行ができるように、
サーバ側にユーザアカウントを（必要であれば複数）用意する必要があります。

（ssh について詳しい場合、
以降の説明はおそらく非常に初歩的に感じるでしょう）

\subsection{How to read and write ssh URLs}

ssh プロトコルを利用する場合の URL は、
概ね以下のような形式を持ちます。

\begin{codesample2}
  ssh://bos@hg.serpentine.com:22/hg/hgbook
\end{codesample2}

\begin{enumerate}
\item ``\texttt{ssh://}' 部分が Mercurial に ssh プロトコルの利用を指示します

\item ``\texttt{bos@}''部分がサーバへのログインにおけるユーザ名を表します。
  サーバでのユーザ名がローカルマシン上のユーザ名と一致する場合は、
  この部分を省略できます。

\item ``\texttt{hg.serpentine.com}'' 
  部分はログイン先サーバのホスト名を表します。

\item ``:22'' 部分はサーバに接続する際のポート番号を表します。
  ssh 接続における既定ポート番号は 22 番ですので、
  22 番\emph{以外}のポートを使用する場合のみ指定が必要です。

\item URL の残りの部分はサーバ上におけるリポジトリのパスを表します。

\end{enumerate}

ssh プロトコルにおける URL 表記のパス要素部分には、
値の解釈に関する標準的な手法がないために、
混乱の余地が多々あります。
一群のプログラムは、
パス要素部分に関して他のプログラムと異なる振る舞いをします。
このような状況は理想的ではありませんが、
状況が変わりそうにはありません。
ですから以降の説明は注意深く読んでください。

Mercurial はパス部分を、
サーバにログインするユーザの、
ホームディレクトリに対する相対パスとみなします。
例えば、
サーバにおける \texttt{foo} ユーザのホームディレクトリが
\dirname{/home/foo} である場合、
ssh プロトコルにおける URL のパス要素が \dirname{bar} であれば、
その URL により\emph{実際に}参照されるのは
\dirname{/home/foo/bar} ディレクトリです。

他のユーザのホームディレクトリに対する相対パスを指定する場合は、
チルダ文字（\texttt{~}）にユーザ名（ここでは
\texttt{otheruser} とします）を続けたパスで始まる、
以下のような表記になります。

\begin{codesample2}
  ssh://server/~otheruser/hg/repo
\end{codesample2}

\emph{絶対}パスによる指定を行う場合は、
以下のようにパス要素をダブルスラッシュで始めます。

\begin{codesample2}
  ssh://server//absolute/path
\end{codesample2}

\subsection{Finding an ssh client for your system}

殆ど全ての Unix ライクなシステムには
OpenSSH が事前導入されています。
Unix ライクなシステムを使用している場合、
\Verb|which ssh| と入力することで
\command{ssh} コマンド（通常は \dirname{/usr/bin} にインストールされています）
のインストールの有無を確認することができます。
予想に反してインストールされていなかった場合には、
システム添付のドキュメントを参照してインストール方法を調べてください。

Windows の場合、
妥当な ssh クライアントを選択してダウンロードする必要があります。
主な選択肢は２つあります。

\begin{itemize}
\item Simon Tatham 氏による PuTTY~\cite{web:putty} は、
  ssh クライアントコマンド一式を提供しています。

\item 面倒な事への耐性が高い方なら、
  Cygwin 上の OpenSSH を使うのも良いでしょう。

\end{itemize}

どちらの場合でも、
Mercurial が ssh クライアントコマンドを探し出せるように
\hgini\ ファイルを編集する必要があるでしょう。
例えば PuTTY を使用するなら、
コマンド行で実行する ssh クライアントとして
\command{plink} を実行することになります。

\begin{codesample2}
  [ui]
  ssh = C:/path/to/plink.exe -ssh -i "C:/path/to/my/private/key"
\end{codesample2}

\begin{note}
  \command{plink} へのパスが空白文字を含む場合、
  Mercurial は \command{plink} コマンドを正しく起動できません
  （ですので \dirname{C:\\Program Files} にインストールするのは、
  よくありません）。
\end{note}

\subsection{Generating a key pair}

ssh クライアントを使用する度に、
毎回パスワード入力を繰り返さなくても良い様に、
鍵対（key pair）\footnote{訳注:
「公開鍵」（public key）と
「秘密鍵」（private key）の対が生成されます。
}を生成することをおすすめします。
Unix ライクなシステム\footnote{訳注: Windows の Cygwin 環境含む}では、
\command{ssh-keygen} コマンドで鍵対を生成します。
Windows 上で PuTTY を使用している場合は、
\command{puttygen} コマンドで鍵対を生成します。

鍵対を生成する場合、
パスフレーズで鍵を守るようにするのが、
一般には\emph{非常に}賢明とされています
（ssh プロトコルによる安全なネットワークを、
自動化された処理において使用する場合を除く）。

しかし、単に鍵対を生成しただけでは不十分です。
ネットワーク経由でログインするサーバ側アカウントにおいて、
承認鍵一覧に公開鍵を追加登録する必要があります。
OpenSSH が導入されているサーバでの公開鍵の追加は、
当該アカウントの \sdirname{.ssh} ディレクトリ配下の
\sfilename{authorized\_keys} 
ファイルに公開鍵の内容を追加することで行われます。

Unix ライク名システムでは、
公開鍵は通常 \filename{.pub} 拡張子を持っています。
Windows 上で \command{puttygen} を使用する場合は、
任意のファイル名で保存可能ですし、
公開鍵の内容が表示されているウィンドウから
\sfilename{authorized\_keys} へ直接貼り付け（paste）ることも可能です

\subsection{Using an authentication agent}

認証エージェントは、
パスフレーズをメモリ上に格納するデーモンプロセスです
（そのため、ログアウト後に再度ログインした場合、
パスフレーズは失われます）。
認証エージェントの稼動を検知すると、
ssh クライアントは認証エージェントにパスフレーズの問い合わせを行います。
認証エージェントが稼動していないか、
あるいは必要なパスフレーズを記憶していない場合は、
Mercurial によるサーバ連携（例: \hgcmd{push} や \hgcmd{pull}）の都度、
パスフレーズの入力が必要です。

認証エージェントによるパスフレーズ保存の欠点は、
入念に準備した攻撃者にとっては、
たとえ定期的に再起動しているシステムであっても XXXXXX power-cycled XXXX
パスフレーズの平分を復元可能である点です。
この問題が許容可能なものか否かは、各自で判断する必要があります。
認証エージェントを使用することで、
繰り返しパスフレーズを入力する手間を大幅に低減することができます。

Unix ライク名システムでは、
認証エージェントは \command{ssh-agent} という名前で、
\command{ssh-add} 
コマンドを使ってエージェントの記憶領域にパスフレーズを保存します。
Windows 上で PuTTY を使用する場合は、
\command{pageant} コマンドが認証エージェントして振舞います。
システムトレイに追加されたアイコンをクリックすることで、
格納されたパスフレーズの管理を行うことができます。

\subsection{Configuring the server side properly}

初心者にとって ssh の設定は面倒なので、
問題が発生する状況も多岐に渡ります。
Add Mercurial on top, and
there's plenty more scope for head-scratching.  XXXXX
問題発生の可能性は、
クライアント側ではなくサーバ側の方が高いです。
ありがたいことに、
一旦正しく動作する設定ができてしまえば、
通常は無期限に正しく動作し続けます。

Mercurial で ssh サーバと通信をしてみる前に、
通常の \command{ssh} ないし 
\command{putty} コマンドによるサーバとの通信を確認するのが無難です。
直接コマンドを使用した際に問題が発生したならば、
Mercurial が機能しないことは確実です。
更に悪いことに、
Mercurial を介しての ssh サーバとの連携は、
根本的な原因が隠れてしまいます。
ssh に関連する Mercurial の問題を解決する場合は、
Mercurial の不具合を疑う\emph{前に}、
ssh クライアントコマンドの直接実行が機能することを確認してください。

サーバ側で最初に確認すべき事は、
あるマシンからサーバマシンへの実際のログインの可否です。
\command{ssh} ないし \command{putty} でログインできない場合、
表示されるエラーメッセージから問題特定のヒントが得られるかもしれません。
よくある問題には以下のようなものがあります。

\begin{itemize}
\item ``connection refused'' が表示される場合は、
  ssh サーバプロセスが起動されていないか、
  ファイヤーウォール設定によりネットワーク接続できないことが原因です。

\item ``no route to host'' が表示される場合は、
  接続先のサーバアドレスが間違っているか、
  ファイヤーウォールによって接続が厳重に禁止されていることが原因です。

\item ``permission denied'' が表示される場合は、
  サーバ接続の際のユーザ名、パスフレーズ、
  ないしサーバ側ユーザのパスワードの入力を間違えていることが原因です。

\end{itemize}

これまでの話をまとめると、
サーバマシン上の ssh サーバプロセスとの通信に問題がある場合、
まずはサーバプロセスの稼動状況を確認してください。
多くのシステムでは、
ssh 自体はインストールされていますが、
初期状態では無効化されている場合があります。
この確認が済んだなら、
次に確認するのは、
ssh サーバプロセスが外部からの接続を受け付けるポート（通常は 22 番）
に対する外部からの接続を、
サーバのファイヤーウォール設定が許可しているか否かです。
これら２つの確認を済ませるまでは、
突拍子もない設定ミスの可能性に関して心配する必要はありません。

秘密鍵用パスフレーズの保持のために、
クライアント側で認証エージェントを使用している場合は、
パスフレーズやパスワードの問い合わせを受ける事無く、
サーバにログインできていなければなりません。
パスフレーズを問い合わせるプロンプトが表示される場合、
問題の可能性のあるものが幾つかあります。

\begin{itemize}
\item \command{ssh-add} ないし \command{pageant} 
  によるパスフレーズの格納を忘れているのかもしれません。

\item 想定しているものとは別な鍵のパスフレーズを格納しているのかもしれません。

\end{itemize}

サーバ側ユーザのパスワードの問い合わせがあった場合、
別な問題の可能性を検討する必要があります。

\begin{itemize}
\item サーバ側ユーザの、ホームディレクトリないし
  \sdirname{.ssh} ディレクトリの権限設定が、
  過度に緩く設定されているのかもしれません。
  ssh サーバプロセスはその場合、
  \sfilename{authorized\_keys}
  ファイルの信頼性が低いものとして読み込みを行いません。
  例えば、
  ホームディレクトリないし \sdirname{.ssh} ディレクトリが、
  グループに対する書き込み権限を設定されている場合、
  パスワード問い合わせが行われる、といった症状が見られます。

\item \sfilename{authorized\_keys} 
  ファイルそのものに問題がある可能性もあります。
  このファイルへの書き込み権限が所有者以外にも設定されている場合、
  ssh サーバプロセスはファイルの信頼性が低いものとして読み込みを行いません。

\end{itemize}

以下のコマンド実行に対して、
（サーバ側の）現在時刻を表示する１行だけが出力される、
という状態が理想的です。

\begin{codesample2}
  ssh myserver date
\end{codesample2}

上記のような非対話的なコマンド実行の場合にも、
バナー表示やそれに類する表示が行われるような設定が、
連携先サーバ側で行われている場合には、
この先の手順に進む前に、
対話的な実行\footnote{訳注: 「ssh によるログイン時」の意}の時にのみ、
これらが表示されるように設定変更してください。
これを怠ると、
バナー等の表示が Mercurial の出力を混乱させてしまいます。
更に問題なことに、
バナー等の表示は Mercurial コマンドの遠隔実行における潜在的な問題と成り得ます。
非対話的な \command{ssh} 連携において、
Mercurial は極力バナー等の表示の検知ならびに無視に努めますが、
必ずしも全てが無視できるわけではありません
（サーバ側でログイン時実行スクリプトをカスタマイズする場合、
\Verb|tty -s| コマンドの戻り値を判定することで、
当該スクリプトが現在対話シェルで実行されているか否かを判定することができます）
\footnote{訳注: ログインスクリプトでの出力以外でも、
フック実行時に標準出力に対して何らかの表示があった場合、
Mercurial は「連携における想定外のデータ授受」とみなすため、
注意が必要です。}。

素の ssh によるサーバ連携が機能することを確認したならば、
次に確認するのは、
サーバ側での Mercurial 実行の可否です。
以下のコマンド実行が正しく機能することを確認してください。

\begin{codesample2}
  ssh myserver hg version
\end{codesample2}

通常の \hgcmd{version} 出力ではなくエラーメッセージが表示される場合、
大概は \dirname{/usr/bin} に
Mercurial がインストールされていないことが原因です。
その場合でも、
必ずしも \dirname{/usr/bin} にインストールする必要はありません。
しかし、考え得る以下の幾つかの原因に関して確認が必要です。

\begin{itemize}
\item Mercurial は本当にサーバにインストールされていますか？
  変な質問と思われるかもしれませんが、これは非常に重要な確認事項です。

\item シェルのコマンドサーチパス（通常は \envar{PATH} 環境変数で設定）
  の設定が単に不適切なのかもしれません。

\item ひょっとしたら、\envar{PATH} 環境変数が 
  \command{hg} 
  コマンドの格納場所を指すように設定されるのは対話的なログイン時にのみ、
  という可能性もあります。
  \envar{PATH} 環境変数の設定を不適当な起動スクリプトで行っている場合に、
  このような現象が発生します。
  各自の使用しているシェルのドキュメントを確認してみましょう\footnote{訳注:
  例えば bash の場合、対話的ログインか否かで
  \sfilename{.bashrc}、
  \sfilename{.bash\_profile}、
  \sfilename{.profile} および
  \sfilename{.login} といった各ファイルの読み込みの有無が変化します。
  また、ディストリビューションによっては、
  非対話的な実行の際には、
  \dirname{/etc/bashrc} による
  \dirname{/etc/profile.d} 
  配下の設定ファイル読み込みが行われない場合があります
  （2.6.x 系カーネルベースのものは読み込まない方針の模様）ので、
  \envar{PYTHONPATH} の件も含めて、
  システムワイドな設定を行う方は注意が必要です。
  \Verb|ssh myserver env| 
  実行で出力される環境変数一覧を確認してみましょう。
  }。

\item \envar{PYTHONPATH} 環境変数による
  Mercurial の Python 
  モジュール格納ディレクトリの参照が必要であるケースもあります。
  不適切な設定だったり、対話的ログイン時にのみ設定されている可能性があります。

\end{itemize}

ssh 経由での \hgcmd{version} コマンド実行が成功したなら準備は完了です。
サーバ・クライアントは共に問題解決済みとなりました。
サーバ上で公開されている リポジトリに、
当該ユーザ名による Mercurial でのアクセスが可能になっている筈です。
ここまでの確認をクリアした上で、
Mercurial と ssh の連携において問題が発生した場合、
問題発生の状況をより明確にするために、
\hggopt{--debug} オプションを付けての実行を試してみてください。

\subsection{Using compression with ssh}

ssh プロトコルを使用する場合、
ssh プロトコル自身が通信時にデータ圧縮を行うため、
Mercurial は圧縮を行いません。
しかし、ssh クライアントの（通常の）基底動作では、
圧縮を\emph{行いません}。

高速な LAN の場合を除けば（無線ネットワークであっても）、
通信時の圧縮は Mercurial 
のネットワーク経由の処理を顕著に高速化します。
例えば WAN 経由での連携の場合、
かなり大きなリポジトリの複製に要する時間が 51 分から 17 分に低減した、
との性能計測報告もあります。

\command{ssh} と \command{plink} の両方とも、
通信時圧縮を有効化する
\cmdopt{ssh}{-C} オプションを受け付けます。
\hgrc\ ファイルを以下のように編集することで、
ssh プロトコル利用の際に常に圧縮を行うように Mercurial に対して指定できます。

\begin{codesample2}
  [ui]
  ssh = ssh -C
\end{codesample2}

\command{ssh} を使用している場合は、
連携先サーバとの通信の際には常に圧縮を行うように設定することもできます。
この設定を行うには、
ホームディレクトリ配下の
\sfilename{.ssh/config} ファイル
（無い場合は新規に作成します）に以下のように記述します。

\begin{codesample2}
  Host hg
    Compression yes
    HostName hg.example.com
\end{codesample2}

上記の記述は、
\texttt{hg} という別名（alias）を作成します。
\command{ssh} 実行の際のコマンド行記述や、
Mercurial の \texttt{ssh} プロトコルにおける URL として、
\texttt{hg} を（ホスト名として）使用した場合、
\command{ssh} は通信時圧縮を行いつつ \texttt{hg.example.com} に接続します。
この設定により、
入力の便利な省略名と、圧縮指定の両方を手にすることができます。

\section{Serving over HTTP using CGI}
\label{sec:collab:cgi}

意気込み次第では、
Mercurial の CGI インタフェースの設定は、
数分のものを数時間にしてしまう可能性があります。

最も単純な例から初めて、
より複雑な設定へと向けて進めてゆきましょう。
最も基本的なケースですら、
ウェブサーバの設定ファウルの読み書きを行う必要が出てくることでしょう。

\begin{note}
  ウェブサーバの設定は複雑で、扱いにくく、且つシステム依存性の高い作業です。
  そのため本書では、
  発生するであろう問題のケースを全て網羅するような手順を示すことができません。
  以降の記述は、慎重さと各自の判断をもって読み進めるようにしてください。
  沢山間違えたり、サーバのエラーログ解析に時間を費やす覚悟が必要でしょう。
\end{note}

\subsection{Web server configuration checklist}

読み進める前に、
システムの設定状況に関する幾つかの確認を行いましょう。

\begin{enumerate}
\item ウェブサーバはインストールされていますか？
  Mac OS X は Apache がインストールされた状態で出荷されますが、
  多くのシステムではウェブサーバはインストールされていません。

\item ウェブサーバがインストールされている場合、
  それは実際に稼動していますか？
  ウェブサーバがインストールされていた場合でも、
  多くのシステムの基底状態は、ウェブサーバが無効化されています。

\item CGI を稼動させようとしているディレクトリは、
  ウェブサーバの設定で CGI の実行が許可されていますか？
  多くのウェブサーバの基底状態は、
  CGI プログラムの実行機能が明示的に無効化されています。

\end{enumerate}

ウェブサーバがインストールされていない場合や、
Apache ウェブサーバの設定経験があまり無い場合には、
Apache ウェブサーバの代わりに
\texttt{lighttpd} ウェブサーバの利用をお薦めします。
Apache ウェブサーバの設定は、
凝っていて且つわかりにくいという評判に見合うものがあります。
\texttt{lighttpd} は Apache ウェブサーバ程の機能は無いものの、
足りない機能の殆どが Mercurial リポジトリの運用には関係ないものです。
それに加えて、
明らかに \texttt{lighttpd} は
Apache ウェブサーバよりも簡単に利用が開始できます。

\subsection{Basic CGI configuration}

Unix 的なシステムを利用している場合、
ウェブページとして公開するための
\dirname{public\_html} のようなディレクトリを、
ホームディレクトリ配下に持つのが共通認識となっています。
このディレクトリ直下に置いた
\filename{foo} という名前のファイルは、
\texttt{http://www.example.com/\~username/foo} という
URL で参照可能になります。

設定を始めるに当たって、
Mercurial のインストール先に格納されている
\sfilename{hgweb.cgi} スクリプトの所在を確認してください。
システム上の所在がすぐにはわからなかった場合は、
Mercurial のマスターリポジトリから
\url{http://www.selenic.com/repo/hg/raw-file/tip/hgweb.cgi}
を直接ダウンロードしてください。

上記スクリプトを
\dirname{public\_html} 配下に配置し、
実行可能となるように権限設定を行います。

\begin{codesample2}
  cp .../hgweb.cgi ~/public_html
  chmod 755 ~/public_html/hgweb.cgi
\end{codesample2}

\command{chmod} コマンドへの \texttt{755} 引数指定は、
スクリプトに実行可能権限を付与する以上の付加的な指定を意味します。
この設定により、スクリプトが誰からも実行可能になると同時に、
``group'' および ``other'' による書き込み権限が\emph{剥奪}されます。
これらの書き込み権限を有効なままにした場合、
Apache の \texttt{suexec} サブシステムは、
おそらくスクリプトの実行を拒否するでしょう。
実のところ \texttt{suexec} は、
スクリプトが配置されている\emph{ディレクトリ}に対する
``group'' および ``other'' による書き込み権限が剥奪されていることも要求します。

\begin{codesample2}
  chmod 755 ~/public_html
\end{codesample2}

\subsubsection{What could \emph{possibly} go wrong?}
\label{sec:collab:wtf}

CGI を配置したならば、
ウェブブラウザを起動して
\url{http://myhostname/~myuser/hgweb.cgi} に相当する
URL にアクセスしてみましょう。
但し、ちょっとした失敗には\emph{身構えておいてください}。
所望の URL へのアクセスが失敗する公算は非常に高く、
その理由は多岐に渡ります。
実際のところ、
以下の起こり得るエラー要因の全てで躓く可能性がありますから、
この先は注意深く読み進めてください。
以下で述べる問題は、
まっさらな状態からインストールした Apache を使い、
この実例を行うために新たに生成したユーザアカウントで、
Fedora~7 上で作業を実施した際に、
筆者が実際に直面した全ての問題です。

使用しているウェブサーバは、
ユーザ毎のディレクトリを無効化しているかもしれません。
Apache を使用している場合は、
設定ファイル中に \texttt{UserDir} 指定の有無を確認してください。
この指定が無い場合、ユーザ毎ディレクトリは無効になります。
指定が有っても\texttt{無効化されている}場合も、
ユーザ毎ディレクトリは無効になります。
有効な \texttt{UserDir} 指定がある場合、
\texttt{UserDir} 指定で記述されている文字列
（例えば \dirname{public\_html}）が、
ホームディレクトリ直下で Apache が参照するサブディレクトリ名になります。

ファイルのアクセス権限が厳しすぎる可能性もあります。
ウェブサーバは、
対象となるユーザのホームディレクトリ、
および \dirname{public\_html} 
配下のファイル・ディレクトリの読み込みができなければなりません。
適切な権限設定を行うための簡単な手順を以下に示します。

\begin{codesample2}
  chmod 755 ~
  find ~/public_html -type d -print0 | xargs -0r chmod 755
  find ~/public_html -type f -print0 | xargs -0r chmod 644
\end{codesample2}

権限設定に関する他の要因の可能性がある場合は、
ブラウザでの所望の URL アクセス時に、
完全に空の画面が表示されることでしょう。
この場合は、おそらくアクセス権限が\emph{緩すぎる}のでしょう。
例えば Apache の \texttt{suexec} サブシステムは、
group ないし other に書き込み権限が付与されたスクリプトは実行しません。

使用しているウェブサーバが、
ユーザ毎ディレクトリ配下の CGI プログラムの実行を、
禁止するように設定されている可能性も有ります。
筆者の Fedora~7 システムにおける Apache の、
初期状態のユーザ毎設定を以下に示します。

\begin{codesample2}
  <Directory /home/*/public_html>
      AllowOverride FileInfo AuthConfig Limit
      Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec
      <Limit GET POST OPTIONS>
          Order allow,deny
          Allow from all
      </Limit>
      <LimitExcept GET POST OPTIONS>
          Order deny,allow
          Deny from all
      </LimitExcept>
  </Directory>
\end{codesample2}

対象となる Apache 設定ファイル中に似たような
\texttt{Directory} 設定がある場合、
\texttt{Options} 指定に注目してください。
\texttt{ExecCGI} が指定されていない場合は一覧末尾にこれを追加し、
ウェブサーバを再起動してください。

Apache が CGI を実行するのではなく、
CGI スクリプトの内容そのものを返却してきた場合は、
以下の記述を（既に記述があるならば）有効化するなり追加するなりしてください。

\begin{codesample2}
  AddHandler cgi-script .cgi
\end{codesample2}

次に問題の発生し得るケースでは、
Python のバックトレースが表示され、
\texttt{mercurial} 関連モジュールがインポート
（import）できない旨を伝えていることでしょう。
所望の結果は得られていませんが、
ウェブサーバは CGI スクリプトの実行を行うようになったので、
先程の状態からは前進しています！
インポートができない旨のエラーは、
システムワイドで利用可能な Mercurial ではなく、
おそらく個人的にインストールした Mercurial 
を実行している場合にのみ発生します。
ウェブサーバが CGI プログラムを実行する場合、
各個人の対話的ログインセッションで実施されている環境変数指定が無い、
ということを忘れないでください。
このエラーが発生した場合は、
\envar{PYTHONPATH} 環境変数設定が適切になるように
\sfilename{hgweb.cgi} の記述を編集してください。

最終的に、
\dirname{/path/to/repository} が見つからない旨を伝える
Python のバックトレースが\emph{確実に}表示されることでしょう。
\sfilename{hgweb.cgi} スクリプトを編集して、
文字列 \dirname{/path/to/repository} 
を実際に公開したいリポジトリへの絶対パスで置き換えてください。

ここまで来れば、
ウェブブラウザでページをリロードした際に、
綺麗に HTML で整形されたリポジトリ履歴の表示を見ることができる筈です。
お疲れ様です。

\subsubsection{Configuring lighttpd}

徹底的に実験するために、
これまで Apache に関して説明したのと同様に、
近年人気が高まっている \texttt{lighttpd} ウェブサーバで、
同じリポジトリを公開するための設定記述に挑戦してみました。
Apache についてこれまで概説してきた全ての問題は既に克服済みですし、
その殆どはウェブサーバ実装に依存しません。
結果として、
ファイル・ディレクトリの権限設定が妥当であることと、
\sfilename{hgweb.cgi} スクリプトが適切に改変済みであることは、
ある程度確信できます。

一旦 Apache での公開に成功していれば、
\texttt{lighttpd} でのリポジトリ公開は簡単
（言い換えるなら、
\texttt{lighttpd} を使用する場合でも、
前述の Apache に関する説明を読むべきと言えます
）です。
初期状態で
\texttt{mod\_cgi} および \texttt{mod\_userdir} が無効化されていた場合、
これらを有効化するために、
まずは、
設定ファイルの \texttt{mod\_access} セクションを編集する必要があります。
その後、これらのモジュールを設定するために、
設定ファイル末尾に数行ほど追加します。

\begin{codesample2}
  userdir.path = "public_html"
  cgi.assign = ( ".cgi" => "" )
\end{codesample2}

この記述により、
\texttt{lighttpd} はユーザ毎のディレクトリおよび CGI を認識します。
Apache よりも前に
\texttt{lighttpd} の設定をしたとしたら、
殆ど間違いなく、
Apache 
の設定の際に経験したのと同じシステムレベルの設定ミスを犯したことでしょう。
しかし
Apache の使用経験が１０年以上あり、
且つ初めての \texttt{lighttpd} 使用ではあるものの、
Apache の設定よりも \texttt{lighttpd} のそれは著しく容易であると思われます。

\subsection{Sharing multiple repositories with one CGI script}

単一のリポジトリのみしか公開できないというのは、
\sfilename{hgweb.cgi} スクリプトの悩ましい制約です。
同じスクリプト\footnote{訳注: 厳密には、
公開対象リポジトリのパスが異なるのですが、
概ね「同じ」と言って良いでしょう。
}を異なる名前で複製する、
という面倒な方法よりは、
\sfilename{hgwebdir.cgi} スクリプトの使用がお薦めです。

\sfilename{hgwebdir.cgi} の設定手順は、
\sfilename{hgweb.cgi} よりも多少込み入っています。
まず始めに
スクリプトのコピーを入手します。
手近に無い場合は
Mercurial のマスターリポジトリから
\url{http://www.selenic.com/repo/hg/raw-file/tip/hgwebdir.cgi}
を直接ダウンロードしてください。

\dirname{public\_html} 配下に上記スクリプトを配置し、
実行可能となるように権限設定を行います。

\begin{codesample2}
  cp .../hgwebdir.cgi ~/public_html
  chmod 755 ~/public_html ~/public_html/hgwebdir.cgi
\end{codesample2}

基本的な設定が済んだなら、
ブラウザで \url{http://myhostname/~myuser/hgwebdir.cgi}
にアクセスしてみましょう。
空のリポジトリリストが表示される筈です。
何も表示されないか、エラーメッセージが表示される場合は、
\ref{sec:collab:wtf}~節で説明した潜在的問題一覧を一通り確認してください。

\sfilename{hgwebdir.cgi} スクリプトは外部設定ファイルを必要とします。
基底状態の
\sfilename{hgwebdir.cgi} スクリプトは、
自身と同じディレクトリに格納された
\sfilename{hgweb.config} ファイルを読み込もうとします。
このファイルを生成し、
誰に対しても読み出し権限を付与しなければなりません。
このファイルの記述形式は、
Windows における ``ini'' ファイルのそれと同じで、
Python の
\texttt{ConfigParser}~\cite{web:configparser} 
により解析可能な形式です。

最も簡単に \sfilename{hgwebdir.cgi} を設定するには、
\texttt{collections} という名前のセクションを設定してください。
このセクションを記述することで、
名付けたディレクトリ配下の\emph{全ての}リポジトリを自動的に公開します。
このセクションの記述は以下のようになります。

\begin{codesample2}
  [collections]
  /my/root = /my/root
\end{codesample2}

Mercurial はこの記述を解釈するに当たり、
``\texttt{=}'' 
記号の\emph{右辺}に記述されたディレクトリ階層下でリポジトリを探し、
``\texttt{=}'' 記号の\emph{左辺}のテキストに合致する部分を、
ウェブインタフェースでの一覧表示で実際に公開される名前から除外します。
除外処理の後に残ったパス要素は、``仮想パス''と呼ばれます。

例として
\dirname{/my/root/this/repo} にリポジトリがあるとした場合、
CGI スクリプトは冒頭の
\dirname{/my/root} 部分を名前から除外し、
仮想パスとして \dirname{this/repo} を持つリポジトリとして公開します。
CGI スクリプトの基底 URL を
\url{http://myhostname/~myuser/hgwebdir.cgi} とすると、
このリポジトリの完全な URL は、
\url{http://myhostname/~myuser/hgwebdir.cgi/this/repo} となります。

この設定記述例での左辺を \dirname{/my/root} から
\dirname{/my} に変更した場合、
\sfilename{hgwebdir.cgi} はリポジトリ名から
\dirname{/my} のみをｚｙ歩外するので、
仮想パスは \dirname{this/repo} ではなく
\dirname{root/this/repo} となります。

\sfilename{hgwebdir.cgi} は、
設定ファイル中の \texttt{collections}
セクションで列挙された個々のディレクトリに対して、
再帰的にリポジトリを探しますが、
見つかったリポジトリから更に下への再帰的探索は\texttt{行いません}。

\texttt{collections} の機構は、
多くのリポジトリを``fire and forget''作法で公開するのに適しています。
CGI や設定ファイルの記述は一度で事足ります。
設定が済んだなら、
\sfilename{hgwebdir.cgi} 
に探索を指示したディレクトリ階層配下との間でリポジトリの移動を行うだけで、
リポジトリの公開・非公開を任意の時点で行うことができます。

\subsubsection{Explicitly specifying which repositories to publish}

\sfilename{hgwebdir.cgi} スクリプトは
\texttt{collections} による公開の仕組みに加えて、
特定の一覧指定によるリポジトリ公開をすることもできます。
この方法での公開をするには、
以下のような形式の内容を持つ
\texttt{paths} セクションを記述する必要があります。

\begin{codesample2}
  [paths]
  repo1 = /my/path/to/some/repo
  repo2 = /some/path/to/another
\end{codesample2}

上記の例では、個々の定義の左辺が仮想パス（URL 中に現れるパス要素）、
右辺がリポジトリへのパスとなります。
仮想パスの指定と、
ファイルシステム上のリポジトリ位置には、
何の関連性も無い点に注意してください。

単一の設定ファイル中で
\texttt{collections} と
\texttt{paths} の両方を同時に使用することも可能です。

\begin{note}
  同一の仮想パスに複数のリポジトリが関連付けられている場合、
  \sfilename{hgwebdir.cgi} はエラーを通知しません。
  その代わりに、
  \sfilename{hgwebdir.cgi} の振る舞いは予想できないものとなります。
\end{note}

\subsection{Downloading source archives}

Mercurial のウェブインタフェース経由で、
任意のリビジョンのアーカイブをダウンロードすることが可能です。
このアーカイブには、
当該リビジョンにおける作業領域ディレクトリのスナップショットが格納されますが、
リポジトリデータ部分は含まれません。

この機能は既定状態では無効化されています。
この機能を有効化するには、
\rcitem{web}{allow\_archive} 項目を
\hgrc ファイルの \rcsection{web} セクションに追加してください\footnote{訳注:
このことから、
アーカイブダウンロードの有効化・無効化設定が、
\sfilename{hgwebdir.cgi} 単位ではなく、
リポジトリ単位での設定であることがわかります。}。

\subsection{Web configuration options}

Mercurial のウェブインタフェース
（\hgcmd{serve} コマンドおよび
\sfilename{hgweb.cgi} ないし \sfilename{hgwebdir.cgi} スクリプト）
には変更可能な設定項目が多数あります。
これらの設定項目は
\rcsection{web} セクションに属しています。

\begin{description}

\item[\rcitem{web}{allow\_archive}] 
  Mercurial のアーカイブダウンロード機能を有効化するか否かを指定。
  この機能を有効化した場合ウェブインタフェースの利用者は、
  リポジトリ中の参照可能な任意のリビジョンのアーカイブをダウンロードできます。
  この機能を有効化するには、
  以下に列挙されるキーワードの並びを
  \rcitem{web}{allow\_archive} 項目に指定する必要があります。

  \begin{description}
  \item[\texttt{bz2}] \texttt{bzip2} 圧縮された \command{tar} アーカイブ形式。
    この形式は最も高い圧縮率を得られますが、
    サーバ側の CPU を最も酷使します。

  \item[\texttt{gz}] \texttt{gzip} 圧縮された \command{tar} アーカイブ形式。

  \item[\texttt{zip}] LZW 圧縮された \command{zip} アーカイブ形式。
    この形式は圧縮率が最も劣りますが、Windows 環境では広く使用されています。

  \end{description}

  値を指定しなかったり、
  \rcitem{web}{allow\_archive} 項目そのものを指定しなかった場合、
  アーカイブダウンロード機能は無効化されます。
  利用可能な全てのアーカイブ形式を有効化する記述例を以下に示します。

  \begin{codesample4}
    [web]
    allow_archive = bz2 gz zip
  \end{codesample4}

\item[\rcitem{web}{allowpull}] 
  ウェブインタフェース経由での HTTP 越しの
  \hgcmd{pull} および \hgcmd{clone} を許可するか否かを指定する真偽値。
  \texttt{no} ないし \texttt{false} が指定された場合、
  ウェブインタフェースの``人間向け''部分のみが有効化されます。

\item[\rcitem{web}{contact}] 
  リポジトリの管理を行う人物・組織を特定するための任意の
  （但し極力簡潔な）文字列。
  通常この値は、管理者ないしメーリングリストの名前と電子メールアドレスです。
  多くの場合、
  この情報はリポジトリ毎の \sfilename{.hg/hgrc} ファイルに記述しますが、
  全てのリポジトリが同一の保守担当により保守されている場合、
  大域的な \hgrc ファイルに記述するのも良いでしょう。

\item[\rcitem{web}{maxchanges}] 
  ページ毎に表示されるチェンジセットの最大数（既定値）を表す数値。

\item[\rcitem{web}{maxfiles}] 
  ページ毎に表示される変更ファイルの最大数（既定値）を表す数値。

\item[\rcitem{web}{stripes}] 
  テーブル表示における可読性向上のために、
  各行の色を互い違いに``縞模様''とする際に、
  何行毎に色を変更するかの数値。

\item[\rcitem{web}{style}] 
  Mercurial がウェブインタフェースを表示する際に使用するテンプレート。
  Mercurial は \texttt{default} および
  \texttt{gitweb} の２つのウェブインタフェース用テンプレートを同梱しています
  （後者の方が見栄えが良いです）。
  自前でカスタマイズしたテンプレートを指定することもできます。
  詳細は\ref{chap:template}~節を参照してください。
  \texttt{gitweb} スタイルの利用方法を以下に示します。

  \begin{codesample4}
    [web]
    style = gitweb
  \end{codesample4}

\item[\rcitem{web}{templates}] 
  テンプレートファイルの参照先ディレクトリを示すパス。
  Mercurial の既定値では、インストール先ディレクトリを参照します。

\end{description}

\sfilename{hgwebdir.cgi} を使用する場合、
幾つかの設定項目に関しては利便性上、
\hgrc ファイルに記述する代わりに、
\sfilename{hgweb.config} ファイルの
\rcsection{web} セクションに記述することができます。
記述可能な設定項目は、
\rcitem{web}{motd} および \rcitem{web}{style} です。

\subsubsection{Options specific to an individual repository}

ユーザ毎ないし大域的な \hgrc ファイルではなく、
リポジトリ毎の \sfilename{.hg/hgrc} で記述すべき
\rcsection{web} セクションの設定項目が幾つかあります。

\begin{description}
\item[\rcitem{web}{description}] 
  リポジトリの内容ないし目的を記述した任意の
  （但し極力簡潔な）文字列。

\item[\rcitem{web}{name}] 
  ウェブインタフェースにおけるリポジトリ参照名を示す文字列。
  この値は、
  リポジトリのパス\footnote{訳注: 仮想パス？
  }の末尾要素を用いた既定名を上書きします。

\end{description}

\subsubsection{Options specific to the \hgcmd{serve} command}

\hgrc ファイルの
\rcsection{web} セクションにおける設定項目の幾つかは、
\hgcmd{serve} コマンド専用の項目です。

\begin{description}

\item[\rcitem{web}{accesslog}] 
  アクセスログを書き出すファイルのパス。
  \hgcmd{serve} コマンドの基底動作でのアクセスログ出力先は、
  ファイルではなく標準出力です。
  ログ要素は、
  多くのウェブサーバにおいて利用される標準的な``複合''（combined）
  ファイル形式で出力されます。

\item[\rcitem{web}{address}] 
  外部からの接続を受け付けるアドレスを指定する文字列。
  基底動作では、\hgcmd{serve} コマンドは全てのアドレスで接続を受け付けます。

\item[\rcitem{web}{errorlog}] 
  エラーログを書き出すファイルのパス。
  \hgcmd{serve} コマンドの基底動作でのエラーログ出力先は、
  ファイルではなく標準エラー出力です。

\item[\rcitem{web}{ipv6}] 
  IPv6 プロトコル利用の有無を指定する真偽値。
  基底動作では IPv6 はサポートされません。

\item[\rcitem{web}{port}] 
  \hgcmd{serve} コマンドが接続を受け付ける TCP ポートの番号を指定する数値。
  基底動作では、8000 番ポートが使用されます。

\end{description}

\subsubsection{Choosing the right \hgrc\ file to add \rcsection{web}
  items to}

Apache や \texttt{lighttpd} のようなウェブサーバは、
リポジトリ所有者とは異なるユーザ権限で稼動する可能性がある、
という点は重要ですので忘れないようにしてください。
ウェブサーバによって起動される
\sfilename{hgweb.cgi} のような
CGI スクリプトは通常、
ウェブサーバと同一のユーザ権限で稼動します。

個人の \hgrc ファイルに
\rcsection{web} セクションを記述しても、
CGI スクリプトはその設定を読み込みません。
個人の \hgrc ファイルに記述した設定は、
当該ユーザ自身で \hgcmd{serve} 
コマンドを実行した場合にのみ効力を発揮します。
CGI スクリプトの挙動に所望の設定を反映するには、
ウェブサーバが稼動される際のユーザのホームディレクトリに
\hgrc ファイルを作成して所望の設定を記述するか、
あるいはシステムワイドな \hgrc ファイルに所望の設定を追加してください。


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
