\chapter{Advanced uses of Mercurial Queues}
\label{chap:mq-collab}

Mercurial Queues の用法を真っ正直に話題にするのは簡単ですが、
少々抑制を効かせて、込み入った開発環境での作業に役立つような、
あまり利用されない機能を幾つか説明しようと思います。

この章では、
Linux カーネル向けの Infiniband デバイスドライバ開発において、
管理に用いていた技法を使用例として取り上げます。
このデバイスドライバは
（一般のデバイスドライバ程度には）大きく、
35 のソースファイルにまたがった 25,000 行からなっており、
少数の開発チームにより保守されています。

この章で扱っている対象は Linux に特化したものですが、
自身が所有していないコードを元に多くの開発を行う必要がある局面で、
同様の方針が適用できるでしょう。

\section{The problem of many targets}

Linux カーネルは頻繁に変更され、
内部的には決して安定していません。
開発者はリリースの間に度々思い切った変更を行います。
このため、
Linux カーネルの特定のリリース版で機能するドライバーの版は、
概して他の版においては\emph{コンパイル}すら通らない場合があります。

ドライバの保守を行うためには、
いくつかの個別の Linux の版を意識する必要があります。

\begin{itemize}
\item 第一には、メインの Linux カーネル開発ツリーです。
  この場合のコードの保守は、カーネルコミュニティの他の開発者と共有され、
  彼らがカーネルのサブシステムに対して行うのと同程度に、
  ``開発しながらの''変更が行われます。

\item 開発しているドライバを利用することができない古い 
  Linux ディストリビューションを使用している顧客の要望に応えるために、
  古い Linux カーネルの版に対する幾つかの``バックポート''の保守も必要です。
  （コードの\emph{バックポート}には、
  そのコードの開発対象となる版よりも古い版の環境で稼動させるための、
  コードの改変が必要です）

\item 最後になりますが、顧客の利用しているカーネルやディストリビューションの、
  全体に対する更新を強いることなく新規機能を提供するために、
  ソフトウェアのリリーススケジュールは、
  Linux ディストリビューションやカーネル開発者が利用しているカーネルと、
  必ずしも足並みを揃えるわけではありません。
  
\end{itemize}

\subsection{Tempting approaches that don't work well}

複数の異なる環境を対象としなければならない一連のソフトウェアの保守には、
２つの``標準的な''方法があります。

１つ目の方法は、
それぞれが単一の環境を対象とする複数のブランチを管理する方法です。
この方法の問題点は、
リポジトリ間での変更の往来\footnote{訳注: いわゆる「マージ」のこと}において、
鉄の規律でもって望む必要が有ることです。
新しい機能やバグの修正は``真新しい''リポジトリで始めなければならず、
その後で全てのバックポート用リポジトリに浸透させます。
バックポートでの変更は、その伝播が更にブランチ限定されます。
所属外のブランチに適用されるようなバックポート向けの変更は、
おそらくドライバのコンパイルを妨げるでしょう。

２つ目の方法は、
個々のコード片の有効／無効を、
意図する対象に依存して切り替えるための条件文で埋められた、
単一のソースツリーを保守する方法です。
これらの``ifdef''記述は、
Linux カーネルツリーでは許されていないので、
これらを取り除いて綺麗なツリーを生成するための、
手動ないし自動の手順が必要です。
この流儀で保守されるコードベースは早々に、
理解も保守も困難な条件分岐の「鼠の巣」となるでしょう。

これらのいずれの手法も、
正当なソースツリーのコピーを``所有''していない状況には適合しません。
標準カーネルと共に配布される Linux ドライバの場合、
Linus 氏のソースツリーは、
世界中が正統とみなすコードのコピーから構成されます。
上流リポジトリにおける``私の''ドライバは、
Linus 氏のソースツリー上に改変内容が反映されるまでには、
知らないうちに見知らぬ人々によって異なる版に改変されているかもしれません。

これらの手法は、
上流リポジトリへのパッチの体裁を整えるのを難しくしてしまう、
という欠点も持っています。

Mercurial Queues は、
これまで述べてきた状況での開発を管理するための、
良い候補と言えます。
まさにこのような状況において、
MQ は作業を快適にする更に幾つかの付加的機能を持っています。

\section{ガードによる条件付きパッチ適用}

おそらく、
多くの対象環境に対する健全性を保守する方法は、
所定の状況ごとに適用される特定のパッチを選択できること、
と言えるでしょう。
MQ は、
上記の機能を持つ``ガード''（quilt の \texttt{guards} コマンドに由来します）
と呼ばれる機能を提供します。
まずはじめに、
実験のための簡素なリポジトリを作成しましょう。

\interaction{mq.guards.init}

この手順により、
異なるファイルを操作するので互いには依存性の無い２つのパッチを持つ、
小さなリポジトリが得られます。

条件付き適用の考え方は、
任意の単純な文字列からなる\emph{ガード}された``札''
(tag)をパッチに付与しておき、
パッチ適用の際に、使用すべき特定のガードを MQ に対して教える、
というものです。
あらかじめ選択しておいたガードに応じて、
MQ はガードされたパッチを適用するか見送るかを決定します。

個々のパッチは任意の数のガードを持つことができ、
それぞれのガードは\emph{ポジティブ}
（``ガード選択時にパッチを適用する場合''）か\emph{ネガティブ}
（``ガード選択時にパッチ適用を見送る''）のどちらかです。
ガードを持たないパッチは常に適用されます。

\section{パッチのガードを制御する}

\hgxcmd{mq}{qguard} コマンドは、
どのガードをパッチに適用するかを決定するか、
さもなくば現時点で有効なガードを表示します。
引数が無い場合、現在の最上位パッチのガードを表示します。

\interaction{mq.guards.qguard}

パッチにポジティブなガードを設定するには、
ガード名の接頭辞として ``\texttt{+}'' を付与します。

\interaction{mq.guards.qguard.pos}

パッチにネガティブなガードを設定するには、
ガード名の接頭辞として ``\texttt{-}'' を付与します。

\interaction{mq.guards.qguard.neg}

\begin{note}
  \hgxcmd{mq}{qguard} コマンドは、パッチにガードを設定しますが、
  パッチのガード設定を\emph{変更}したりはしません。
  つまり、
  パッチに \hgcmdargs{qguard}{+a +b} を適用した後に、
  同じパッチに \hgcmdargs{qguard}{+c} を適用した場合、
  このパッチに設定されているガードは \texttt{+c} \emph{だけ}となります。
\end{note}

Mercurial は、
解釈・手動編集が共に容易な形式で、
ガード情報を \sfilename{series} に格納します
（言い換えるなら、
\hgxcmd{mq}{qguard} コマンドを利用する必要は無く、
\sfilename{series} ファイルを直接編集しても構いません）。

\interaction{mq.guards.series}

\section{使用するガードの選択}

\hgxcmd{mq}{qselect} コマンドは、有効にするガードを決定します。
ガードが決定することで、
次に \hgxcmd{mq}{qpush} を実行した際に MQ が適用するパッチが決定されます。
このコマンドはそれ以外の働きをしません。
特に、既に適用済みのパッチに対しては、一切何も行いません。

引数が指定されない場合、
\hgxcmd{mq}{qselect} コマンドは、
現時点で有効になっているガードを１行に１つづつ表示します。
個々の引数は、適用されるガードの名前とみなされます。

\interaction{mq.guards.qselect.foo}

現在選択されているガードの一覧が
\sfilename{guards} ファイルに格納されていますので、
興味があれば見てみるのも良いでしょう。

\interaction{mq.guards.qselect.cat}

\hgxcmd{mq}{qpush} を実行することで、
ガード選択の効果を見ることができます。

\interaction{mq.guards.qselect.qpush}


``\texttt{+}'' ないし ``\texttt{-}'' 
で始まる名前はガード名にはできません。
空白文字を含むものもガード名にはなれませんが、
それいがいの大抵の文字は使用可能です。
不正なガード名の使用は、MQ により警告されます。

\interaction{mq.guards.qselect.error} 

ガード選択の変更は、適用されるパッチを切り替えます。

\interaction{mq.guards.qselect.quux} 

ネガティブなガードがポジティブなガードに優先することを、
以下の例で見ることができます。

\interaction{mq.guards.qselect.foobar}

\section{MQ のパッチ適用ルール}

パッチ適用の有無を判定する際に、MQ は以下のルールを使用します。

\begin{itemize}
\item ガード無しパッチは常に適用されます。

\item 現在選択されているガードにマッチするネガティブガードがある場合、
  パッチは適用されません。

\item 現在選択されているガードにマッチするポジティブガードがある場合、
  パッチは適用されます。

\item 現在選択されているガードにマッチするガードが何も無い場合、
  パッチは適用されません。

\end{itemize}

\section{Trimming the work environment}

先に述べた
Linux カーネル向けの Infiniband
デバイスドライバ開発でのパッチ適用では、
Linux カーネルの通常のソースツリーは使用しません。
その代わり、
Infiniband デバイスドライバ開発に関連するソース／
ヘッダのみを含むリポジトリを作成し、
そこに対してパッチを適用するようにします。
このリポジトリのサイズはカーネルリポジトリの 1\% に収まるため、
作業を行うのも簡単です。

縮小版のリポジトリを作成したならば、
パッチの``適用対象''となるバージョンを選択します\footnote{訳注:
ここで言う「choose」（選択）は、
\hgcmd{update} 実行を指すのではないか？
そうであれば、次文が「これは〜スナップショットだ」というのも理解できる。}。
XXXXXXXXXXXX
This is a snapshot of the Linux kernel tree as of a revision
of my choosing.
XXXXXXXXXXXX
適用対象を選択する際に筆者は、
当該リビジョンのカーネルリポジトリにおけるチェンジセットIDを、
コミットメッセージ\footnote{訳注: パッチの？ XXXXXX}中に記録しておきます。
カーネルツリー中の開発に関連する部位に関して、
スナップショットによって``状況''と内容が特定できるため、
縮小版リポジトリと通常版のカーネルツリーのいずれに対しても、
パッチの適用が可能になります。XXXXXX
Since the snapshot
preserves the ``shape'' and content of the relevant parts of the
kernel tree, I can apply my patches on top of either my tiny
repository or a normal kernel tree.

通常は、
パッチの適用対象となるソースツリーのベースには、
上流リポジトリの直近のスナップショットを使用すべきです。
そうすることで、
作成したパッチを上流リポジトリの担当者へ送付する際に、
殆ど（あるいは全く）改変の必要が無くなるでしょう。

\section{Dividing up the \sfilename{series} file}

筆者は、\sfilename{series} に列挙されるパッチを、
幾つかの論理的なまとまりに分類しています。
それぞれのパッチ分類は、
その後に列挙されるパッチの意図を記述したコメントブロックで開始されます。

筆者の扱っているパッチ分類は、以下のような並びになっています。
分類の順序は重要なので、分類を紹介した後で説明します。

\begin{itemize}
\item ``受理済み(accepted)''分類: 
  開発チームが Infiniband サブシステムの保守担当に送付して、
  既に受理はされているものの、
  縮小版リポジトリが元にしているスナップショットには、
  まだ反映されていないパッチの分類です。
  これらは、
  上流リポジトリの保守担当のリポジトリと同じ状態を得るために、
  ソースツリーを変換する``読み出し限定''パッチです。

\item ``再作業(rework)''分類:
  上流リポジトリの保守担当に送付したものの、
  受理に当たって変更を要求されたパッチの分類。

\item ``保留(pending)''分類:
  上流リポジトリの保守担当に送付こそしていないものの、
  既に作業を終えたパッチの分類。
  しばらくの間は``読み出し限定''として扱われます。
  上流リポジトリの保守担当により受理されれば、
  このパッチを``受理済み''分類の末尾へと移動します。
  受理に当たって変更が要求された場合、
  ``再作業''分類の先頭へと移動します。

\item ``作業中(in progress)''分類:
  目下のところ活発に作業が行われているパッチの分類。
  この分類のパッチは、外部に公開すべきではありません。

\item ``バックポート(backport)''分類:
  古い版のカーネルのソースツリーに適合させるためのパッチの分類。

\item ``内部用(do not ship)''分類:
  何らかの理由により、上流リポジトリの保守担当へは送付されないパッチの分類。
  このようなパッチの例としては、
  ドライバ識別用の埋め込み文字列の変更を行うことで、
  ソースツリーのものとは異なるドライバ実装の版
  \footnote{訳注: 開発中のドライバのこと？}と、
  ディストリビューションベンダによって配布されるドライバ実装の版の間で、
  動作確認等における区別を容易にするパッチがあります。

\end{itemize}

ではここで、パッチ分類尾をこの順番にする理由に戻りましょう。
コンテキストの変更が発生することで、
スタック上方のパッチへの再作業
\footnote{訳注: \hgxcmd{mq}{qrefresh} の実行によるパッチの修正のこと}
が必要になることが無いように、
スタック中で底にあるパッチほど安定していて欲しいものです。
変更されにくいパッチ群を
\sfilename{series} ファイルの冒頭に置くことで、
この目的を達成することができます。

他のパッチの適用を極力上流リポジトリの状態に近いソースツリーへ行うために、
ソースツリーの変換に必要と思われるパッチも重要です。
受理済みのパッチも暫くの間保持しているのはそのためです。

``バックポート''および``内部用''パッチは、
\sfilename{series} 末尾近辺を転々とします。
バックポートパッチは他の全てのパッチ適用の上で適用されなければなりませんし、
その上、
``内部用''パッチは不都合が無いように内部に留まり続ける必要があります。

\section{Maintaining the patch series}

筆者の作業の際には、
パッチ適用を制御するために複数のガードを使用しています。

\begin{itemize}
\item ``受理済み''パッチには、\texttt{accepted} ガードが付与されます。
  このガードは殆どの場合に有効とされます。
  既にパッチが適用されているソースツリーにパッチを適用する際には、
  パッチを適用させないようにすることが
  \footnote{訳注: \texttt{accepted} ガード付きパッチを無効にすることで}
  できるので、
  後続のパッチ群は綺麗に適用されます。

\item 作業は``完了''しているものの、
  上流リポジトリの保守担当に送付されていないパッチ
  \footnote{訳注: 先の分類で言うところの``保留(pending)''}には、
  何もガードが付与されません。
  上流リポジトリのコピーに対してパッチスタックを適用する場合、
  特に何もガードを指定しなくても、
  適度に安全なソースツリーを得ることができます。

\item 上流リポジトリの保守担当への（再）送付に当たって、
  再作業が必要なパッチには \texttt{rework} ガードが付与されます。

\item 目下開発作業中にあるパッチ
  \footnote{訳注: 先の分類で言うところの``作業中(in progress)''}には、
  \texttt{devel} ガードが付与されます。

\item バックポートパッチには、
  適用対象カーネルのバージョンを指定する複数のガードが付与されます。
  例えば、~2.6.9 版へのバックポートを行うパッチには、
  \texttt{2.6.9} ガードが付与されます。

\end{itemize}

これらのガード分類により、
最終的にどのようなソースツリーが得られるかを決定する際に、
少なからぬ柔軟性を得ることができます。
多くの場合、
適切なガードの選択は構築手順の中で自動化されていますが、
特別な状況向けにガードの調整を手動で行うことも可能です。

\subsection{The art of writing backport patches}

MQ を使用することで、
バックポートパッチの作成は単純な作業となります。
旧版のカーネル配下においてもドライバが正常に稼動するように、
旧版のカーネルにおいて提供されていない機能を使用するコードの変更が、
バックポートパッチのすべきことの全てです。

良いバックポートパッチを書く際のゴールは、
対象とする旧版カーネル向けに書いたかのように、
あなたのコードを変更するようなパッチにすることです。
パッチがでしゃばらない程、理解と保守が容易になります。
コード中の大量の \texttt{\#ifdef}（条件に応じて適用されるコード片）
による``鼠の巣''化を避けるためにバックポートパッチ群を書くのであれば、
バージョン依存な \texttt{\#ifdef} をパッチに持ち込むべきではありません。
バージョン依存な \texttt{\#ifdef} を使用する替わりに、
個々のパッチはバージョンに依存しない変更を行うようにして、
パッチの適用をガードによって制御すべきです。

``通常''のパッチと、
その適用結果を更に変更するバックポートパッチとを、
別個のグループに分離するのには２つの理由があります。
第１の理由は、
これらのパッチが混ざり合った場合に、
上流リポジトリの保守担当へのパッチ送付の自動化の際に、
\hgext{patchbomb} 拡張のようなツールを使うことが難しくなるためです。
第２の理由は、
後続の通常パッチの適用コンテキスト
\footnote{訳注: \command{patch} ファイルにおける「コンテキスト」}
をバックポートパッチが混乱させてしまい、
通常パッチの適用前に適用されたバックポートパッチ\emph{抜き}では、
通常パッチを綺麗に適用することができなくなってしまうためです。

\section{Useful tips for developing with MQ}

\subsection{Organising patches in directories}

MQ を利用した実在するプロジェクトで作業をしているのであれば、
多くのパッチを蓄積することも難しいことではありません。
例えば、筆者は 250 を超えるパッチを抱えたパッチリポジトリを持っています。

パッチを個別の論理的なまとまりに分類できるのであれば、
MQ はパッチ名にパス区切りが含まれていても問題ないので、
それぞれのパッチを異なるディレクトリに格納することもできます
\footnote{訳注: MQ はパッチ内容の保存先として、
パッチ名と同名のファイルを作成するため、
パッチ名にパス区切りが含まれる場合、
MQ は自動的にサブディレクトリを作成します}。

\subsection{Viewing the history of a patch}
\label{mq-collab:tips:interdiff}

長期間にわたってパッチの開発を行う場合、
\ref{sec:mq:repo} 節で述べたように、
パッチをリポジトリで管理するのが良いでしょう。
その場合は早々に、
パッチの変更履歴の参照に 
\hgcmd{diff} が使えないことに気付くことでしょう。
これは実際のコードの二次派生物(差分の差分)を見ていること以外にも、
タイムスタンプやパッチ更新時のディレクトリ名等を改変することで
MQ が雑音を加えてしまっていることに原因があります。

Mercurial に同梱されている \hgext{extdiff} 拡張を使うことで、
２つの版のパッチ差分を幾分読みやすいものにすることができます。
この拡張を使うためには、
サードパーティーパッケージである
\package{patchutils}~\cite{web:patchutils} が必要です。
このパッケージが提供する \command{interdiff} というコマンドは、
差分間の差分を１つの差分として表示します。
同じ差分の２つの版
\footnote{訳注: 「同じパッチの異なる版」の意か？}
に対してこのコマンドを適用すると、
最初の版から次の版へと変更するための差分を生成します。

いつものように、
\hgrc ファイルの \rcsection{extensions} 
セクションに行を追加することで、
\hgext{extdiff} 拡張を有効化することができます。

\begin{codesample2}
  [extensions]
  extdiff =
\end{codesample2}

\command{interdiff} コマンドは２つのファイル名の指定が必要ですが、
\hgext{extdiff} 拡張は、
それぞれ任意の数のファイルを配下に持つ、
２つのディレクトリに対して動作するプログラムの指定が必要です。
そのため、
これら２つのディレクトリ配下の個々のファイル対に対して
\command{interdiff} を実行する小さなプログラムが必要です。
本書のソースコードリポジトリにおける
\dirname{examples} ディレクトリ配下に、
\sfilename{hg-interdiff} として格納されています。

\excode{hg-interdiff}

\sfilename{hg-interdiff} がシェルのコマンド検索パス上に有る場合、
MQ のパッチディレクトリから以下のようにして起動することができます。

\begin{codesample2}
  hg extdiff -p hg-interdiff -r A:B my-change.patch
\end{codesample2}

おそらくこの長たらしいコマンドを何度も使うことになるでしょうから、
再度 \hgrc を編集して、
\hgext{hgext} を Mercurial の普通のコマンド並に使えるようにしましょう。

\begin{codesample2}
  [extdiff]
  cmd.interdiff = hg-interdiff
\end{codesample2}

この記述により \texttt{interdiff} が
\hgext{hgext} から利用できるようになりますので、
先の \hgxcmd{extdiff}{extdiff} 起動も短くなって幾分使いやすくなるでしょう。

\begin{codesample2}
  hg interdiff -r A:B my-change.patch
\end{codesample2}

\begin{note}
  \command{interdiff} コマンドは、
  場合だけ正しく機能します。
  The \command{interdiff} command works well only if the underlying
  files against which versions of a patch are generated remain the
  same.  
  パッチの生成・ファイルの変更およびパッチの更新を行った場合、
  \command{interdiff} は有用な出力を生成しないことがあります。
\end{note}

\hgext{extdiff} 拡張は、
MQ パッチの表示機能の向上に留まらない有用なものです。
\hgext{extdiff} 拡張に関する詳細は、
\ref{sec:hgext:extdiff} 節を参照してください。

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
