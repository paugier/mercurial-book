\chapter{Managing releases and branchy development}
\label{chap:branch}

Mercurial は、
同時並行的に開発を進めるようなプロジェクトを管理できる仕組みを持っています。
これらの仕組みを理解するために、
まずは一般的なソフトウェア開発の仕組みを眺めてみましょう。

多くのソフトウェアプロジェクトでは、
重要な新規機能を含む``メジャー''リリースを間欠的に発行します。
それと平行して``マイナー''リリースも発行することがあります。
多くの場合、
マイナーリリースは元にしたメジャーリリースと同一ですが、
バグの修正がなされています。

この章では、
「リリース」のようなプロジェクトのマイルストーンの、
記録を保持する方法から説明を始めたいと思います。
その後で、
プロジェクトにおけるフェーズ移行での作業の流れや、
その際の作業や成果物を
Mercurial によって分離／管理する方法を説明します。

\section{Giving a persistent name to a revision}

特定のリビジョンを``リリース''と呼ぶことに決定したなら、
そのリビジョンの ID を記録するべきです。
リビジョンの ID を記録することで、
後日何らかの理由（例えばバグの再現や、新規プラットフォームへの移植等）
で必要になった際にリリースを再現することができます。

\interaction{tag.init}

\hgcmd{tag} コマンドを利用することで、
Mercurial は任意のリビジョンに永続的な名前を付与します。
読者の予想通り、この名前のことを``タグ''と呼びます。

\interaction{tag.tag}

リビジョンにとって、
タグは``象徴的な名前''(symbolic name) 以外の何者でもありません。
タグは純粋に利便性のために存在するもので、
リビジョンを参照する際の手軽で永続的な手段となります。
Mercurial は、
利用者の用いるタグ名の意味を解釈したりしません。
曖昧さが無く解析できることを保証するために必要な少々の制約を除いては、
タグ名に何らかの制約をつけたりすることもありません。
以下のいずれの文字もタグ名には使用できません。

\begin{itemize}
\item コロン(ASCII 58, ``\texttt{:}'')
\item 行頭移動\footnote{carriage return} (ASCII 13, ``\Verb+\r+'')
\item 改行 (ASCII 10, ``\Verb+\n+'')
\end{itemize}

\hgcmd{tags} コマンドを使用することで、
リポジトリが保持しているタグを表示させることができます。
\hgcmd{tags} コマンドの出力において、
個々のタグ付けされたリビジョンは、
始めにタグ名で、次にリビジョン番号で、
最後に一意のリビジョンハッシュ値で識別されます。

\interaction{tag.tags}

\texttt{tip} タグが \hgcmd{tags} 
コマンドの出力に列挙されていることに注意してください。
\texttt{tip} は、常にリポジトリ中の最新のリビジョンを指す
``流動的な''特殊タグです。

\hgcmd{tags} コマンドの出力では、
タグはリビジョン番号の逆順（降順）で列挙されています。
これは最新のタグは古いタグよりも先に列挙されることを意味し、
それは同時に \hgcmd{tags} が出力するタグ一覧の最初に
\texttt{tip} が表示されることも意味します。

\hgcmd{log} コマンドの実行時に、
タグと関連付けられたリビジョンを表示する場合、
\hgcmd{log} コマンドはタグを表示します。

\interaction{tag.log}

Mercurial コマンドに対してリビジョン識別子を指定する必要がある場合、
リビジョン識別子を指定する位置では、
常にタグ名を使用することができます。
Mercurial の内部では、
タグ名を対応するリビジョン識別子に変換してから使用しています。

\interaction{tag.log.v1.0}

単一のリポジトリが保持できるタグの数にも、
単一のリビジョンに付与できるタグの数にも制限はありません。
現実的な問題として、
タグは単にリビジョンの特定を補助するものですから、
``過剰に''（具体的な数はプロジェクトに応じて異なりますが）
タグを付与するのはよろしくありません。
多くのタグがあると、リビジョンを特定する利便性が早々に減少してしまいます。

例えば、
あるプロジェクトでは数日毎の頻度でマイルストーンを設定しているとすると、
それぞれのマイルストーンにタグを付与するのは極めて合理的です。
しかし、全てのリビジョンで確実に綺麗なビルドができる継続的
（continuous）なビルドシステムがある場合は、
綺麗なビルド毎にタグを付与すると、大量のノイズを持ち込むことになります。
その代わりに、
ビルドが失敗するリビジョン（この事態が稀だと仮定しています！）
にタグを付与するか、
ビルドの可否を追跡するタグの使用を止めるのが良いでしょう。

必要の無くなったタグを削除したい場合は
\hgcmdargs{tag}{--remove} コマンドを使用します。

\interaction{tag.remove}

任意の時点でタグの関連付けを変更することもできますので、
新規の \hgcmd{tag} コマンド実行により、
同一のタグが異なるリビジョンを識別するようになります。
\emph{本当に}タグを更新したいことを Mercurial に伝えるために、
\hgopt{tag}{-f} オプションを使用しなければなりません。

\interaction{tag.replace}

タグの更新後も、
タグが以前に識別していたリビジョンに関する永続的な記録が残りますが、
Mercurial がそれを使用することはありません。
このように、
間違ったリビジョンへのタグの付与には何の不利益もありませんので、
タグ付けを間違ったなら、正しいリビジョンにタグを付与し直せばよいのです。

Mercurial は、
リポジトリ中のリビジョン管理された通常ファイルにタグの情報を格納しています。
何らかのタグを付与すると、
\sfilename{.hgtags} ファイル中にそのタグを見つけることができるでしょう。
\hgcmd{tag} コマンドを実行すると、
Mercurial はこのファイルを変更し、自動的に変更をコミットします。
このことは、
\hgcmd{tag} コマンドを実行した際には、
常に対応するチェンジセットを \hgcmd{log} コマンドの出力で見ることができる、
ということを意味しています。

\interaction{tag.tip}

\subsection{Handling tag conflicts during a merge}

\sfilename{.hgtags} ファイルを気にする必要は殆どありませんが、
時にはマージの際にその存在が意識されることがあります。
このファイルの形式は単純で、連続した行から構成されています。
各行はチェンジセットのハッシュ値で始まり、空白とタグ名が続きます。

マージにおける
\sfilename{.hgtags} ファイルの衝突を解消する際には、
\sfilename{.hgtags} ファイル修正にひねりが必要です。
リポジトリ中のタグを解析する場合、
Mercurial は\emph{決して} 
\sfilename{.hgtags} ファイルのワーキングコピーを参照することはありません。
その代わりに、Mercurial 
は\emph{最も最近コミットされた}ファイルのリビジョンを調べます。

このような設計の残念な結果として、
マージした \sfilename{.hgtags} ファイルが、
その変更をコミットした\emph{後も}正しい状態であることを、
実際に検証することができません。
マージの際に \sfilename{.hgtags} ファイルの衝突を解消する際には、
コミット後に \hgcmd{tags} コマンドの実行を忘れずに行ってください。
\sfilename{.hgtags} ファイルに不正があった場合、
\hgcmd{tags} コマンドは不正の場所を報告しますので、
その箇所を修正してコミットすれば良いのです。
変更内容の正しさを確認するために、
変更の後で、再度 \hgcmd{tags} コマンドを実行してください。

\subsection{Tags and cloning}

\hgcmd{clone} コマンドが
特定のチェンジセットを指定して厳密な複製を作成するための
\hgopt{clone}{-r} オプションを持っていることに気付いているかもしれません。
新しい複製は、
指定したリビジョンよりも後に生じた履歴情報を一切持っていません。
このことがタグと相互作用した場合、、
油断していると驚かされる事態になります。

タグの生成が、
\sfilename{.hgtags} ファイルへの格納の際に、
一つのリビジョンとして扱われることを思い出せば、
タグが記録されたチェンジセットが、
タグの付与対象となる（古い）チェンジセットを参照するのは当然のことです。
タグ \texttt{foo} 時点のリポジトリを複製するために
\hgcmdargs{clone}{-r foo}  を実行した場合、
複製されたリポジトリは、
複製する際に使用された\emph{タグの作成に関する履歴を持っていません}。
新しいリポジトリには、
プロジェクト履歴の完全なサブセットが含まれますが、
唯一、指定に用いたタグの情報は\emph{含まれていません}。

\subsection{When permanent tags are too much}

Mercurial のタグは構成管理されており、
プロジェクトの履歴と一体化しているため、
誰かが作成したタグは、
一緒に作業を行っている誰もが見ることができます。
しかし、リビジョンに名前を付けることは、
リビジョン \texttt{4237e45506ee} が実は \texttt{v2.0.2}  である、
ということを書き留めておく以上の有用性があります。
巧妙なバグを追跡する際に、
``アンがこのリビジョンで症状を見かけた''といった類の備忘録として、
タグを付与したい場合もあるでしょう。

このような場合、
\emph{ローカル}なタグが最適です。
\hgopt{tag}{-l} オプション付きで
\hgcmd{tag} コマンドを起動することで、
ローカルタグを作成することができます。
このコマンド実行の場合、
タグは \sfilename{.hg/localtags} ファイルに格納されます
\sfilename{.hgtags} と異なり
\sfilename{.hg/localtags} は構成管理されません。
\hgopt{tag}{-l} によって作成したタグは、
現在作業をしているリポジトリに留まり続けます
\footnote{訳注: \hgcmd{clone}、\hgcmd{pull} や 
\hgcmd{push} によって他のリポジトリにコピーされることがありません}。

\section{The flow of changes---big picture vs. little}

ここで、本章の冒頭で述べた概略に戻り、
複数の平行した開発が同時に行われているプロジェクトについて考えて見ましょう。

新しい``主''リリースや、
最新の主リリースに対する新たなマイナーバグ修正、
現在は保守状態にあるような古いリリースに対する予期せぬ``hot fix''
のための push があるでしょう。

開発における様々な平行した方向を参照するための一般的な方法は、
``ブランチ''と呼ばれるものです。
しかし、
Mercurial が\emph{全ての履歴}を
「ブランチとマージの連続」として扱っていることを、
既に何度も見てきました。
実際には、
表面的には関係しているようで、
その実、たまたま同じ名前であるだけの２つの概念を扱っているのです。

\begin{itemize}
\item ``巨視的な''ブランチは、プロジェクト発展の広がりを表し、
  名前をつけたり、話題に上ったりします。

\item ``微視的な''ブランチは、日々の開発活動と、変更マージの成果です。
  このブランチは、コードがどのように開発されていったのかを物語ります。

\end{itemize}

\section{Managing big-picture branches in repositories}

Mercurial において``巨視的な''ブランチを隔離する最も簡単な方法は、
隔離用のリポジトリを用意することです。
例えば、既にある共有リポジトリ---これを \texttt{myproject} と呼称します
---が ``1.0'' というマイルストーンに到達している場合、
1.0 リリースのために使用したリビジョンにタグを付与することで、
1.0 版に対する来るべき保守リリースの準備を行います。

\interaction{branch-repo.tag}

タグ付けした時点と同じ内容の
\texttt{myproject-1.0.1} 
という名の新しい共有リポジトリを複製します。

\interaction{branch-repo.clone}

その後、
来る 1.0.1 マイナーリリースに含めるべきバグ修正の作業が必要になったなら、
\texttt{myproject-1.0.1} リポジトリを複製し変更を行って、
その成果を反映します。

\interaction{branch-repo.bugfix}

その間、次のメジャーリリースへ向けた開発作業は、
マイナーリリースに関する作業とは隔離された状態で、
\texttt{myproject} リポジトリにおいて活発に続けられます。

\interaction{branch-repo.new}

\section{Don't repeat yourself: merging across branches}

保守用ブランチでバグ修正を行ったとすると、
多くの場合、プロジェクトのメインブランチに
（そしてそれ以外の保守ブランチにおいても）
同じバグが存在する可能性があります。
同じバグを何度も直したいと思う開発者は稀ですから、
同じ作業を繰り返すことなくバグ修正を管理するために
Mercurial が提供する幾つかの方法を見てみましょう。

最も単純な方法は、
作業対象ブランチから複製したローカルリポジトリへ、
保守ブランチから変更を pull することです。

\interaction{branch-repo.pull}

その上で２つのブランチのそれぞれのヘッドをマージし、
その成果をメインブランチに反映します。

\interaction{branch-repo.merge}

\section{Naming branches within one repository}

多くの場合は、
リポジトリの分離によってブランチを分離するのが適切な遣り方です。
単純ですから理解も簡単ですし、それ故に間違えることがありません。
作業しているブランチと、コンピュータ上の（リポジトリ）ディレクトリの間で、
１対１の関係ができていますので、
ブランチ／リポジトリ中のファイルに対して、
（Mercurial を意識しない）通常のツールを使用することもできます。

あなたが（そして共同作業者も）
``パワーユーザー''よりも高いレベルにあるのであれば、
ブランチ(that you can consider XXXX)を扱う別な方法があります。
前の節では、
``微視的''ブランチと``巨視的''ブランチの、
利用者レベルでの区別について言及しました。
単一のリポジトリ中で、
常に複数の``微視的な''ブランチ
（例えば、変更の pull 後にマージしていない状態）を扱っている一方で、
Mercurial は複数の``巨視的な''ブランチを扱うこと\emph{も}できます。

Mercurial が``巨視的な''ブランチを扱う際の要点は、
ブランチに永続的な\emph{名前}を付けるところにあります。
前述のように \texttt{default} という名前のブランチが常に存在しますので、
ブランチへの命名を行う前であっても、
探せば \texttt{default} ブランチの跡を見つけることができます。

例えば、
\hgcmd{commit} コマンドを実行すると、
エディタが起動されてコミットメッセージを入力できます
\footnote{訳注: Emacs の hg-mode.el を使用している場合は見られません}が、
末尾の ``\texttt{HG: branch default}'' を含む行を見てください。
これは、\texttt{default} という名前のブランチに対してコミットしている、
ということを表しています。

ブランチに名前をつけるには、
まずは \hgcmd{branches} を使用します。
このコマンドは、リポジトリ中に既に存在する名前付きブランチと、
個々のブランチにおける先頭（tip）リビジョンがどれかを列挙します。

\interaction{branch-named.branches}

実行例では、
名前付きブランチを生成する前ですから、
唯一存在する \texttt{default} だけが表示されます。

どれが``現在の''ブランチかを知るには、
引数無しで \hgcmd{branch} コマンドを実行します。
このコマンドは、
現在のチェンジセットの親チェンジセットが、
どのブランチ上にあるものかを表示します。

\interaction{branch-named.branch}

新しいブランチを作成するには、
再度 \hgcmd{branch} コマンドを実行しますが、
今回は生成するブランチ名を引数として指定します。

\interaction{branch-named.create}

ブランチ生成後、
\hgcmd{branch} コマンドによりどのような副作用を生じたのか、
怪しむかもしれません。
\hgcmd{status} や \hgcmd{tip} の出力はどうなっているでしょうか？

\interaction{branch-named.status}

作業領域に変更は加えられていませんし、
履歴に変化もありません。
このことが示唆しているように、
\hgcmd{branch} コマンドの実行は何ら永続的な効果を持ちません。
このコマンドは、
\emph{次回の}チェンジセットのコミットの際に、
何というブランチ名を使用するかを
Mercurial に伝えるだけです。

変更をコミットすると、
Mercurial はコミットされたチェンジセットにブランチ名を記録します。
一旦 \texttt{default} ブランチから他のブランチに切り替えてコミットしたなら、
\hgcmd{log}、\hgcmd{tip} やそれに類する出力を持つコマンドの出力に、
新たなブランチ名が表示されていることでしょう。

\interaction{branch-named.commit}

\hgcmd{log} に類するコマンドは、
\texttt{default} ブランチ以外に属する全てのチェンジセットに対して、
ブランチ名を表示します。
そのため、名前付きブランチを使わない限り、
ブランチに関する情報を見ることはありません。

名前付きブランチを作成し、そのブランチ名で変更をコミットしたならば、
その変更に連なるその後のコミットは、同じブランチ名を引き継ぎます。
\hgcmd{branch} コマンドにより、
任意の時点でブランチ名を変更することができます。

\interaction{branch-named.rebranch}

ブランチ名はかなり長い寿命を持つため、
実際にはこのようなブランチ名の変更はそれほど頻繁に実行することは無いでしょう
（このことは規約ではなく、あくまで感想です）。

\section{Dealing with multiple named branches in a repository}

リポジトリに複数の名前付きブランチがある場合、
\hgcmd{update} や \hgcmdargs{pull}{-u} といったコマンド実行の際に、
Mercurial は作業領域ディレクトリが属するブランチを覚えていて、
``リポジトリ全体''の tip リビジョンではなく、
そのブランチの tip リビジョンで作業領域ディレクトリを更新します。
別な名前付きブランチのリビジョンで更新したい場合は、
\hgcmd{update} コマンドに
\hgopt{update}{-C} オプションを指定しなければなりません。

この振る舞いは少々微妙ですから、実例で見てみましょう。
始めに、
どのブランチ上で作業しているのかと、
どんなブランチがリポジトリ中に有るのかを確認します。

\interaction{branch-named.parents}

現在 \texttt{bar} ブランチ上にいますが、
古い \hgcmd{foo} ブランチも存在します。

\texttt{foo} ブランチおよび \texttt{bar} ブランチの
tip リビジョンへの移動は、
変更履歴上を直線的に前後することしか必要としないため、
\hgcmd{update} コマンドに
\hgopt{update}{-C} オプションを指定すること無しに、
それぞれの tip リビジョンへの更新を行うことができます。

\interaction{branch-named.update-switchy}

\texttt{foo} ブランチに戻るために
\hgcmd{update} コマンドを実行すると、
\texttt{foo} ブランチ上に留まったままで
\texttt{bar} ブランチの tip リビジョンには移動しません。

\interaction{branch-named.update-nothing}

\texttt{foo} ブランチでの変更のコミットにより、
新たなヘッドが生成されます。

\interaction{branch-named.foo-commit}

\texttt{foo} ブランチから \texttt{bar} ブランチへの更新は、
履歴を``横っ飛び''しないとできませんから、
Mercurial は
\hgcmd{update} コマンドへの \hgopt{update}{-C}
オプションの指定を必要とします。

\interaction{branch-named.update-bar}

\section{Branch names and merging}

お気づきの事とは思いますが、
Mercurial におけるマージ処理は対称的ではありません。
リビジョン番号 17 のものと 23 のもの、
２つのヘッドをリポジトリが持っているものとしましょう。
リビジョン 17 へと \hgcmd{update} 
してからリビジョン 23 と \hgcmd{merge} した場合、
Mercurial はリビジョン 17 をマージの第１親、
リビジョン 23 を第２親として記録します。
一方で、
リビジョン 23 へと \hgcmd{update}
してからリビジョン 17 と \hgcmd{merge} した場合、
リビジョン 23 がマージの第１親、
リビジョン 17 が第２親として記録されます。

この振る舞いが、マージを行った際の Mercurial のブランチ名選択に影響します。
マージ後にその結果をコミットすると、
Mercurial は第１親のブランチ名を維持しようとします。
第１親のブランチ名が \texttt{foo} で、
\texttt{bar} ブランチのリビジョンとマージした場合、
マージ後のブランチ名は \texttt{foo} のままとなります。

リポジトリ中に同じブランチ名の複数のヘッドが存在することは、
それほど珍しいことではありません。
例えば、私とあなたが \texttt{foo} ブランチで作業しているとします。
二人がそれぞれ異なる変更をコミットし、
私があなたの変更を pull しました。
この時点で私のリポジトリには、
\texttt{foo} ブランチ上に２つのヘッドが存在します。
マージの結果、
\texttt{foo} ブランチ上の２つのヘッドは期待通り１つになります。

しかし、私が \texttt{bar} ブランチで作業していて、
\texttt{foo} ブランチの成果をマージした場合、
マージの結果は \texttt{bar} ブランチ上に留まります。

\interaction{branch-named.merge}

より具体的な例として、
\texttt{bleeding-edge} ブランチで作業していて、
最新の成果を \texttt{stable} ブランチから持ち込みたいと思ったとします。
この場合、
\texttt{stable} ブランチの成果を pull してマージした段階で、
Mercurial は``適切な''ブランチ名(\texttt{bleeding-edge})を選択します。

\section{Branch naming is generally useful}

寿命の長い複数のブランチが単一リポジトリで共存している状況だけが、
名前付きブランチの利用できる状況だとは考えないでください。
リポジトリ１つにブランチ１つの状況であっても、
名前付きブランチは有用です。

単純な例としては、
ブランチに名前を付与することで、
チェンジセットがどのブランチに由来するかの恒久的な記録を得ることができます。
この記録は、
寿命の長いブランチを持つプロジェクトの履歴を辿る際に、
多くの情報をもたらすことでしょう。

リポジトリを共有して作業している場合、
\hook{pretxnchangegroup}  フックをそれぞれのリポジトリに対して設定することで、
``不正な''ブランチ名を持つ変更が持ち込まれるのを防ぐことができます。
この手法は単純ですが、
``血の滴る刃''とでも言うべき（不安定な）ブランチの成果を、
誤って``安定した''ブランチへと持ち込むことを防ぐには効果的です。
このようなフックは、
共有リポジトリの \hgrc ファイルに以下のように記述します。

\begin{codesample2}
  [hooks]
  pretxnchangegroup.branch = hg heads --template '{branches} ' | grep mybranch
\end{codesample2}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
