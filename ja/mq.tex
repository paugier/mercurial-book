\chapter{Managing change with Mercurial Queues}
\label{chap:mq}

\section{パッチ管理問題}
\label{sec:mq:patch-mgmt}

ソフトウェアパッケージをソースからインストールする必要があるのに、
パッケージ使用前に修正しておかなければならないバグをソース中に発見してしまう、
というような事態はよくあることです。
  変更の後、暫くパッケージのことを忘れていると、
数ヵ月後にパッケージを新しい版で更新する必要が出てきたとします。
  パッケージの新しい版が未だにバグを残していたなら、
古い版のソースツリーから修正内容を抽出して、
新しい版に適用しなければなりません。
  このような作業は退屈で間違いを起こしやすいものです。

これは``パッチ管理''問題の単純なケースです。
  自分では変更することができない``上流''のソースツリーがあるとします。
上流のソースツリーの上でローカルな修正を行う必要があるなら、
上流ソースの新しい版に対してローカルな修正を適用できるように、
そういった修正を別途管理したいと思うでしょう。

パッチ管理問題はさまざまな状況で発生します。
オープンソースソフトウェアプロジェクトのユーザが、
プロジェクトのメンテナンス担当へ、
バグ修正や新規機能をパッチ形式で送付する状況が、
おそらく最もわかりやすい状況でしょう。

オープンソースソフトウェアを含むオペレーティングシステムの配布者は、
配布するパッケージに対する変更を頻繁に行うので、
自分たちの環境においてビルドを行うのは当然のことです。

整備の上で幾つか変更を行いたい場合、
標準的な
\command{diff} および \command{patch} プログラム
（これらのツールに関する議論は \ref{sec:mq:patch} 節を参照のこと）
を使用して、単一のパッチを管理することは簡単です。
しかし、一旦変更の数が増え始めると、
単一のパッチの管理は関連性の無い``成果の塊''に感じ始めるため、
例えば、単一のパッチは単一のバグ修正のみを含む
（パッチは複数のファイルを修正するかもしれませんが、
``単一の事''しか行わない）ようになるでしょうから、
異なるバグやローカルな修正に必要とされるパッチを、
いくつも抱えることになるかもしれません。
  このような状況で、
上流のパッケージ保守担当者にバグ修正のパッチを送ったとすると、
彼らはその後のリリースにおいてその修正を取り込むでしょうから、
新しい版への更新の際には、
そのパッチの適用を取りやめることができます。

上流のソースツリーに対して単一のパッチを保守することは、
退屈で間違いやすいですが難しくはありません。
  しかし、保守しなければならないパッチの数が増えるにしたがい、
問題の複雑さはすみやかに増加します。
  すくなからぬパッチを抱え込むことで、
適用の有無を把握したり、それらを保守することが、
「面倒なこと」から「圧倒されること」へと変化するでしょう。

幸いなことに、Mercurial は
Mercurial Queues
（あるいは単に ``MQ''）と呼ばれる、
パッチ管理問題を簡素化する強力な拡張機能を持っています。

\section{Mercurial Queues 以前}
\label{sec:mq:history}

1990 年代後半、何人かの Linux カーネル開発者達は、
Linux カーネルの挙動を変える``パッチ系列''の保守を始めていました。
幾つかの系列は安定性に、幾つかは網羅性に、
その他の系列はより実験的な部分に焦点を当てていました。

これらのパッチのサイズは速やかに巨大化しました。
2002 年、Andrew Morton が、
自分のパッチキュー管理作業を自動化するのに用いていた、
幾つかのシェルスクリプトを発表しました。
Andrew は、
Linux カーネルソース上での数百（時には数千）のパッチの管理に、
これらのスクリプトを上手に利用していました。

\subsection{A patchwork quilt（訳注：継ぎはぎの上掛け）}
\label{sec:mq:quilt}

2003 年の初頭、
Andreas Gruenbacher と Martin Quinson は、
Andrew によるスクリプトの手法を取り入れて、

``patchwork quilt''~\cite{web:quilt} あるいは単に ``quilt''
(これについて述べた論文は~\cite{gruenbacher:2005}を参照のこと)
と呼ばれるツールを発表しました。
  パッチ管理が大幅に自動化されることから、
quilt はオープンソース開発者の間で瞬く間に大きな支持を得ました。

quilt は、
最上位のディレクトリにおいて\emph{パッチのスタック}を管理します。
管理開始の際には、
quilt に対してディレクトリツリーを管理する旨と、
どのファイルを管理したいのかを伝えます。
quilt はこれらのファイルの名前と内容を別な場所に保存します。
  バグの修正の際には、
新しいパッチを（単一のコマンドを使用して）作成し、
修正する必要の有るファイルの編集を行い、
パッチを``refresh''します。

refresh の段階で quilt はディレクトリツリーを走査します。
quilt は実施された全ての変更でパッチを更新します。
最上位のディレクトリにおいて作成した別なパッチを用いることで、
``１つのパッチが適用されたツリー''から
``２つのパッチが適用されたツリー''へと変化させるために必要な変更を、
追跡することができます。

ツリーに対するパッチの適用状況を\emph{変更}することもできます。
パッチを``pop''すると、
そのパッチによる変更はディレクトリツリーから取り除かれます。
しかし、
quilt はどのパッチが取り除かれたのかを覚えているので、
取り除かれたパッチを再び``push''することができ、
ディレクトリツリーには当該パッチによる変更が復元されます。
最も重要な点は、
``refresh''コマンドの実行と、
それによる最上位のパッチの内容更新が任意の時点にできることです。
これは、
パッチの適用状況と、そのパッチによる変更内容の両方を、
任意の時点で変更できることを意味します。

quilt は変更制御ツールを意識しないため、
展開された tarball の最上位ディレクトリにおいても、
Subversion リポジトリにおいても同等に機能します。

\subsection{patchwork quilt から Mercurial Queues へ}
\label{sec:mq:quilt-mq}

2005 年中旬、
quilt 的な振る舞いを Mercurial に追加するための、
Mercurial Queues と呼ばれる拡張機能が、
Chris Mason により実装されました。

quilt と MQ の大きな違いは、
quilt が変更制御システムを意識しないのに対して、
MQ が Mercurial に\emph{統合}されていることです。
  push される個々のパッチは、
Mercurial のチェンジセットとして表現されます。
  パッチを pop することで、チェンジセットは取り除かれます。

変更制御システムを意識しないことから、
Mercurial と MQ を利用できない状況について知る上で、
依然として quilt は非常に有用なソフトウェアです。

\section{MQ の大きな利点}

パッチと変更管理の統一を通して MQ が提供するものの価値を、
誇張し過ぎることはありません。

フリーソフトウェアおよびオープンソースの世界でパッチが利用され続けるのは、
変更管理ツールが年々その機能を向上させているにも関わらず、
パッチが\emph{軽快さ}を持っていることが大きな理由の一つです。

伝統的な変更制御ツールは、
実施したことに関する全てを、
永続的で取り消しの出来ないものとして記録します。
この振る舞いに大きな価値がある一方で、
幾分堅苦しくもあります。
過激な実験を行おうとする場合、
自分が行おうとすることに慎重になるか、
必要とされない〜なお悪いことには、誤解や不安定の元となる〜
失敗と間違いの記録を、
永続的な履歴記録中に残す危険を冒す必要があります。

対照的に、
MQ における分散履歴管理とパッチの結合により、
あなたの作業を容易に隔離することができます。
あなたのパッチは通常の変更履歴の上で存続し続け、
望む時にそれらの実施／取り消しを行うことが出来ます。
そのパッチが気に入らない場合、それを取りやめることができます。
そのパッチが完全には望むものでない場合、
望む姿に洗練させるまで、必要なだけ何度でも修正することが出来ます。

例えば、
パッチと変更管理の統合により、
パッチの理解とその効果〜および元になったコードとの連携〜のデバッグが、
\emph{非常に}簡単になります。
全ての適用済みパッチが関連したチェンジセットを持っているので、
どのチェンジセットとパッチがそのファイルに影響を及ぼしているのかを、
\hgcmdargs{log}{\emph{filename}} によって見ることが出来ます。
\hgext{bisect} 拡張を用いることで、
バグが持ち込まれたり修正された時点を見るために、
全てのチェンジセットと適用済みパッチを通しての二分探索を行うことができます。
\hgcmd{annotate} コマンドを用いることで、
ソースファイルの特定の行を変更したのが、
どのチェンジセットやパッチであるかを見ることが出来ます。

\section{パッチの理解}
\label{sec:mq:patch}

MQ は、それがパッチ指向の特性を持つことを表に出しているため、
パッチがどういったものであるかや、
パッチとともに機能するツールに関することがらを理解する手助けになります。

伝統的な Unix の \command{diff} コマンドは、
２つのファイルを比較し両者の違いを表示します。
\command{patch} コマンドは、
この違いをファイルに対する\emph{変更}とみなします。
これらのコマンドの簡単な動作例として、
図~\ref{ex:mq:diff}を見てください。

\begin{figure}[ht]
  \interaction{mq.dodiff.diff}
  \label{ex:mq:diff}
  \caption{\command{diff} および \command{patch} コマンドの利用例}
\end{figure}

\command{diff} が生成する（そして、\command{patch} が入力する）
ファイルの形式は``パッチ（patch）''ないし``差分（diff）''と呼ばれます。
パッチと差分の間に違いはありません
（以後は、より一般的に使用される``パッチ''という呼称を使用します）。

パッチファイルは、任意のテキストから始めることができます。
\command{patch} コマンドはこのテキストを無視しますが、
MQ はチェンジセットを生成する際のコミットメッセージとみなします。
パッチ内容を開始を見つけるために、
\command{patch} は ``\texttt{diff~-}'' で始まる最初の行を探します。

MQ は \emph{unified} 差分と共に機能します
（\command{patch} はそれ以外の何種類かの差分形式でも機能しますが、
MQ は \emph{unified} 差分でないと機能しません）。
unified 差分は２種類のヘッダを持っています。
\emph{ファイルヘッダ header}には、
変更対象となるファイルのファイル名が記述され、
\command{patch} コマンドが新規のファイルヘッダを見つけた際には、
変更を行うために当該する名前のファイルを探します。

ファイルヘッダに続いて、\emph{hunk} 列が記述されます。
それぞれの hunk はヘッダで開始され、
その hunk により変更される対象の、
ファイルにおける行番号の範囲を識別します。
ヘッダに続く hunk は、
ファイルの改変されない部分からなる数行のテキストが前後に付加されます。
これらの改変されない部分のことを、hunk に対する\emph{コンテキスト}と呼びます。
後続の hunk との間に少量のコンテキストしかない場合、
\command{diff} は新たな hunk ヘッダを表示しません。
変更内容の間に数行のコンテキスト行を置いて、
hunk をそのまま続けます。

コンテキストの個々の行は空白文字で始まります。
hunk 内部では、
``\texttt{-}'' で始まる行は``削除される行''を、
``\texttt{+}'' で始まる行は``挿入される行''を意味します。
例えば、変更される行は、１行の削除と１行の挿入で表現されます。

パッチのより微妙な側面に関しては後ほど（~\ref{sec:mq:adv-patch}節にて）
説明しますが、MQ を利用するに当たってはここまでの知識で十分です。

\section{Mercurial Queues の利用}
\label{sec:mq:start}

MQ は Mercurial の拡張として実装されているので、
利用の前に明示的に有効化する必要があります
（ダウンロードの必要はありません。
MQ は通常の Mercurial の配布物に含まれています）。
MQ を有効にするには、
\tildefile{.hgrc} ファイルを編集し、
~\ref{ex:mq:config} に示す行を追加してください。

\begin{figure}[ht]
  \begin{codesample4}
    [extensions]
    hgext.mq =
  \end{codesample4}
  \label{ex:mq:config}
  \caption{MQ 拡張有効化のために \tildefile{.hgrc} に追加する内容}
\end{figure}

拡張が有効化されると、
いくつかの新しいコマンドが有効化されます。
\hgcmd{help} を使って \hgxcmd{mq}{qinit} コマンドの利用可否を見ることで、
拡張が機能することを確認できます。
~\ref{ex:mq:enabled} の例を参照してください。

\begin{figure}[ht]
  \interaction{mq.qinit-help.help}
  \caption{MQ 利用可否の確認}
  \label{ex:mq:enabled}
\end{figure}

MQ は\emph{全ての} Mercurial リポジトリで利用でき、
コマンドはそのリポジトリにしか作用しません。
利用開始の際には、
\hgxcmd{mq}{qinit} コマンドによりリポジトリの準備を行います
（~\ref{ex:mq:qinit} 参照）。
このコマンドは、\sdirname{.hg/patches} と呼ばれる空のディレクトリを作成し、
MQ はこのディレクトリにメタデータを格納します。
多くの Mercurial コマンドと同様、
\hgxcmd{mq}{qinit} コマンドは実行が正常に終了した場合には、
特に何も表示しません。

\begin{figure}[ht]
  \interaction{mq.tutorial.qinit}
  \caption{MQ 利用に向けたリポジトリの準備}
  \label{ex:mq:qinit}
\end{figure}

\begin{figure}[ht]
  \interaction{mq.tutorial.qnew}
  \caption{新しいパッチの作成}
  \label{ex:mq:qnew}
\end{figure}

\subsection{新しいパッチの作成}

新しいパッチで作業を開始するには、
\hgxcmd{mq}{qnew} コマンドを使います。
このコマンドは作成するパッチの名前を引数に取ります。
例~\ref{ex:mq:qnew}に示すように、
MQ はこれを \sdirname{.hg/patches} 
ディレクトリ中の実ファイルの名前とみなします。

\sdirname{.hg/patches} ディレクトリ配下にはそれ以外にも、
\sfilename{series} と \sfilename{status} 
という２つの新しいファイルが作成されます。
\sfilename{series} は、
そのリポジトリにおいて MQ が管理する全てのパッチの一覧を、
１行１パッチで保持しています。
\sfilename{status} は
そのリポジトリにおいて MQ が\emph{適用}した全てのパッチを追跡するための、
内部帳簿的な用途に使用されます。

\begin{note}
  例えば、パッチの適用順序を変更したいような場合、
  \sfilename{series} を手動で変更したい場合があるかもしれません。
  しかし、MQ の認識状況を容易に損なうことから、
  手動での \sfilename{status} 編集は殆ど全ての場合において不適切です。
\end{note}

新しいパッチを作成したならば、
普段と同じように作業領域ディレクトリのファイルを編集できます。
\hgcmd{diff} や \hgcmd{annotate} といった、
Mercurial の全ての通常コマンドはそれ以前と全く同様に機能します。

\subsection{パッチの refresh}

作業内容を保存する段階になったなら、
作業中のパッチを更新するために \hgxcmd{mq}{qrefresh} を使用します
（図~\ref{ex:mq:qnew}参照）。
このコマンドは、
作業領域ディレクトリでの変更内容をパッチへと格納し、
対応するチェンジセットを、それらの変更内容を保持するように更新します。

\begin{figure}[ht]
  \interaction{mq.tutorial.qrefresh}
  \caption{パッチの refresh}
  \label{ex:mq:qrefresh}
\end{figure}

\hgxcmd{mq}{qrefresh} コマンドはいつでも何度でも実行できるので、
作業の``チェックポイント''として利用するのも良いでしょう。
都合の良い時にパッチの refresh を実施することで、
実験的な作業を行ってみて、それがうまく機能しない場合には、
直近の refresh 時点までの変更を、
\hgcmd{revert} コマンドにより取り消すことができます。

\begin{figure}[ht]
  \interaction{mq.tutorial.qrefresh2}
  \caption{複数回のパッチ refresh による変更の蓄積}
  \label{ex:mq:qrefresh2}
\end{figure}

\subsection{パッチの積み重ねと追跡}

パッチに対する作業を終えるか、
他のパッチに対する作業が必要になったなら、
再度 \hgxcmd{mq}{qnew} コマンドを実行することで、
新しいパッチを作成します。
Mercurial は、新規に作成したこのパッチを、
既存のパッチの最上位に適用します。
図~\ref{ex:mq:qnew2}を参照してください。
先に作業していたパッチに含まれる変更は、
この新しいパッチの文脈の一部として含まれます
（\hgcmd{annotate} 出力を見れば、このことは明らかです）。

\begin{figure}[ht]
  \interaction{mq.tutorial.qnew2}
  \caption{１つ目の上に積み重ねられる２つ目のパッチ}
  \label{ex:mq:qnew2}
\end{figure}

これまでは、
\hgxcmd{mq}{qnew} と \hgxcmd{mq}{qrefresh} を除いて、
Mercurial の通常コマンドのみを使用するように注意してきました。
しかし、
図~\ref{ex:mq:qseries} に示すように、
パッチに関する作業を行う際により便利な多くのコマンドを、
MQ は提供しています。

\begin{itemize}
\item \hgxcmd{mq}{qseries} コマンドは
  MQ が当該リポジトリ中で管理している全てのパッチの一覧を、
  古いものから新しいもの（最も最近\emph{作成されたもの}）
  の順序で一覧表示します。

\item \hgxcmd{mq}{qapplied} コマンドは、
  MQ が当該リポジトリで\emph{適用した}全てのパッチの一覧を、
  古いものから新しいもの（最も最近適用されたもの）
  の順序で一覧表示します。
\end{itemize}

\begin{figure}[ht]
  \interaction{mq.tutorial.qseries}
  \label{ex:mq:qseries}
  \caption{\hgxcmd{mq}{qseries} および 
   \hgxcmd{mq}{qapplied} によるパッチの積み重ねの習得}
\end{figure}

\subsection{パッチの積み重ねの操作}

``管理されている''パッチと``適用されている''それの間に違いがあることを、
先の記述では暗に示していますが、
実際に両者の間には違いがあります。
MQ は適用すること無しに、パッチをリポジトリ中で管理することができます。

\emph{適用された}パッチは、
リポジトリ中に対応するチェンジセットを持ち、
パッチとチェンジセットの効果は作業領域ディレクトリにおいて見ることができます。
\hgxcmd{mq}{qpop} コマンドを使用して、
パッチの適用を取り消すこともできます。

MQ は取り除かれたパッチを\emph{管理}し続けますが、
そのパッチはもはやリポジトリ中に対応するチェンジセットを持たず、
作業領域ディレクトリにはパッチによる変更の痕跡は残されていません。
図~\ref{fig:mq:stack}に、
適用されたパッチと追跡されているそれの違いを示します。

\begin{figure}[ht]
  \centering
  \grafix{mq-stack}
  \caption{MQ のパッチの積み重ねにおける適用済みパッチと未適用パッチ}
  \label{fig:mq:stack}
\end{figure}

\hgxcmd{mq}{qpush} コマンドを使用することで、
未適用パッチの再適用、ないし取り除きを行うことができます。
この操作によりパッチに対応する新しいチェンジセットが作成され、
パッチによる変更は再び作業領域ディレクトリに現れます。
図~\ref{ex:mq:qpop}に、
\hgxcmd{mq}{qpop} および \hgxcmd{mq}{qpush} の実施例を示します。
図のように１つないし２つのパッチを一度取り除いても、
\hgxcmd{mq}{qseries} の出力は変化しませんが、
その一方で \hgxcmd{mq}{qapplied} の出力は変化します。

\begin{figure}[ht]
  \interaction{mq.tutorial.qpop}
  \caption{適用パッチの積み重ねの変更}
  \label{ex:mq:qpop}
\end{figure}

\subsection{複数パッチの適用(push)および取り消し(pop)}

\hgxcmd{mq}{qpush} および \hgxcmd{mq}{qpop} のそれぞれが、
デフォルトでは一度に一つのパッチに対して処理を行う一方で、
一度に複数のパッチの適用や取り消しを行うこともできます。
\hgxcmd{mq}{qpush} に
\hgxopt{mq}{qpush}{-a} オプションを指定することにより、
全ての未適用パッチの適用が、
\hgxcmd{mq}{qpop} に
\hgxopt{mq}{qpop}{-a} オプションを指定することにより、
全ての適用済みパッチの取り消しを行うことができます。
（それ以外の複数パッチの適用／取り消しの方法に関しては、
~\ref{sec:mq:perf} 節を参照してください。）

\begin{figure}[ht]
  \interaction{mq.tutorial.qpush-a}
  \caption{全ての未適用パッチの適用}
  \label{ex:mq:qpush-a}
\end{figure}

\subsection{安全確認とその無効化}

いくつかの MQ コマンドは、
処理の前に作業領域ディレクトリの確認を行い、
何らかの改変が検出された場合には処理を中断します。
この確認は、
パッチに取り込まれていない変更内容を失わないために行われます。
図~\ref{ex:mq:add} に例を示します。
\hgxcmd{mq}{qnew} コマンドは未取り込みの変更
（このケースでは \filename{file3} の \hgcmd{add} に起因するもの）がある場合、
新しいパッチを生成しません。

\begin{figure}[ht]
  \interaction{mq.tutorial.add}
  \caption{強制的なパッチの生成}
  \label{ex:mq:add}
\end{figure}

作業領域ディレクトリを確認するコマンドは、
すべて``了解済み''オプションを取ることができ、
そのオプションは常に \option{-f} と名づけられています。
\option{-f} オプションの厳密な意味はコマンドごとに異なります。
例えば、
\hgcmdargs{qnew}{\hgxopt{mq}{qnew}{-f}} 
は新たに生成されるパッチに未取り込みの変更を全て取り込みますが、
\hgcmdargs{qpop}{\hgxopt{mq}{qpop}{-f}} 
は取り消されるパッチが影響を及ぼすファイルに対する変更を元に戻します
\footnote{訳注:
「パッチの影響を元に戻す」のではなく、
「パッチが影響を及ぼすファイル」を全て元に戻す、の意}。
利用する前に各コマンドの \option{-f} オプションのドキュメントを確認しましょう！

\subsection{複数パッチの一括処理}

\hgxcmd{mq}{qrefresh} コマンドは、
常に\emph{最上位の}適用済みパッチを更新します。
これは、あるパッチに対する操作を（refresh することで）中断し、
取り消し（pop）ないし適用（push）により別のパッチを最上位に持ってくることで、
そのパッチに対して作業することができることを意味します。

この機能によって可能になることを例によって示します。
２つのパッチによって新しい機能を開発しているものとしましょう。
１つ目のパッチはソフトウェアの中核機能の変更を、
そして２つ目のパッチは --- １つ目のパッチの上で ---
中核機能の変更を使用するためのユーザーインタフェース(UI)の変更を行います。
UI へのパッチの作業中に、
中核機能へのパッチにバグを見つけたとしても、
それを修正するのは簡単なことです。
UI へのパッチに対する \hgxcmd{mq}{qrefresh} により作業中の変更を保存した後に、
\hgxcmd{mq}{qpop} により操作対象パッチを中核機能へのそれに変更します
（パッチスタックを下へと移動します）。
中核機能へのパッチのバグを修正し、
\hgxcmd{mq}{qrefresh} によってパッチへの反映を行った後に、
\hgxcmd{mq}{qpush} により操作対象パッチを UI へのパッチに戻すことで、
やりかけの作業を継続することができます。

\section{パッチに関して更に詳しく}
\label{sec:mq:adv-patch}

MQ はパッチの適用に GNU \command{patch} コマンドを使用しますので、
\command{patch} コマンドの動作とパッチそのものに関して、
より詳細な情報を知ることは有用です。

\subsection{除去数}

パッチのファイルヘッダを見ると、
実際のパス名には現れない余分な要素を先頭に持っていることに気が付くでしょう。
これは以前にパッチが生成されていた方法の名残です
（今でもこの方法を用いていますが、
近年の構成管理ツールでは稀です）。

Alice が tarball を展開してファイルを編集した後で、
パッチを作成しようと考えたとします。
作業領域ディレクトリを改名し、
再度 tarball を展開（この展開のために改名することが必要になります）し、
\command{diff} コマンドに
\cmdopt{diff}{-r} および \cmdopt{diff}{-N} オプションを指定することで、
改変前のディレクトリと改変後のディレクトリの間で再帰的にパッチを生成します。
一方には改変前のディレクトリ名が全てのファイルのパス冒頭に付加され、
他方には改変後のディレクトリ名が同様に付加されます。

Alices からパッチを受け取った人物の環境に、
改変前と改変後ディレクトリの両方と厳密に一致する名前のディレクトリがある、
というのはありそうもない事ですから、
\command{patch} コマンドは、
パッチ適用時にパス名要素の何番目までを取り除くかを指す
\cmdopt{patch}{-p} オプションを持っています。
このオプションに指定される数を\emph{除去数}（strip count）と呼びます。

``\texttt{-p1}'' オプションは、
``除去数を１とみなす''ことを意味します。
\command{patch} コマンドが、
ファイルヘッダにおいてファイル名 \filename{foo/bar/baz} を検知した場合、
\filename{foo} 部分を除去した 
\filename{bar/baz} というファイルに対してパッチをあてます
（厳密なことを言えば、
除去数は除去される\emph{パス区切り}（およびそれに付随する要素）の数を指します。
除去数１は、\filename{foo/bar} を \filename{bar} にしますが、
\filename{/foo/bar}（先頭のスラッシュに注意）は 
\filename{foo/bar} になります）。

パッチにおける``標準の''除去数は１ですので、
ほとんど全てのパッチは取り除かれる先頭要素を１つ含んでいます。
Mercurial の \hgcmd{diff} コマンドはこの形式でパス名を生成しますので、
\hgcmd{import} コマンドや MQ は除去数１のパッチを期待しています。

除去数が１ではないパッチをパッチキューに追加しようとした場合、
現時点で \texttt{-p} オプションを持っていない
\hgxcmd{mq}{qimport} （~\bug{311} 参照のこと）では取り込むことができません。
その場合、
\hgxcmd{mq}{qnew} で新規パッチを MQ 上に作成し、
\cmdargs{patch}{-p\emph{N}} によりパッチを適用、
\hgcmd{addremove} でパッチにより追加／削除されたファイルを特定し、
\hgxcmd{mq}{qrefresh} を行うのが最善の方法です。
このような面倒な手順はいずれ不要になるかもしれません。
詳細は ~\bug{311} を参照してください。

\subsection{パッチ適用手順}

\command{patch} が hunk を適用する際には、
it tries a handful of
(successively はどこに掛かる？)
successively less accurate strategies to try to make the hunk apply XXXXX
用心深いこの方法により、古い版のファイルで生成されたパッチであっても、
新しい版のファイルに適用することが、多くの場合で可能となります。

\command{patch} コマンドは、
最初は hunk における行番号、
コンテキストおよび変更対象テキストの厳密一致を試みます。
厳密一致ができない場合、
行番号に関する情報を無視し、
コンテキストのみの厳密一致を試みます。
これが成功した場合、
\command{patch} コマンドは、
hunk が適用されたことと、
元の行番号から\emph{オフセット分}ずれていることを表示します。

コンテキストのみによる一致が失敗した場合、
\command{patch} は冒頭および末尾行を取り除いたコンテキストを用いて、
\emph{縮小}コンテキストのみによる一致を試みます。
縮小コンテキストによる hunk 適用が成功した場合、
\emph{あいまいな要因}を元に hunk が適用されたことを表示します
（この時示される数値は、
\command{patch} コマンドがパッチ適用前にコンテキストから取り除いた行数です）。

これらのどの技法でも適用できない場合、
\command{patch} コマンドは争点となっている hunk が却下された旨を表示します。
\command{patch} コマンドは却下された hunk （単に ``reject'' とも呼ばれます）
を同名で \sfilename{.rej} 拡張子を持つファイルに保存します。
更にその上で、
パッチ適用前のファイルのコピーを \sfilename{.orig} 拡張子付きで保存します。
拡張子無しのファイルは、
適切にの適用\emph{された} hunk による変更を含んでいます。
ファイル \filename{foo} を変更する６つの hunk を持つパッチがあり、
そのうちの１つが適用できなかった場合、
変更前の内容を持つ \filename{foo.orig}、
適用できなかった hunk を１つ持つ \filename{foo.rej} および
適用できた５つの hynk による変更を含む \filename{foo} 
の３つのファイルができます。

\subsection{パッチの実現上の癖}

\command{patch} コマンドのファイルへの作用を知る上で、
有用な事がいくつかあります。

\begin{itemize}
\item わかりきった事ですが、\command{patch} はバイナリファイルを扱えません。

\item 実行ビットも扱えませんので、新しいファイルを作成する際には、
  読み取り可能にはしますが、実行可能にはしません。

\item \command{patch} は、削除対象ファイルと空ファイルの差分をもって、
  ファイルの削除を表します。
  そのため、``ファイルを削除する''ことは、
   パッチにおいては``全ての行が削除される''ように見えます。

\item 空のファイルと追加対象ファイルの差分をもって、
  ファイルの追加を表します。
  そのため、``ファイルを追加する''ことは、
  パッチにおいては``全ての行が追加される''ように見えます。

\item 古い名前のファイルの削除と新しい名前のファイルの追加をもって、
  ファイルの改名を表します。
  これは、ファイルの改名を行うパッチのサイズ
  （footprint）が大きくなることを意味します
  （パッチにおけるファイルの改名やコピーを Mercurial が推測することは、
  現状では行われないことにも留意してください） 。

\item \command{patch} は空のファイルを表現できませんので、
  ``空のファイルをツリーに追加する''ことをパッチで表現することは出来ません。

\end{itemize}

\subsection{あいまいさに注意}

オフセット付きや、あいまいな要因を元にしている場合であっても、
パッチの適用は完全に成功することが多いのですが、
一方でこのような厳密性を欠いた適用手法は、
おのずとファイルへのパッチ適用が不完全である可能性を残してしまいます。
最も典型的な事例は、
パッチを２度適用してしまうことや、
不適切な位置に適用してしまうことです。
\command{patch} や \hgxcmd{mq}{qpush} 
がオフセットやあいまい要因に関して言及した際には、
ファイルが適切に変更されていることを後から確認してください。

オフセット付きや、あいあまいな要因を元に適用されたパッチを refresh するのが、
多くの場合においておすすめなのは、
パッチの refresh が、
パッチを綺麗に適用するための新しいコンテキスト情報を生成するからです。
ただし、パッチを refresh することで、
元ファイルの異なる版に対してパッチの適用が失敗するようになる場合があるため、
``多くの場合''おすすめですが、``常に''ではありません。
ソースツリーの複数の版に対して適用可能なパッチを保守するような場合、
パッチ適用処理の結果を検証する機会を得ることが出来るので、
パッチにあいまい要因を持たせておくのは許容範囲です。

\subsection{却下された hunk の取り扱い}

パッチの適用に失敗すると、
\hgxcmd{mq}{qpush} はエラーメッセージを表示して終了します。
\sfilename{.rej} ファイルが残されている場合、
それ以上のパッチを push したり他の作業をする前に、
却下された hunk の修正を行うことが一般的には最善です。

パッチの適用対象であるソースの更新により、
\emph{それまでは}きちんと適用できていたパッチが適用できなくなった場合の
Mercurial Queues の使い方の詳細に関しては、
~\ref{sec:mq:merge} 節を参照してください。

残念なことに、却下された hunk を扱うための決定的な技法は存在しません。
多くの場合、\sfilename{.rej} ファイルを参照しながら、
対象ファイルを編集し、
却下された hunk を手動で適用しなければなりません。

思い切った事も辞さないのであれば、
パッチの適用に関しては \command{patch} よりも強力な、
\command{wiggle}~\cite{web:wiggle} と呼ばれるツールが、
Linux カーネルハッカーの Neil Brown により書かれています。

\command{patch} により却下された hunk の適用を自動化するために、
簡便な手法を用いる \command{mpatch}~\cite{web:mpatch} と呼ばれるツールも、
別の Linux カーネルハッカーの Chris Mason
（Mercurial Queues の作者です）により書かれています。
\command{mpatch} は、
４つのよくある理由で却下された hunk の適用を助けることができます。

\begin{itemize}
\item hunk 中程のコンテキストが変更された。
\item hunk のコンテキストの、先頭あるいは末尾の一方が見当たらない。
\item 大きな hunk よりも---全部なり一部なりが---
  小さな hunk に分割された方が適用しやすい。
\item 現時点でのファイルとわずかに内容の異なる行を 
  hunk が削除しようとしている。
\end{itemize}

\command{wiggle} ないし \command{mpatch} を使用する際には、
実施結果に対して二重に注意を払う必要があります。
実のところ \command{mpatch} は、
処理の完了時に自動的にマージプログラムへと誘導することで、
ツール出力の二重確認の手法を強要していますので、
\command{mpatch} の実行結果を確認し、
残されたマージ処理を完了させることが出来ます。

\section{MQ で最高性能を出すために}
\label{sec:mq:perf}

MQ は大量のパッチの取り扱いを効率よく実施します。
2006 EuroPython conference~\cite{web:europython} での講演のために、
2006 年中旬に性能実験を実施しました。
適用パッチとして、
1,738 個のパッチを持つ Linux 2.6.17-mm1 パッチ系列を使用しています。
Linux 2.6.12-rc2 から Linux 2.6.17 にかけての、
27,472 のリビジョン全てを持つ Linux カーネルリポジトリに対して、
これらのパッチを適用したのです。

旧式の遅いラップトップ PC 上で、
1,738 個のパッチ全てを
\hgcmdargs{qpush}{\hgxopt{mq}{qpush}{-a}} するのに 3.5 分、
それらを \hgcmdargs{qpop}{\hgxopt{mq}{qpop}{-a}} するのに 30 秒かかりました
（新しいラップトップなら、
全てのパッチを push する時間は２分まで下がりました）。
最も大きなパッチの１つ（22,779 行の変更を 287 のファイルに対して行います）
を 6.6 秒で \hgxcmd{mq}{qrefresh} できています。

MQ が巨大なソースツリーで作業するのに適しているのは明らかですが、
最高の性能を出すために知っておいたほうが良い幾つかのコツがあります。

最初のコツは、``一括''操作を行うことです。
\hgxcmd{mq}{qpush} および \hgxcmd{mq}{qpop} の実行の際には、
何ら変更がされていないことと、
\hgxcmd{mq}{qrefresh} し忘れがないことを確認するために、
常に作業領域ディレクトリを走査しています。
小さなソースツリーの場合は、
この走査に要する時間は気になりません。
しかし、中程度（10,000 ファイル程度）のソースツリーでは、
１秒からそれ以上の時間が必要です。

\hgxcmd{mq}{qpush} および \hgxcmd{mq}{qpop} コマンドでは、
複数パッチを一括して push および pop する際に、
作業を切り上げる``到達パッチ''を指定することができます。
到達パッチ指定付きで実行することで、
\hgxcmd{mq}{qpush} 
は指定したパッチが適用スタックの最上位になるまでパッチの適用を行います。
\hgxcmd{mq}{qpop} の場合は、
到達パッチが適用スタックの最上位になるまでパッチの取り消しを行います。

到達パッチの指定には、パッチの名前か数値が使用できます。
数値指定の場合、パッチは０から数え始めるため、
最初のパッチは０、次のパッチの１となります。

\section{元ソース変更時のパッチの更新}
\label{sec:mq:merge}

直接変更することのできないリポジトリに対して、
パッチスタックを持つことはよくある事です。
第三者のソースに対する変更や、
元ソースの更新頻度よりも開発に時間の掛かる機能を実装している場合、
元ソースの更新との同期や、
適用できなくなったパッチの hunk を修正する必要があります。
このような作業は、パッチ系列の\emph{リベース}と呼ばれます。

リベースの一番単純な方法は、
パッチに対して \hgcmdargs{qpop}{\hgxopt{mq}{qpop}{-a}} を行い、
\hgcmd{pull} で元ソースの変更をリポジトリに取り込み、
最後に \hgcmdargs{qpush}{\hgxopt{mq}{qpop}{-a}} でパッチを再適用します。
MQ によるパッチ適用では、
衝突が検出されている間は適用できないパッチの適用を止めることで、
衝突の解消とパッチの \hgxcmd{mq}{qrefresh} を行う機会を設けつつ、
パッチスタック中の全てのパッチを更新し終わるまでパッチの適用を継続します。

元ソースの変更がパッチの適用具合に悪影響を及ぼす心配が無いのであれば、
この手法は手軽で且つ上手く機能するでしょう。
しかしながら、
元ソースで頻繁に更新される部分に触れるようなパッチスタックの場合、
却下された hunk の手動での修正は、
すぐにでも面倒な作業と化すでしょう。

リベース処理を部分的に自動化する事は可能です。
元ソースの幾つかのリビジョンに対してきちんと適用できるパッチであれば、
異なるリビジョンとパッチとの間での衝突に対して、
事前の適用情報を用いた解消を MQ により行うことができます。

手順は少々込み入っています。

\begin{enumerate}
\item 開始に当たって、
  パッチがきちんと適用できている最上位リビジョンに対して
  \hgcmdargs{qpush}{-a} により全てのパッチを適用します。

\item \hgcmdargs{qsave}{\hgxopt{mq}{qsave}{-e} \hgxopt{mq}{qsave}{-c}} 
  を用いてパッチディレクトリのバックアップを保存します。
  このコマンドの実行の際には、パッチを保存したディレクトリの名前を表示します。
  \texttt{\emph{N}} を小さい整数とした場合、
  \sdirname{.hg/patches.\emph{N}} 
  という形式の名前のディレクトリにパッチが保存されます。
  適用されたパッチ以外に、
  ``保存されたチェンジセット''もコミットしますが、
  これは内部的な情報と、
  \sfilename{series} および \sfilename{status} の状態を記録するためです。

\item hgcmd{pull} により、更新をリポジトリに取り込みます
  （\hgcmdargs{pull}{-u} を用いない理由は、以降の記述を参照してください）。

\item \hgcmdargs{update}{\hgopt{update}{-C}} を用いて最新の 
  tip リビジョンに更新することで、適用したパッチを無効にしてください。

\item \hgcmdargs{qpush}{\hgxopt{mq}{qpush}{-m}
    \hgxopt{mq}{qpush}{-a}} を用いて全てのパッチをマージします。
  \hgxcmd{mq}{qpush} への \hgxopt{mq}{qpush}{-m} オプション指定により、
  パッチ適用に失敗した際に、MQ は 3-way マージを実施します。

\end{enumerate}

\hgcmdargs{qpush}{\hgxopt{mq}{qpush}{-m}} 実施の際には、
\sfilename{series} 
ファイルに列挙されたそれぞれのパッチは通常通り適用されます。
あいまい要因を元にパッチが適用されたり、パッチの適用が却下された場合、
MQ は \hgxcmd{mq}{qsave} により保存されたパッチキューを参照し、
パッチに対応するチェンジセットを用いた 3-way マージを行います。
このマージ処理には Mercurial の通常のマージ機構が利用されますので、
衝突の解消の際には GUI マージツールが起動されるかもしれません。

パッチの影響を解消し終えると、
マージ結果を元に MQ によるパッチの refresh が行われます。

この手順を終えたリポジトリには、
古いパッチキューに相当するチェンジセットを元にした余分な head と、
\sdirname{.hg/patches.\emph{N}} に保存された古いパッチキューが残ります。
余分な head の削除は、
\hgcmdargs{qpop}{\hgxopt{mq}{qpop}{-a} \hgxopt{mq}{qpop}{-n} patches.\emph{N}}
ないし \hgcmd{strip} で行うことができます。
バックアップとしての必要性がなくなったなら、
\sdirname{.hg/patches.\emph{N}} も削除してしまって構いません。

\section{パッチの指定}

パッチを操作する MQ コマンドにおけるパッチの指定は、
パッチの名前か数値で行います。
名前による指定は非常にわかりやすいでしょう。
例えば、\hgxcmd{mq}{qpush} コマンドへの
\filename{foo.patch} の指定により、
\filename{foo.patch} が適用されるまでパッチの適用が繰り返されます。

短縮形式として、名前と数値オフセットの両方を指定することもできます。
\texttt{foo.patch-2} は
``\texttt{foo.patch} パッチの２つ前''を、
\texttt{bar.patch+4} は
``\texttt{bar.patch} パッチの４つ後ろ''を意味します。

数値によるパッチの指定はそれほど難しくありません。
\hgxcmd{mq}{qseries} により最初に表示されるパッチは０、
２番目は１、となっています
（そう、０から数え始める仕組みです）。

MQ は、通常の Mercurial コマンドの利用時におけるパッチ操作も簡便にします。
チェンジセット識別子を受け付ける全てのコマンドは、
適用済みのパッチ名も受け付けます。
リポジトリ中に元々あった通常のタグに加えて、
パッチ適用の際の起点となるリビジョンにタグ\footnote{
\index{tags!特殊タグ名!\texttt{qbase}}\texttt{qparent}
}が付与されます。
それに加えて、
\index{tags!特殊タグ名!\texttt{qbase}}\texttt{qbase} および
\index{tags!特殊タグ名!\texttt{qtip}}\texttt{qtip} タグにより、
最下位および最上位の適用ずみパッチをそれぞれ指定できます。

Mercurial の通常タグに対するこれらの拡張は、
パッチの取り扱いをより簡便にします。

\begin{itemize}

\item 最新の一連の変更を元に、メーリングリストへパッチ爆弾（patchbomb）
  を投稿したい場合には？
  \begin{codesample4}
    hg email qbase:qtip
  \end{codesample4}
  （``パッチ爆弾''については \ref{sec:hgext:patchbomb} 節を参照してください）

\item \texttt{foo.patch} 以降のパッチで、
  特定のディレクトリ配下のファイルに関与しているものを、
  全て知りたい場合には？
  \begin{codesample4}
    hg log -r foo.patch:qtip \emph{subdir}
  \end{codesample4}

\end{itemize}

パッチの名前を利用可能にするために、
MQ は Mercurial の持つ内部タグ機能を使用しているので、
パッチを名前で指定する場合には、
その名前を全て入力する必要はありません。

\begin{figure}[ht]
  \interaction{mq.id.output}
  \caption{MQ のタグ機能を使用したパッチの操作}
  \label{ex:mq:id}
\end{figure}

パッチの名前をタグで実現することで、
\hgcmd{log} コマンドの実行時に、
その出力の一部としてタグとしてのパッチ名が表示される、
という副作用も得られます。
このことにより、
適用済みのパッチと``通常の''リビジョンを、
視覚的に識別することを容易にします。
適用済みパッチと連携する Mercurial の通常コマンドの実行例を
図 ~\ref{ex:mq:id} に示します。

\section{知っておくと便利な事柄}

MQ の利用に関して、独立した節を設ける程ではないものの、
知っておいたほうが良い事柄が幾つかあります。
ここでは、そういった事柄を集めてみました。

\begin{itemize}
\item \hgxcmd{mq}{qpop} でパッチを取り消した後に、
  \hgxcmd{mq}{qpush} で再度適用した場合、
  その時点での適用済みパッチに相当するチェンジセットは、
  pop/push する前のチェンジセットとは\emph{異なる識別子}を持ちます。
  識別子が異なる理由は ~\ref{sec:mqref:cmd:qpush} 節を参照してください。

\item 少なくとも、
  パッチスタック上のパッチによるチェンジセット群の
  ``パッチ性''を保ちたいのであれば、
  他のブランチとそれらを\hgcmd{マージ}すべきではありません。
  \hgcmd{マージ}した場合、それ自体は成功するでしょうが、
  結果として MQ が混乱してしまうでしょう。
\end{itemize}

\section{リポジトリにおけるパッチの管理}
\label{sec:mq:repo}

MQ が利用する \sdirname{.hg/patches} ディレクトリが
Mercurial の作業領域ディレクトリの外にあるため、
MQ の``下にある''Mercurial のリポジトリは、
パッチの管理や存在に関して何も認識していません。

このことは、
パッチディレクトリの内容をそれ自身の Mercurial リポジトリを用いて管理できる、
という興味深い可能性をもたらします。
例えば、
パッチに関する作業を行い、\hgxcmd{mq}{qrefresh} をした後で、
パッチの現状を \hgcmd{commit} することで、
後からその状態へとパッチを``巻き戻す''（roll back）することができるなど、
有用な機能を提供します。

複数のリポジトリの間で、
同一パッチスタックの異なる版を共有することも出来ます。
筆者は Linux カーネル機能の開発の際にこの手法を使用しています。
複数の CPU アーキテクチャごとにそれぞれ真新しいカーネルソースのコピーを用意し、
それぞれに作業中のパッチを含むリポジトリを複製します。
別なアーキテクチャで変更内容の試験を行う際には、
対応するカーネルソースのパッチリポジトリへ現時点のパッチを push し、
全てのパッチを最適用（pop 後に push）した後に、
そのカーネルのビルドおよび試験を行います。

リポジトリ形式の上でパッチを管理することで、
適用対象のソースに対する制御の可否に関わり無く、
開発者同士でお互いに衝突すること無しに、
同じパッチ系列に対する作業を実施できます

\subsection{MQ のパッチリポジトリサポート}

MQ は \sdirname{.hg/patches} ディレクトリを自身のリポジトリとして、
パッチ操作を補助しますが、
\hgxcmd{mq}{qinit} での初期化の際に
\hgxopt{mq}{qinit}{-c} オプションを指定することで、
\sdirname{.hg/patches} ディレクトリを
Mercurial リポジトリとして作成することが出来ます。

\begin{note}
  \hgxopt{mq}{qinit}{-c} オプションの指定を忘れた場合、
  任意の時点で \sdirname{.hg/patches} ディレクトリで
  \hgcmd{init} を実行してください。
  \sfilename{status} を履歴管理しようと思うことは\emph{本当に}ありませんから、
  \sfilename{.hgignore} ファイルに 
  \sfilename{status} を追加するのを忘れないでください
  （\hgcmdargs{qinit}{\hgxopt{mq}{qinit}{-c}} は、
  この作業を自動的に行います）。
\end{note}

利便性上、
\dirname{.hg/patches} ディレクトリが
Mercurial リポジトリである場合、
MQ は作成・取り込みを行ったパッチの全てを自動的に
\hgcmd{add} します。

最後になりますが、
MQ は \sdirname{.hg/patches} において 
\hgcmd{commit} を実行する短縮コマンド 
\hgxcmd{mq}{qcommit} を提供していますので、
（ディレクトリ移動等の）煩わしいキー入力が省略できます。

\subsection{幾つかの注意点}

MQ によるパッチのリポジトリ管理のサポートは、限定的なものです。

MQ は、パッチディレクトリに対して行われた変更を、
自動的に検出することはできません。
\hgcmd{pull} の実行や、手動での編集、
あるいは \hgcmd{update} の実行によるパッチや 
\sfilename{series} の変更を行った場合、
パッチ適用対象のリポジトリにおいて
\hgcmdargs{qpop}{\hgxopt{mq}{qpop}{-a}} の後に
\hgcmdargs{qpush}{\hgxopt{mq}{qpush}{-a}} を行って、
それらの変更を有効にする必要があります。
この作業を忘れた場合、
MQ は適用されているパッチがどれなのか混乱してしまうでしょう。

\section{パッチ操作のためのサードパーティー製ツール}
\label{sec:mq:tools}

暫くの間、パッチを使った作業をしていると、
扱っているパッチの解釈や操作を補助するツールが、
欲しくてたまらなくなっているに違いありません。

\command{diffstat} コマンド ~\cite{web:diffstat} は、
パッチによって各ファイルがどれだけ変更されるかを表すヒストグラムを生成します。
どのファイルが、どの程度の影響を受けるのか、
といった全体的な``感覚を掴む''には良い方法です
（\command{diffstat} の 
\cmdopt{diffstat}{-p} オプション利用は勿論良いのですが、
ファイル名の前置詞に対して行う \cmdopt{diffstat}{-p} オプションの巧妙な処理は、
少なくとも筆者にとってはわかりにくいです）。

\begin{figure}[ht]
  \interaction{mq.tools.tools}
  \label{ex:mq:tools}
  \caption{\command{diffstat}、\command{filterdiff} および \command{lsdiff} コマンド}
\end{figure}

\package{patchutils} パッケージ ~\cite{web:patchutils} は貴重な存在です。
このパッケージは、
``Unix の理念''に従って、
それぞれがパッチに対して単一の処理を行う小さなツールの集まりです。
\package{patchutils} の中で筆者が最も利用しているのは、
パッチファイルから一部を展開する \command{filterdiff} です。
例えば、
あるパッチが数ダースのディレクトリに渡って数百のファイルを変更する場合、
\command{filterdiff} を起動することで、
指定したパターンに名前が合致するファイルにだけ変更を行う、
小さなパッチを生成することが出来ます。
それ以外の例については、
~\ref{mq-collab:tips:interdiff} 節を参照してください。

\section{パッチを扱う良い方法}

一連のパッチが、
フリーソフトウェアやオープンソースプロジェクトへ送付するものであろうと、
あなたの作業における定期的な変更手続きとみなされるものであろうとも、
より良く作業するための、
簡単に利用できる手法があります。

まずは、パッチに説明的な名前をつけましょう。
例えば \filename{rework-device-alloc.patch} といった名前は、
そのパッチが何を行うものかというヒントをすばやく与えてくれるので、
良い名前と言えるでしょう。
名前は長くても問題にはなりません。
名前を入力することはそれほど多くはないでしょうが、
\hgxcmd{mq}{qapplied} や \hgxcmd{mq}{qtop} といったコマンドは、
何度も何度も実行するものですから。
多くのパッチを扱う場合や、
多くの異なるタスクに手一杯でパッチに多くの注意を割けないような場合、
名前の適切さはとりわけ重要です。

次に、どのパッチに対して作業しているのかに注意しましょう。
\hgxcmd{mq}{qtop} コマンドを
---例えば、\hgcmdargs{tip}{\hgopt{tip}{-p}} を指定しつつ---
使用して頻繁にパッチの名前を見ることで、
どんな作業をしているのかを確認しましょう。
筆者は作業中に何度も意図しないパッチに対して
\hgxcmd{mq}{qrefresh} を実行してしまったことがありますが、
間違ったパッチに取り込んでしまった変更を正しいパッチに移動させるのは、
往々にして手のかかるものです。

上記の理由から、
~\ref{sec:mq:tools} 節で紹介している
\command{diffstat} や \command{filterdiff} 
のようなサードパーティー製ツールの学習に、
少しでも良いので時間を費やすべきです。
前者はパッチの及ぼす変更に関してすばやい見解を得ることが、
後者はパッチ中の hunk 
を選択的に継ぎ合わせて異なるパッチに組み上げることができます。

\section{MQ クックブック}

\subsection{``些細な''パッチの管理}

真新しい Mercurial リポジトリにファイルを投入するのは、
非常にオーバーヘッドが低いので、
単にダウンロードしたソース tarball に対して変更を加えるのだとしても、
MQ によりパッチ管理を行うことは非常に理にかなっています。

まずはソース tarball のダウンロードと展開を行い、
Mercurial リポジトリに投入します。

\interaction{mq.tarball.download}

次にパッチスタックを作成し、変更を行います。

\interaction{mq.tarball.qinit}

数週間から数ヵ月経ってから、
そのパッケージの著者が新しい版をリリースしたとします。
まずはリポジトリに変更を取り込みます。

\interaction{mq.tarball.newsource}

上記手順で \hgcmd{locate} により始まるパイプラインは、
作業領域ディレクトリ中の全てのファイルを削除しますので、
\hgcmd{commit} の \hgopt{commit}{--addremove} オプションは、
新しい版においてどのファイルが本当に追加／削除されたのかを判定できます。

最後に、新しくなったソースツリーの最上位でパッチを適用します。

\interaction{mq.tarball.repush}

\subsection{パッチ全体の結合}
\label{sec:mq:combine}

MQ はパッチ全体を結合する
\hgxcmd{mq}{qfold} コマンドを提供しています。
このコマンドは、
名前を指定したパッチを指定した順序で、
最上位の適用済みパッチへと``結合''し、
それらの説明文を最上位パッチの説明文末尾へ追加します。
結合対象のパッチは、結合の時点で未適用でなければなりません。

パッチの結合順序は重要です。
最上位の適用済みパッチが \texttt{foo} で、
そこに \hgxcmd{mq}{qfold} と \texttt{quux} を
\hgxcmd{mq}{qfold} する場合、
順に \texttt{foo}、\texttt{bar} そして \texttt{quux} 
と適用するのと同じ効果を持つパッチができあがります。

\subsection{パッチの一部の他のパッチへの併合}

パッチの\emph{一部}を他のパッへ併合するのは、
パッチ全体を結合するよりも面倒です。

あるファイル（群）に対する変更全体を移動したい場合、
\command{filterdiff} の \cmdopt{filterdiff}{-i} および
\cmdopt{filterdiff}{-x} オプションを用いることで、
パッチから切り出す変更点を選択して、
その結果を併合先パッチへと取り込むことでができます。
通常は取り込み元となったパッチそのものは変更したくないものです。
そこで、
MQ は取り込み元パッチを \hgxcmd{mq}{qpush} する際に、
取り込まれた分の hunk が拒否されたことが報告されますから、
\hgxcmd{mq}{qrefresh} でパッチを更新することで、
重複した hunk を取り除くことができます。

１つのファイルに対する複数の hunk を持つパッチの一部だけが欲しい場合、
事態はもう少し厄介ですが、
それでも部分的に自動化することができます。
\cmdargs{lsdiff}{-nvv} を使うことで、
パッチに関するメタデータを表示させます。

\interaction{mq.tools.lsdiff}

このコマンドは、３つの異なる数値の類を表示します。

\begin{itemize}
\item （最初のカラムは）改変対象の個々のファイルをパッチ中で識別するための
 \emph{ファイル番号}で、

\item （字下げされた次の行には）変更されるファイルでの hunk の開始行番号と、

\item （同じ行に）hunk を識別するための \emph{hunk 番号}

\end{itemize}

必要なファイル番号や hunk 番号を特定するためには、
視覚的な精査やパッチの読解が必要とされますが、
それらの数値を \command{filterdiff} の
\cmdopt{filterdiff}{--files} や
\cmdopt{filterdiff}{--hunks} といったオプションに指定することで、
ファイルや hunk を正確に選択することができます。

一度 hunk を取り出してしまえば、
結合先パッチの末尾に結合して
~\ref{sec:mq:combine} 節の残りの作業を再開することができます。

\section{quilt と MQ の違い}

既に quilt を熟知しているのであれば、
MQ は同様のコマンド群を持っていますが、
その働きにはいくらかの違いがあります。

殆どの quilt コマンドに対して、
``\texttt{q}'' で始まる対応する 
MQ のコマンドがあることに気付くことでしょう。
但し、
quilt の \texttt{add} および \texttt{remove} コマンドに対応するのが、
Mercurial の通常の \hgcmd{add} および \hgcmd{remove} であるのが例外です。
また、MQ には quilt の \texttt{edit} に対応するコマンドはありません。

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
