\chapter{Finding and fixing your mistakes}
\label{chap:undo}

人は間違えるものですが、その結果をより上手に扱ってこそ、
優れた構成管理システムと言えます。
この章では、
プロジェクトに忍び込んだ問題を発見した際に、
使える手法について説明します。
Mercurial は、
問題の元を隔離し適切に処理するための優れた機能を持っています。

\section{Erasing local history}

\subsection{The accidental commit}

筆者は、時として考えるよりも先に入力してしまう、
という根深い問題を抱えているため、
不完全であったり、
単純に間違った内容のチェンジセットをコミットしてしまうことがあります。
筆者の場合、
不完全なチェンジセットをコミットしてしまうのは、
新しいソースファイルを作成したのに
\hgcmd{add} の実行を忘れている場合が殆どです。
``単純に間違っている''チェンジセットをコミットしてしまうケースには、
特に共通点はありませんが、but 非常に迷惑(no less annoying) XXXXX。

\subsection{Rolling back a transaction}
\label{sec:undo:rollback}

Mercurial が、
リポジトリへの個々の変更を\emph{トランザクション}として扱っていることを
\ref{sec:concepts:txn} 節で述べました。
チェンジセットをコミットしたり、
他のリポジトリから変更を pull する際に、
Mercurial は常に処理したことを記録しています。
\hgcmd{rollback} コマンドを使用することで、
きっちり一回分の処理を元に戻す、
別な言い方をするなら、\emph{巻き戻す}ことができます
（このコマンドを使用する際の重要な注意が述べられていますので、
\ref{sec:undo:rollback-after-push} 節を参照してください）。

新しくファイルを作成したのに、
そのファイルに対して \hgcmd{add} 
コマンドを実行するのを忘れてコミットしてしまう、
という筆者のよくやる間違いは、以下のようなものです。

\interaction{rollback.commit}

コミット後の \hgcmd{status} 出力を見れば、
すぐさま間違いを確証できます。

\interaction{rollback.status}

先のコミットは、
\filename{a} の変更は捉えていますが、
新規のファイル \filename{b} は把握していません。
同僚と共有しているリポジトリに、
このチェンジセットを反映してしまったら、
同僚がこのチェンジセットを取り込んだ際に、
\filename{a} 中の何かが、
同僚のリポジトリには存在しない \filename{b} を参照してしまいます。
そうなれば、私は同僚の憤りの対象になってしまうでしょう。

しかし、幸いなことに、
チェンジセットを共有リポジトリへと反映する前に、
自分の間違いを見つけています。
\hgcmd{rollback} コマンドを使うことで、
Mercurial は最後のチェンジセットを消してくれます。

\interaction{rollback.rollback}

リポジトリの履歴上、最早最前のチェンジセットは存在しませんので、
作業領域ディレクトリは、
再び \filename{a} ファイルが変更されている状態だとみなされます。
コミット後のロールバックは、
作業領域ディレクトリをコミット前の状態そのままに戻し、
チェンジセットは完全に消去されます。
そうなったなら、
安全に \filename{b} ファイルを \hgcmd{add} し、
再度コミットすることができます。

\interaction{rollback.add}

\subsection{The erroneous pull}

１つの プロジェクトで、
別々に開発の進んでいるブランチを Mercurial で保守する場合、
それぞれ異なるリポジトリで保守することが一般的な慣習となっています。
開発チームは、
プロジェクトの ``0.9'' リリース用に共有リポジトリを持つ一方で、
異なる変更履歴を持つ ``1.0'' リリース用のリポジトリを別途持つかもしれません。

この場合、
ローカルな ``0.9'' リポジトリがあって、
そこに偶然 ``1.0'' 用共有リポジトリの成果を取り込んだ場合、
面倒な事態になることが想像できます。
最悪の場合、
十分な注意を払わないために、
``1.0'' のリポジトリから取り込んだ変更を
``0.9'' の共用リポジトリへと反映してしまった
チーム全体を混乱させてしまうでしょう
（この恐ろしいケースに関しては、
後ほど解決方法を示しますので御安心を。）。
しかし、
Mercurial は成果取り込み先の URL を表示するか、
Mercurial 
が怪しげな大量の変更をリポジトリに取り込んだことが表示されますから、
すぐに気付く方があり得ます
\footnote{訳注: ``display the URL it's pulling from''
の関係がよくわからない}。

\hgcmd{rollback} コマンドは、
今まさに取り込んだ全てのチェンジセットを、
きちんと綺麗にします。
Mercurial は、一回の \hgcmd{pull} 起動により取り込まれるチェンジセット全体を、
単一のトランザクションに分類するので、
一回の \hgcmd{rollback} 起動でこの失敗を取り消すことができます。

\subsection{Rolling back is useless once you've pushed}
\label{sec:undo:rollback-after-push}

\hgcmd{rollback} は、
一旦他のリポジトリに反映した変更でも、
（手元のリポジトリにおいては）無かったことにできます。
取り消しにより変更は完全に消されますが、
それができるのは、
\hgcmd{rollback}  を実施したリポジトリにおける取り消し\emph{のみ}です。
取り消しは履歴を削除しますので、
変更の取り消しをリポジトリ間で伝播する手段が無いのです。

変更を他のリポジトリ--典型的な例では共有リポジトリ--に反映した場合、
本質的には、その変更は``野生に逃げ出し''ており、
取り消しとは別な方法で間違いを埋め合わせる必要があります。
変更を他のリポジトリに反映し、
（手元のリポジトリで）その変更を取り消した後で、
変更を反映したリポジトリから変更を取り込んだ時には、
取り消した変更が（手元のリポジトリに）再び現れます。

（取り消したい変更が、変更を反映したリポジトリにおける最新のもので、
\emph{且つ}、
誰もそれをそのリポジトリから取り込んでいないことが確実である場合、
その変更を取り消すこともできますが、
取り消しが機能することには依存しないようにしてください。
遅かれ早かれ変更は直接触ることのできない
（あるいは存在を忘れていた）リポジトリへと反映され、
回りまわって戻ってきた時に噛み付かれてしまいます。
）

\subsection{You can only roll back once}

Mercurial は、
当該リポジトリにおける最も最新のトランザクションを、
１つだけトランザクションログに記録します。
そのため、取り消せるトランザクションは１つ分だけです。
トランザクションを１つ取り消した後で、
その前のトランザクションも取り消せることを期待しても、
期待通りの結果は得られません。

\interaction{rollback.twice}

あるリポジトリでトランザクションの取り消しを行った場合、
別な変更をコミットするなり取り込むなりしない限り、
そのリポジトリで取り消しを行うことはできません。

\section{Reverting the mistaken change}

ファイルを変更した後で、
ファイルの変更が全く必要ないことに気付いた場合、
変更をコミットする前であれば、
\hgcmd{revert} コマンドが利用できます。
このコマンドは、
作業領域ディレクトリの親チェンジセットを参照し、
ファイルの内容を元の状態に戻します。
（説明すると長くなりますが、
通常の場合、このコマンドは変更を取り消します。）

\hgcmd{revert} コマンドの機能を、
ちょっとしたサンプルで説明します。
Mercurial により既に構成管理されているファイルを変更します。

\interaction{daily.revert.modify}

変更が必要ない場合、
単純に \hgcmd{revert} コマンドをファイルに適用します。

\interaction{daily.revert.unmodify}

\hgcmd{revert} コマンドは、
ある程度の安全性を確保するために、
\filename{.orig} 拡張子付きのファイルに、
変更されたファイルの内容を保存します。

\interaction{daily.revert.status}

\hgcmd{revert} コマンドが扱うことのできる状況を以下にまとめます。
個々の状況に関する詳細は、以後の節で説明します。

\begin{itemize}
\item ファイルが変更されていたなら、変更前の状態に戻します。

\item ファイルが \hgcmd{add} されていたなら、
  ファイルの``追加''されている状態を取り消しますが、
  ファイルそのものには何も変更を行いません。

\item Mercurial への指示無くファイルを削除していたなら、
  変更前\footnote{訳注: ``削除前''ではない点に注意}の状態に戻します。

\item \hgcmd{remove} コマンドでファイルを削除していたなら、
  ファイルの``削除された''状態を取り消し、
  変更前の状態に戻します。

\end{itemize}

\subsection{File management errors}
\label{sec:undo:mgmt}

\hgcmd{revert} は変更されたファイル以外に対しても有用なコマンドです。
このコマンドは、
Mercurial の全てのファイル管理コマンド
---\hgcmd{add} や \hgcmd{remove} など---
の実施を反転させます。

ファイルに対して \hgcmd{add} を行った後で、
そのファイルを Mercurial で構成管理する必要が無いことに気付いたなら、
\hgcmd{revert} によりファイルの追加を取り消せます。
Mercurial はファイル自体には何も変更を行いませんので安心してください。
ファイル追加の取り消しは、
ファイルに対して``印を消す''だけです。

\interaction{daily.revert.add}

同様に、
ファイルに対して \hgcmd{remove} を行った後でも、
\hgcmd{revert} を使うことで、
作業領域ディレクトリの親チェンジセットにおける状態に、
ファイルの内容を復旧することができます。

\interaction{daily.revert.remove}

これは、Mercurial を通さずに手動で削除したファイル
（Mercurial の用語ではこの種のファイルが``紛失''(missing)
と呼ばれることを思い出してください）であっても機能します。

\interaction{daily.revert.missing}

\hgcmd{copy} されたファイルに取り消しを行った場合、
複製先ファイルは作業領域ディレクトリに、
構成管理されない状態でそのまま残ります。
複製操作は複製元ファイルには何も作用しないので、
取り消しの際に Mercurial は複製元ファイルに対して特に何もしません。

\interaction{daily.revert.copy}

\subsubsection{A slightly special case: reverting a rename}


ファイルに対して \hgcmd{rename} を行った場合、
覚えていて欲しいことがあります。
\hgcmd{rename} 実行に対して \hgcmd{revert} を行う際には、
以下に示すように、
変更後のファイル名を指定しただけでは不十分です。

\interaction{daily.revert.rename}

\hgcmd{status} コマンドの出力からもわかるように、
変名後のファイルは既に未追加状態と認識されていますが、
変名\emph{前}のファイルは未だに削除状態と認識されています！
これは（少なくとも著者にとっては）直感に反しますが、
扱いは簡単です。

\interaction{daily.revert.rename-orig}

\hgcmd{rename} の取り消しを行うには、
変名前後のファイル名を\emph{両方}指定することを忘れないでください。

（ちなみに、
ファイルの変名後に、変名後のファイルを変更し、
それから変名前後のファイル名の両方を指定して取り消しを行った場合、
Mercurial は変名の際に削除されたファイル\footnote{訳注: 変名前のファイル
}を何も変更されていない状態に戻します。
変名後のファイルに対する変更を変名前ファイルに反映したい場合には、
変名後ファイルから変名前ファイルへのコピーを忘れないでください。
）

変名の取り消しにおけるこれらの厄介な側面は、
おそらく Mercurial の小さなバグに由来するものです。

\section{Dealing with committed changes}

ある変更 $a$ をコミットし、その上で別の変更 $b$ をコミットした後で、
変更 $a$ が間違っていたことに気付いたとします。
Mercurial には、
チェンジセットそのものを自動的に``無かったことにする''機能や、
チェンジセットの一部を手動で無効にするための情報を提供する機能があります。

この節を読む前に、覚えておいて欲しいことが幾つかあります。
\hgcmd{backout} コマンドによる変更の取り消しは、
履歴を\emph{追加}することで行われるものであり、
変更そのものを修正したり削除したりするものではありません。
そのため、バグの修正をするのには向いていますが、
破壊的な結果を伴う取り消しといった用途には向いていません。
そのような取り消しに関しては、
~\ref{sec:undo:aaaiiieee} 節を参照してください。

\subsection{Backing out a changeset}

\hgcmd{backout} コマンドは、
自動化された形式でチェンジセットの効果全体を``取り消し''ます。
Mercurial の履歴は改変できないので、
このコマンドは取り消したいチェンジセットを取り除いたりは\emph{しません}。
その代わりにこのコマンドは、
取り消したいチェンジセットによる改変内容を\emph{反転}させる、
新たなチェンジセットを作成します。

\hgcmd{backout} コマンドの操作は少々複雑ですので、例を使って説明します。
まずは単純なチェンジセットを幾つか持つリポジトリを作成します。

\interaction{backout.init}

\hgcmd{backout} コマンドは、
``bakc out''対象とする単一のチェンジセット識別子を引数に取ります。
通常、
\hgcmd{backout} 
はコミットメッセージを書くためにテキストエディタを起動しますので、
変更を back out する理由を記録することができます。
この例では、
\hgopt{backout}{-m} オプションを用いることで、
コマンドラインからコミットメッセージを与えています。

\subsection{Backing out the tip changeset}

以下の例では、
最後にコミットしたチェンジセットを back out します。

\interaction{backout.simple}

\filename{myfile} が既に２行目を持たないことがおわかりでしょう。
\hgcmd{log} 出力を見れば、
\hgcmd{backout} コマンドが何を行ったかを理解できます。

\interaction{backout.simple.log}

\hgcmd{backout} が生成した新しいチェンジセットは、
back out したチェンジセットの子チェンジセットとなる点に注意してください。
変更履歴を図示した \ref{fig:undo:backout}~図を見れば、
このことがわかるでしょう。
ご覧の通り、履歴は見事に一直線です。

\begin{figure}[htb]
  \centering
  \grafix{undo-simple}
  \label{fig:undo:backout}
  \caption{Backing out a change using the \hgcmd{backout} command}
\end{figure}

\subsection{Backing out a non-tip change}

最後にコミットしたチェンジセット以外を back out したい場合、
\hgcmd{backout} コマンドに
\hgopt{backout}{--merge} オプションを指定してください。

\interaction{backout.non-tip.clone}

このコマンド実行は、
任意のチェンジセットを、
簡単で素早い``一回限りの''操作で back out できます。

\interaction{backout.non-tip.backout}

back out 完了後の \filename{myfile} の内容には、
１回目と３回目の変更に相当する内容は見ることができますが、
２回目の変更に相当する内容は見ることができないでしょう。

\interaction{backout.non-tip.cat}

履歴を図示した \ref{fig:undo:backout-non-tip}~図に見られるように、
このような状況の場合、
Mercurial は実際には\emph{２つ}のチェンジセットをコミットします
（Mercurial が自動的にコミットしたも\footnote{訳注: 
実行例で Mercurial が出力するメッセージを見ればわかるように、
マージされたチェンジセットのコミットは利用者責任となっているため、
「自動的にコミット」したものではなく
「自動的に生成したもの」が正しい表現です。}のは矩形で示してあります）。
Mercurial は back out 処理を始める前に、
現時点での作業領域ディレクトリにおける親チェンジセットを覚えておきます。
その上で対象チェンジセットを back out し、
チェンジセットとしてコミットします。
最後に、
作業領域ディレクトリの親チェンジセットとマージした結果をコミットします
footnote{訳注: 前述のように、自動的にはコミットされません}。

\begin{figure}[htb]
  \centering
  \grafix{undo-non-tip}
  \label{fig:undo:backout-non-tip}
  \caption{Automated backout of a non-tip change using the \hgcmd{backout} command}
\end{figure}

結果として、
back out したいチェンジセットによる変更内容を取り消すための、
幾つかの余分な履歴のみを伴って、
``以前の状態への復旧''が行われます。

\subsubsection{Always use the \hgopt{backout}{--merge} option}

実のところ、
back out 対象のチェンジセットが tip か否かに関わらず、
\hgopt{backout}{--merge} オプションは``正しく機能''します
（back out 対象が tip の場合は、必要が無いのでマージしようとはしません）
ので、
\hgcmd{backout} コマンドを実行する際には\emph{常に}
\hgopt{backout}{--merge} オプションを指定するべきでしょう。

\subsection{Gaining more control of the backout process}

先の記述では、変更の back out の際の
\hgopt{backout}{--merge} オプションの常用を推奨しましたが、
その一方で、
back out 対象となるチェンジセットのマージ方法を、
\hgcmd{backout} コマンドの利用者が決定することもできます。
back out 処理を手動で制御する必要は滅多にありませんが、
手動制御の方法を知ることは、
\hgcmd{backout} が自動的に行っていることの内情を理解する上で有用です。
手動制御の説明のために、
最初に作成したリポジトリを複製しますが、
ここでは back out は行いません。

\interaction{backout.manual.clone}

先の例と同様に、
第３のチェンジセットをコミットし、
その上でその親を back out した結果を見てみましょう。

\interaction{backout.manual.backout} 

新たなチェンジセットも第３のチェンジセット同様に、
back out 対象のチェンジセットの子になりますので、
それまで tip だったチェンジセット\footnote{訳注: 第３のチェンジセットのこと}
の子\emph{ではなく}、新たなヘッドになります。
\hgcmd{backout} コマンドは、
このことを告げる非常にはっきりとしたメッセージを表示しています。

\interaction{backout.manual.log}

ここでも、
履歴を図示した\ref{fig:undo:backout-manual}~図を見ることで、
どういった状況にあるのかが理解し易いと思います。
この図から、
\hgcmd{backout} コマンドを tip 以外のチェンジセットに適用した際に、
Mercurial が新しいヘッドをリポジトリに追加する
（Mercurial により追加されたチェンジセットは矩形で表しています）
ことがよくわかります。

\begin{figure}[htb]
  \centering
  \grafix{undo-manual}
  \label{fig:undo:backout-manual}
  \caption{Backing out a change using the \hgcmd{backout} command}
\end{figure}

\hgcmd{backout} コマンドの実行が完了すると、
作業領域ディレクトリの親チェンジセットが、
新しい ``backout'' チェンジセットになります。

\interaction{backout.manual.parents}

この時点で、２つの独立した変更のまとまり
\footnote{訳注: マージが必要な「複数ヘッド状態」のことを指していると思われます}
が存在します。

\interaction{backout.manual.heads}

この時点で、\filename{myfile} 
はどのような内容であることが期待されるかを考えてみましょう。
第１の変更は back out していませんから、
それに関する内容は存在していなければなりません。
第２の変更は back out しましたので、
それに関する内容は消失していなければなりません。
履歴図で別個のヘッドとして図示されているように、
第３の変更に関する内容が
\filename{myfile} に存在しては\emph{なりません}。

\interaction{backout.manual.cat}

第３の変更の内容をファイルに取り込むには、
２つのヘッドをいつものようにマージすれば良いのです。

\interaction{backout.manual.merge}

マージすることで、
リポジトリ中の履歴は
\ref{fig:undo:backout-manual-merge}~図に示すようになります。

\begin{figure}[htb]
  \centering
  \grafix{undo-manual-merge}
  \caption{Manually merging a backout change}
  \label{fig:undo:backout-manual-merge}
\end{figure}

\subsection{Why \hgcmd{backout} works as it does}

\hgcmd{backout} コマンドの振る舞いを簡単にまとめると以下のようになります。

\begin{enumerate}
\item 作業領域ディレクトリが``クリーン''な状態、
  即ち \hgcmd{status} の出力が空であることを確認します。

\item その時点での作業領域ディレクトリの親チェンジセットを覚えておきます。
  以下、このチェンジセットを \texttt{orig} と呼称します。

\item 作業領域ディレクトリを back out 対象チェンジセットに同期するために、
  \hgcmd{update} と同等の処理を行います。
  以下、このチェンジセットを \texttt{backout} と呼称します。

\item \texttt{backout} の親チェンジセットを調べます。
  以下、この親チェンジセットを \texttt{parent} と呼称します。

\item \texttt{backout} チェンジセットが影響する個々のファイルに対して、
  \hgcmdargs{revert}{-r parent} 相当の処理を行い、
  \texttt{backout} チェンジセットがコミットされる前の内容に復元します。

\item 復元結果を新しいチェンジセットとしてコミットします。
  このチェンジセットの親は \texttt{backout} です。

\item コマンドラインで \hgopt{backout}{--merge} が指定されていた場合、
  新しいチェンジセットと \texttt{orig} をマージし、
  その結果をコミットします。

\end{enumerate}

作業領域ディレクトリを弄繰り回すことなく
\hgcmd{backout} コマンド相当の効果を得るもう一つの方法は、
back out されるチェンジセットに対して \hgcmd{export}
することで得た diff ファイルを、
作用を反転させる
\cmdopt{patch}{--reverse} オプションを指定した
\command{patch} コマンドに用いることです。
この方法は非常に簡単に感じるでしょうが、
全く上手く機能しません。

\hgcmd{backout} が update、commit、merge および再度の commit を行うのは、
back out 対象のチェンジセットと現在の tip 
の\emph{間}の全てのチェンジセットを扱う際に、
良好な結果を得るための最善の機会を Mercurial のマージ機構に与えるためです。

例えば、
プロジェクトの履歴から、100 リビジョン分前のチェンジセットを
back out しようとした場合、
\command{patch} がパッチの適用可否を判定するコンテキスト情報を、
back out 対象との間にあるチェンジセットが``破壊''してしまうかもしれない
（この意味がわからない場合は、
\ref{sec:mq:patch}~節の \command{patch} に関する説明を参照してください）
ので、
\command{patch} コマンドが反転 diff を綺麗に適用できることは期待できません。
Mercurial のマージ機構は、
ファイルやディレクトリの変名、
ファイル権限の変更や、
バイナリファイルの変更といった
\command{patch} コマンドが扱うことのできないものも扱うことができます。

\section{Changes that should never have been}
\label{sec:undo:aaaiiieee}

変更内容を取り消そうとした場合の殆どは、
\hgcmd{backout} コマンドの利用が妥当です。
\hgcmd{backout} コマンドは、
元のチェンジセットのコミットと、
後からそれを取り消した際の両方に関して、
正確で永続的な記録を残します。

しかし、非常に稀な状況ですが、
リポジトリ中に存在して欲しくない変更をコミットしてしまうかもしれません。
例えば、
ソースファイルと同様にオブジェクトファイルをコミットしてしまうような事態は、
滅多に無いので通常は「間違い」とみなされます。
オブジェクトファイルには本質的な価値はありませんし、
非常に\emph{サイズが大きい}ですから、
リポジトサイズや複製／変更取り込みに要する時間が増加してしまいます。

XXXXXXXXXX
Before I discuss the options that you have if you commit a ``brown
paper bag'' change (the kind that's so bad that you want to pull a
brown paper bag over your head), let me first discuss some approaches
that probably won't work.
XXXXXXXXXX

Mercurial は履歴を「蓄積的なもの」---
全ての変更が先行する変更の上に適用される---として扱いますので、
破壊的な影響を持つチェンジセットに対してであっても、
それを破棄することは通常はできません。
\ref{sec:undo:rollback}~節で詳細を述べますが、
例外的に \hgcmd{rollback} コマンドを安全に使用できるのは、
変更をコミットした直後で、
別なリポジトリへ \hgcmd{push} も \hgcmd{pull} もされていない場合だけです。

不適切なチェンジセットを他のリポジトリへ 
\hgcmd{push} してしまった\emph{後でも}、
\hgcmd{rollback} コマンドにより、
ローカルなリポジトリでそのチェンジセットを破棄することはできますが、
それはおそらく本来やりたかったことでは無い筈です。
遠隔リポジトリ中には不適切なチェンジセットが存在し続けますので、
次に変更の取り込みを行った際には、
その変更が再びローカルリポジトリに現れるかもしれません。

このような状況が発生した場合、
どのリポジトリが不適切なチェンジセットを保持しているかを把握しているなら、
それら\emph{全ての}リポジトリからの不適切なチェンジセットの除去を、
\emph{試みる}ことが可能です。
勿論、これは申し分の無い解法ではありません。
たった一つでも抹消し損ねたリポジトリがあれば、
``野に放たれた''ままのチェンジセットは更に伝播してしまうでしょう。

除去したいチェンジセットの\emph{後に}、
幾つかのチェンジセットをコミットしてしまった場合、
取り得る選択肢は更に限られてしまいます。
Mercurial は、
チェンジセットに手をつけないままで、
履歴に``穴を開ける''機能は提供していません。

XXX This needs filling out.  
\texttt{examples} ディレクトリ配下の
\texttt{hg-replay} スクリプトは機能しますが、
チェンジセットのマージを行いません。
重大な手抜きです。

\subsection{Protect yourself from ``escaped'' changes}

ローカルリポジトリにコミットした幾つかのチェンジセットが、
\hgcmd{push} ないし \hgcmd{pull} 
等によってそれらが他のリポジトリへと反映されたからといって、
そのこと自体は必ずしも大失敗というわけではありません。
ある種の不正なチェンジセットに対して、
あらかじめ自己防衛することも可能です。
開発チームが変更を中央のリポジトリから \hgcmd{pull} するような体制の場合、
事故防衛は非常に簡単です。

中央のリポジトリの幾つかのフックを、
追加されるチェンジセットの検証を行うように設定する
（\ref{chap:hook}~章を参照してください）ことで、
ある種の不正なチェンジセットが、
中央リポジトリに全く反映されないように自動化することができます。
設定が適切であれば中央のリポジトリに反映できなくなるため、
このようなチェンジセットは自然と``死に絶え''ます。
なお良いことに、この手法は明示的な介入を必要としません。

例えば、当該チェンジセットが実際にコンパイル可能かどうかを検証する
incoming フックは、
うっかり``ビルドできなくしてしまう''ことを防止できます。

\section{Finding the source of a bug}
\label{sec:undo:bisect}

バグをもたらしたチェンジセットを back out できるのは非常に結構なのですが、
どのチェンジセットを back out すべきかを知っている必要があります。
Mercurial には、
チェンジセット特定の自動化と非常に効率的な実施を補助する、
\hgext{bisect} と呼ばれる重要な拡張があります。

チェンジセットによる変更は振る舞いに変化をもたらすので、
その変化を簡単な２値テストによりそれを特定することができる、
というのが \hgext{bisect} 拡張の原理です。
どのコード片が変化をもたらしているのかはわからなくても、
バグの有無を試験する方法はわかるでしょう。
\hgext{bisect} 拡張は、
バグの原因となったコードをもたらしたチェンジセットを探すのに、
あなたのテストプログラムを直接使用します。

\hgext{bisect} 拡張の適用方法を理解しやすいように、
幾つかのシナリオを例示します。

\begin{itemize}
\item 数週間前には見られなかったバグが、最新の版で発見されましたが、
  何時それが混入されたのかがわかりません。
  この場合、binary test でバグの有無を調べることができます
  \footnote{訳注: 「バグの有無」という２値を判定するテストを用いることで、
  バグの混入したチェンジセットを探します}。

\item 大急ぎでバグを修正し、
  開発チームのバグデータベースの状態を「クローズ」にできるようになりました。
  「クローズ」状態にする際に、
  バグデータベースがチェンジセットIDを求めてきましたが、
  どのチェンジセットでバグを修正したのか覚えていませんでした。
  ここで再び binary test  でバグの有無を調べることができます。

\item ソフトウェアが正しく動作していますが、
  以前計測した時よりも 15\% 遅くなってました。
  どのチェンジセットが性能低下の要因となっているのかを知りたいです。
  この場合、binary test はソフトウェアの性能を計測し、
  ``早い''のか``遅い''のかを判定します。

\item ここ最近、
  出荷したプロジェクトの構成要素のサイズが爆発的に大きくなっていて、
  プロジェクトのビルド手順の何らかが変更されたのではないかと推測しています
  \footnote{訳注: ビルド結果の「構成要素サイズの大小」
  という２値を判定するテストを用いることで、
  変更が混入されたチェンジセットを探します}。

\end{itemize}

これらの例から、
\hgext{bisect} 拡張がバグの元を探すだけのものでないことは明らかでしょう。
その特性に関する２値テストを書けるなら、
リポジトリにおける
（ソースツリー中のファイルに対する単純な文字列検索では探し出せない）
任意の``特性の出現''を探し出すことができます。

利用者と Mercurial のそれぞれが、
検索処理においてどの部分に責任を負うのかをはっきりとさせるために、
ここでもう少し用語の説明をしましょう。
\emph{テスト}(test)とは、
\hgext{bisect} 拡張がチェンジセットを選択する際に、
\emph{利用者}が実行するものです。
\emph{調査}(probe)とは、
あるリビジョンの良否を判定するために \hgext{bisect} が実行するものです。
最後に、
``bisect'' という言葉を、
``\hgext{bisect} 拡張を用いた検索''の代用として、
名詞および動詞として使用します。

検索処理を自動化する簡単な方法の一つが、
全てのチェンジセットを調査する遣り方です。
しかしながら、この遣り方には殆どスケーラビリティがありません。
１つのチェンジセットのテストに１０分必要で、
リポジトリに１万のチェンジセットがあったとすると、
徹底的に調査する遣り方では、
バグをもたらしたチェンジセットを見つけるのに、
平均で３５~\emph{日}必要です。
検索対象を最新の５００チェンジセットに限定できるとしても、
バグをもたらしたチェンジセットを見つけるのには、
それでもなお４０時間必要です。

\emph{bisect} 拡張は、
確認するチェンジセット数に対して\emph{対数}のオーダーで検索
（この種の検索は``二分探索''と呼ばれます）できるように、
プロジェクト履歴の``形''に関する情報を利用します。
この方法により、
仮にテストあたりの所要時間が１０分掛かるとしても、
１万チェンジセットに対する検索は２時間以内で終わります。
検索対象を最新の５００チェンジセットに限定できるならば、
１時間以内に検索できるでしょう。

\hgext{bisect} 拡張は、
Mercurial で管理されているプロジェクトの履歴の持つ
``枝分かれ''の特質をわかっていますので、
リポジトリにおける枝分かれ・マージ・複数ヘッドの扱いも問題ありません。
単一の調査で履歴の枝分かれ全体を刈り取る\footnote{訳注:
「枝分かれ先全体を検索対象から除外する」の意}ことができるため、
\hgext{bisect} 拡張は効率的に検索することができるのです。

\subsection{Using the \hgext{bisect} extension}

ここでは \hgext{bisect} 拡張の実行例を示します。
Mercurial 自体の簡便性を維持するために、
\hgext{bisect} は拡張機能として提供されます。
そのため、明示的に有効にしなければ、その機能は提供されません。
\hgext{bisect} 拡張を有効にするには、
（存在しない場合には） \hgrc\ に以下のセクションヘッダを追加し：

\begin{codesample2}
  [extensions]
\end{codesample2}

続いて、\hgext{bisect} 拡張を有効化するための行をこのセクションに追加します
\footnote{1.0 版以降の Mercurial では、
\hgext{bisect} 機能は基本機能に取り込まれていますので、
「拡張機能の有効化」は不要です}。

\begin{codesample2}
  hbisect =
\end{codesample2}

\begin{note}
  \hgext{bisect} 拡張の名前の先頭に``\texttt{h}''が付くのは間違っていません。
  この文字が付くのは、Mercurial が Python で実装されていて、
  Python の標準ライブラリの \texttt{bisect} を使用しているためです。
  誤って ``\texttt{hbisect}''から``\texttt{h}''を省略した場合、
  \hgrc ファイルの記述のスペルを修正するまでは、
  Mercurial は Python 標準の \texttt{bisect} パッケージを見つけ出し、
  それを Mercurial 拡張として利用しようとしてクラッシュし続けることでしょう。
\end{note}

\hgext{bisect} 拡張を隔離して利用するために、
リポジトリを作成しましょう。

\interaction{bisect.init}

ループによって幾つかの些細な変更を行い、
その中の特定の変更が``バグ''を持つようにする、
という単純な方法で、
バグを持ったプロジェクトのシミュレーションを行います。
このループは 50 のチェンジセットを生成し、
それぞれが１つのファイルをリポジトリに追加します。
ここでは、
ファイルが``i have a gub''というテキストを含んでいることをもって、
``バグ''とみなします。

\interaction{bisect.commits}

それでは、\hgext{bisect} 拡張の使用方法を理解しましょう。
\hgext{bisect} 拡張に関しても、
通常の Mercurial の組み込み help 機能が使用できます。

\interaction{bisect.help}

\hgext{bisect} 拡張は段階を踏んで機能します。
各段階は以下のように進みます。

\begin{enumerate}
\item ２値テストを実行します。
  \begin{itemize}
  \item テストが成功した場合、
    \hgcmdargs{bisect}{good} コマンドにより 
    \hgext{bisect} 拡張にそのことを伝えます。
  \item テストが失敗した場合、
    \hgcmdargs{bisect}{bad} コマンドにより
    \hgext{bisect} 拡張にそのことを伝えます。
  \end{itemize}
\item \hgext{bisect} 拡張は伝えられた情報を元に、
  次にテストすべきチェンジセットを決定します。

\item \hgext{bisect} 拡張は、
  作業領域ディレクトリをそのチェンジセットで更新しますので、
  以上の手順を繰り返します。

\end{enumerate}

２値テストの結果が``成功''から``失敗''に変化した点を示す、
一意なチェンジセットを \hgext{bisect} 拡張が特定できた時点で、
この手順は終了します。

検索の開始に当たっては、
\hgcmdargs{bisect}{init} コマンドの実行が必要です。

\interaction{bisect.search.init}

今回の実行例で使用する２値テストは簡単なもので、
リポジトリ中の何れかのファイルが
``i have a gub'' 文字列を含んでいるか否かを判定します。
含んでいる場合、そのチェンジセットは
``バグの要因となる''チェンジセットです。
慣習上、
検索対象となる特性を持っているチェンジセットを ``bad''、
持っていないチェンジセットを ``good'' と呼びます。
多くの場合、
作業領域ディレクトリが同期しているリビジョン（通常は tip）
はバグを持つチェンジセットにより問題を抱えているものですから、
これを``bad''とみなします。

\interaction{bisect.search.bad-init}

次の作業は、
バグが\emph{無い}チェンジセットを指定することです。
\hgext{bisect} 拡張は
最初の ``good'' と ``bad'' のチェンジセット間の検査状況を
``括弧''で括って表示するでしょう。
今回の事例では、
リビジョン 10 にはバグがありません
（最初の ``good'' チェンジセットの選択に関しては、
後ほど補足があります）。

\interaction{bisect.search.good-init}

コマンド出力には以下の意味があります。

\begin{itemize}
\item バグをもたらしたチェンジセットの特定までに、
  どれだけのチェンジセットに対して考慮が必要であるか、
  また、どれだけのテストを要求するかを表示します。

\item \hgext{bisect} 
  拡張は次にテストすべきチェンジセットへと作業領域ディレクトリを更新し、
  どのチェンジセットがテスト対象であるのかを表示します。

\end{itemize}

早速作業領域ディレクトリでテストをしてみましょう。
\command{grep} を使用して、
作業領域ディレクトリの``bad''ファイルの有無を調べ、
ファイルが無ければそのリビジョンは``good''です。

\interaction{bisect.search.step1}

このテストは完全に自動化できそうですので、
シェル関数にしてしまいましょう。

\interaction{bisect.search.mytest}

これで、
テスト手順全体を単一の
\texttt{mytest} コマンドで実行できます。

\interaction{bisect.search.step2}

テスト手順が記録されたコマンドをあと数回起動することで、
当初の目的が達成されます。

\interaction{bisect.search.rest}

40 程のチェンジセット全体の検索にも関わらず、
\hgext{bisect} 
拡張はわずか５回のテストで``バグ''をもたらしたチェンジセットを特定できました。
調査対象チェンジセット数に対して、
\hgext{bisect} 拡張は対数のオーダーでテスト対象を選定するので、
チェンジセットを追加しただけテスト回数が増加する
``力尽く''の手法よりも有利です。

\subsection{Cleaning up after your search}

リポジトリにおける \hgext{bisect} 拡張の使用が終わったなら、
検索に使用していた情報を
\hgcmdargs{bisect}{reset} コマンドにより破棄することができます。
\hgext{bisect} 拡張はそれほど多くの領域を消費するわけではありませんので、
この作業を忘れても問題にはなりません。
しかし、\hgcmdargs{bisect}{reset} を実行するまでは、
\hgext{bisect} はそのリポジトリで別の検索を開始させてくれません。

\interaction{bisect.search.reset}

\section{Tips for finding bugs effectively}

\subsection{Give consistent input}

\hgext{bisect} 拡張には、
実施した全てのテストの結果が正しく指定されなければなりません。
本当はテストが成功していたにも関わらず、
テストの失敗を \hgext{bisect} 拡張に伝えた場合、
矛盾した結果を出す\emph{かも}しれません。
テスト結果に対して矛盾が検知された場合、
\hgext{bisect} は、
特定のチェンジセットが``good''でも``bad''でもある、
と言ってきます。
しかし、この検知は完璧に行われるわけではないので、
間違ったチェンジセットをバグの要因として報告するでしょう。

\subsection{Automate as much as possible}

筆者が \hgext{bisect} 拡張を使い始めた頃は、
検索のためのテストをコマンドラインで手動で実行していましたが、
少なくとも私には、この手法は馴染みません。
何度か \hgext{bisect} を使用した後で、
最終的に正しい結果を得る前に、
いつも手違いのために何度も検索をやり直していることに気付きました。

\hgext{bisect} 拡張を手動で駆動していた際には、
小さなリポジトリにおける単純な検索であっても問題が発生していました。
テストの内容が複雑であったり、
\hgext{bisect} が要求するテスト実行回数が増えれば、
それだけテスト実行における操作ミスの可能性は高まります。
テストを自動化するようになって以来、
非常に良好な結果を得られています。

テスト自動化のための鍵は２つあります。

\begin{itemize}
\item 常に同じ「症状」をテストすることと、
\item 常に一貫した入力を \hgcmd{bisect} コマンドに与えること
\end{itemize}

前述の実行例では、
\command{grep} コマンドにより「症状」を調べていて、
\texttt{if} ステートメントが「検査」の結果を受けて
\hgcmd{bisect} コマンドに同じ入力を与えることを保証していました。
\texttt{mytest} 関数が、
これらを再現しやすい形式に統合したことで、
全てのテストが均一で整合性の取れたものになっています。

\subsection{Check your results}

\hgext{bisect} による検索の出力結果は与えた情報程度にしか正しくないので、
\hgext{bisect} により ``good'' と報告されたチェンジセットを、
絶対的に正しいものとみなさないでください。
報告内容をクロスチェックする簡単な方法は、
以下のようなチェンジセットのそれぞれに対して、
手動で自身のテストを実行してみることです。

\begin{itemize}
\item 最初の ``bad'' リビジョンであると報告されたもの
  （以下、「障害チェンジセット」と呼称）。
  あなたのテストはこれに関して ``bad'' と報告しなければなりません。

\item 上記チェンジセットの親チェンジセット
  （マージされた場合は両方の親）。
  あなたのテストはこれ（これら）に関して ``good'' と報告しなければなりません。

\item 障害チェンジセットの子チェンジセット。
  あなたのテストはこれに関して ``bad'' と報告しなければなりません。

\end{itemize}

\subsection{Beware interference between bugs}

あるバグを探す際に、
他のバグの存在により混乱させられる可能性もあります。
例えば、
リビジョン 100 でソフトウェアがクラッシュし、
リビジョン 50 では正しく動作していたとします。
あなたの知らない間に、
ソフトウェアをクラッシュさせる別のバグを、
他の人がリビジョン 60 で入れてしまい、
それをリビジョン 80 で修正した場合、
なんらかの方法で検索結果を混乱させるかもしれません。

他のバグの存在によって、
探しているバグが完全に``覆い隠される''かもしれず、
探しているバグがその存在を示す機会を得る前に他のバグが発生している、
と言えます。
他のバグを回避したテストが
（例えば、そのバグがプロジェクトのビルドを阻害するなどの理由で）
できないために、
特定のチェンジセットにおける検索対象のバグの有無を明言できない場合、
\hgext{bisect} 拡張の助けを直接受けることはできません。
その替わり、
他のバグが存在するチェンジセットを手動で取り除くことで、
``周辺''での別な検索を行いましょう。

バグの存在に関するテストが十分明確でない場合には、
別な問題が発生し得ます。
``プログラムのクラッシュ''でバグの有無を確認している場合、
ソフトウェアをクラッシュさせる全然関係ないバグにより、
検索対象であるバグが覆い隠されてしまい、
両方とも同じものとみなされるために、
\hgext{bisect} が惑わされてしまいます。

\subsection{Bracket your search lazily}

検索における終端の印となる
``good'' および ``bad'' なチェンジセットの最初の選択は、
通常は簡単なことですが、
そうであっても多少は議論の余地があります。
\hgext{bisect} の立場から見た場合、
``最新''のチェンジセットは通例では``bad''で、
最古のチェンジセットは``good''です。

\hgext{bisect} の使用に当たって
``good''にふさわしいチェンジセットがどれかを思い出すのが難しい場合には、
でたらめにテストするのも悪くはないでしょう。
どうあってもバグの兆候が見出せない
（例えば、バグの発生に関連する機能がまだ提供されていない）ものや、
他の問題が（前述したように）バグを覆い隠してしまうようなものを、
テスト候補のチェンジセットから除外するのを忘れないようにしましょう。

数千のチェンジセット、
ないし数ヶ月の履歴の``初期''のものが最終結果だったとしても、
対数オーダーの振る舞いのお陰で、
\hgext{bisect} が実施しなければならない総回数が数回増えるだけです。

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "00book"
%%% End: 
